<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Apache Pekko Http: Modern, fast, asynchronous, streaming-first HTTP server and client.">
<link rel="shortcut icon" href="assets/images/pekko_favicon.png">
<title>1. Introduction · Apache Pekko HTTP</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="assets/stylesheets/application-palette.22915126.css">
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="assets/stylesheets/pekko-theme.css">
</head>
<body
data-md-color-primary="white"
data-md-color-accent="orange"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="Apache Pekko HTTP" class="md-header-nav__button md-logo">
<img src="assets/images/pekko_logo.png" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Apache Pekko HTTP
</span>
<span class="md-header-nav__topic">
1. Introduction
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="Apache Pekko HTTP" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="assets/images/pekko_logo.png" width="24" height="24">
</a>
<a href="index.html" title="Apache Pekko HTTP">
Apache Pekko HTTP
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/apache/incubator-pekko-http"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
apache/incubator-pekko-http
</div>
</a>

</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<ul>
  <li><a href="security.html" class="page">! Security Announcements !</a>
  <ul>
    <li><a href="security.html#receiving-security-advisories" class="header">Receiving Security Advisories</a></li>
    <li><a href="security.html#reporting-vulnerabilities" class="header">Reporting Vulnerabilities</a></li>
    <li><a href="security.html#references" class="header">References</a></li>
  </ul></li>
  <li><a href="release-notes/index.html" class="page">0. Release Notes</a></li>
  <li><a href="introduction.html#1-introduction" class="active page">1. Introduction</a>
  <ul>
    <li><a href="introduction.html#philosophy" class="header">Philosophy</a></li>
    <li><a href="introduction.html#using-apache-pekko-http" class="header">Using Apache Pekko HTTP</a></li>
    <li><a href="introduction.html#routing-dsl-for-http-servers" class="header">Routing DSL for HTTP servers</a></li>
    <li><a href="introduction.html#marshalling" class="header">Marshalling</a></li>
    <li><a href="introduction.html#streaming" class="header">Streaming</a></li>
    <li><a href="introduction.html#low-level-http-server-apis" class="header">Low-level HTTP server APIs</a></li>
    <li><a href="introduction.html#http-client-api" class="header">HTTP Client API</a></li>
    <li><a href="introduction.html#the-modules-that-make-up-apache-pekko-http" class="header">The modules that make up Apache Pekko HTTP</a></li>
  </ul></li>
  <li><a href="usage.html" class="page">2. Usage</a>
  <ul>
    <li><a href="configuration.html" class="page">Configuration</a></li>
    <li><a href="migration-guide/index.html" class="page">Migration Guides</a></li>
    <li><a href="compatibility-guidelines.html" class="page">Compatibility Guidelines</a></li>
  </ul></li>
  <li><a href="common/index.html" class="page">3. Data Types &amp; Abstractions</a>
  <ul>
    <li><a href="common/http-model.html" class="page">HTTP Model</a></li>
    <li><a href="common/uri-model.html" class="page">The URI model</a></li>
    <li><a href="common/marshalling.html" class="page">Marshalling</a></li>
    <li><a href="common/unmarshalling.html" class="page">Unmarshalling</a></li>
    <li><a href="common/encoding.html" class="page">Encoding / Decoding</a></li>
    <li><a href="common/json-support.html" class="page">JSON Support</a></li>
    <li><a href="common/xml-support.html" class="page">XML Support</a></li>
    <li><a href="common/sse-support.html" class="page">Server-Sent Events Support</a></li>
    <li><a href="common/timeouts.html" class="page">Timeouts</a></li>
    <li><a href="common/caching.html" class="page">Caching</a></li>
  </ul></li>
  <li><a href="server-side/index.html" class="page">4. Server API</a>
  <ul>
    <li><a href="routing-dsl/index.html" class="page">Routing DSL</a></li>
    <li><a href="server-side/low-level-api.html" class="page">Core Server API</a></li>
    <li><a href="server-side/websocket-support.html" class="page">Server WebSocket Support</a></li>
    <li><a href="server-side/server-https-support.html" class="page">Server HTTPS Support</a></li>
    <li><a href="server-side/graceful-termination.html" class="page">Graceful termination</a></li>
    <li><a href="server-side/http2.html" class="page">Server-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="client-side/index.html" class="page">5. Client API</a>
  <ul>
    <li><a href="client-side/configuration.html" class="page">Configuration</a></li>
    <li><a href="client-side/request-and-response.html" class="page">HttpRequest and HttpResponse</a></li>
    <li><a href="client-side/request-level.html" class="page">Request-Level Client-Side API</a></li>
    <li><a href="client-side/host-level.html" class="page">Host-Level Client-Side API</a></li>
    <li><a href="client-side/connection-level.html" class="page">Connection-Level Client-Side API</a></li>
    <li><a href="client-side/pool-overflow.html" class="page">Pool overflow and the max-open-requests setting</a></li>
    <li><a href="client-side/client-https-support.html" class="page">Client-Side HTTPS Support</a></li>
    <li><a href="client-side/client-transport.html" class="page">Pluggable Client Transports / HTTP(S) proxy Support</a></li>
    <li><a href="client-side/websocket-support.html" class="page">Client-Side WebSocket Support</a></li>
    <li><a href="client-side/http2.html" class="page">Client-Side HTTP/2 (Preview)</a></li>
  </ul></li>
  <li><a href="extensions.html" class="page">6. Extensions</a></li>
  <li><a href="technologies.html" class="page">7. Supported Technologies</a>
  <ul>
    <li><a href="technologies.html#http" class="header">HTTP</a></li>
    <li><a href="technologies.html#https" class="header">HTTPS</a></li>
    <li><a href="technologies.html#websocket" class="header">WebSocket</a></li>
    <li><a href="technologies.html#http-2" class="header">HTTP/2</a></li>
    <li><a href="technologies.html#dns" class="header">DNS</a></li>
    <li><a href="technologies.html#multipart" class="header">Multipart</a></li>
    <li><a href="technologies.html#server-sent-events-sse-" class="header">Server-sent Events (SSE)</a></li>
    <li><a href="technologies.html#json" class="header">JSON</a></li>
    <li><a href="technologies.html#xml" class="header">XML</a></li>
    <li><a href="technologies.html#gzip-and-deflate-content-encoding" class="header">Gzip and Deflate Content-Encoding</a></li>
  </ul></li>
  <li><a href="tipsandtricks.html" class="page">8. Tips And Tricks</a>
  <ul>
    <li><a href="troubleshooting/index.html" class="page">Troubleshooting</a></li>
    <li><a href="handling-blocking-operations-in-pekko-http-routes.html" class="page">Handling blocking operations in Apache Pekko HTTP</a></li>
    <li><a href="implications-of-streaming-http-entity.html" class="page">Implications of the streaming nature of Request/Response Entities</a></li>
  </ul></li>
  <li><a href="contributing.html" class="page">9. Contributing</a>
  <ul>
    <li><a href="contributing.html#welcome-" class="header">Welcome!</a></li>
    <li><a href="contributing.html#snapshots" class="header">Snapshots</a></li>
  </ul></li>
  <li><a href="reference.html" class="page">10. Reference</a>
  <ul>
    <li><a href="reference.html#api-documentation" class="header">API Documentation</a></li>
    <li><a href="reference.html#directives" class="header">Directives</a></li>
    <li><a href="reference.html#books" class="header">Books</a></li>
  </ul></li>
</ul>

<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="introduction.html#1-introduction" class="header">1. Introduction</a>
  <ul>
    <li><a href="introduction.html#philosophy" class="header">Philosophy</a></li>
    <li><a href="introduction.html#using-apache-pekko-http" class="header">Using Apache Pekko HTTP</a></li>
    <li><a href="introduction.html#routing-dsl-for-http-servers" class="header">Routing DSL for HTTP servers</a></li>
    <li><a href="introduction.html#marshalling" class="header">Marshalling</a></li>
    <li><a href="introduction.html#streaming" class="header">Streaming</a></li>
    <li><a href="introduction.html#low-level-http-server-apis" class="header">Low-level HTTP server APIs</a></li>
    <li><a href="introduction.html#http-client-api" class="header">HTTP Client API</a></li>
    <li><a href="introduction.html#the-modules-that-make-up-apache-pekko-http" class="header">The modules that make up Apache Pekko HTTP</a></li>
  </ul></li>
</ul>
</nav>


<ul class="md-nav__list md-nav__links">
<li class="md-nav__item"><a href="https://apache.org"><i class="md-icon">link</i> Apache Software Foundation</a></li>
<li class="md-nav__item"><a href="https://apache.org/licenses/"><i class="md-icon">link</i>&nbsp;License</a></li>
<li class="md-nav__item"><a href="https://apache.org/security/"><i class="md-icon">link</i>&nbsp;Security</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/sponsorship.html"><i class="md-icon">link</i>&nbsp;Donate</a></li>
<li class="md-nav__item"><a href="https://www.apache.org/foundation/thanks.html"><i class="md-icon">link</i>&nbsp;Thanks</a></li>
</ul>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.0.0+4308-98f0ff9c*
</label>
</li>
</ul>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="introduction.html#1-introduction" class="header">1. Introduction</a>
  <ul>
    <li><a href="introduction.html#philosophy" class="header">Philosophy</a></li>
    <li><a href="introduction.html#using-apache-pekko-http" class="header">Using Apache Pekko HTTP</a></li>
    <li><a href="introduction.html#routing-dsl-for-http-servers" class="header">Routing DSL for HTTP servers</a></li>
    <li><a href="introduction.html#marshalling" class="header">Marshalling</a></li>
    <li><a href="introduction.html#streaming" class="header">Streaming</a></li>
    <li><a href="introduction.html#low-level-http-server-apis" class="header">Low-level HTTP server APIs</a></li>
    <li><a href="introduction.html#http-client-api" class="header">HTTP Client API</a></li>
    <li><a href="introduction.html#the-modules-that-make-up-apache-pekko-http" class="header">The modules that make up Apache Pekko HTTP</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#1-introduction" name="1-introduction" class="anchor"><span class="anchor-link"></span></a>1. Introduction</h1>
<table class="project-info">
<tr><th colspan="2">Project Info: Pekko Http</th></tr>
  <tr><th>Artifact</th><td><div>org.apache.pekko</div>
  <div>pekko-http</div>
  <div>0.0.0+4308-98f0ff9c-SNAPSHOT</div>
  <div><a href="contributing.html#snapshots">Snapshots are available</a></div>
  </td></tr>
  <tr><th>JDK versions</th><td><div>Adopt OpenJDK 8</div><div>Adopt OpenJDK 11</div></td></tr>
  <tr><th>Scala versions</th><td>2.13.10, 2.12.15</td></tr>
  <tr><th>JPMS module name</th><td>pekko.http</td></tr>
  <tr><th>License</th><td><div><a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache-2.0</a></div>
  </td></tr>
  
  <tr><th>API documentation</th><td>
  <div><a href="https://doc.akka.io/api/akka-http/snapshot/akka/http/scaladsl/index.html" target="_blank" rel="noopener noreferrer">API (Scaladoc)</a></div>
  <div><a href="https://doc.akka.io/japi/akka-http/snapshot" target="_blank" rel="noopener noreferrer">API (Javadoc)</a></div>
  </td></tr>
  <tr><th>Forums</th><td>
  <div><a href="https://discuss.lightbend.com/tags/c/akka/akka-http" target="_blank" rel="noopener noreferrer">Lightbend Discuss</a></div>
  <div><a href="https://gitter.im/akka/akka" target="_blank" rel="noopener noreferrer">akka/akka Gitter channel</a></div>
  </td></tr>
  <tr><th>Release notes</th><td><a href="https://akka.io/blog/news-archive.html">akka.io blog</a></td></tr>
  <tr><th>Issues</th><td><a href="https://github.com/apache/incubator-pekko-http/issues" target="_blank" rel="noopener noreferrer">Github issues</a></td></tr>
  <tr><th>Sources</th><td><a href="https://github.com/apache/incubator-pekko-http" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-pekko-http</a></td></tr>
</table>

<p>The Apache Pekko HTTP modules implement a full server- and client-side HTTP stack on top of <em>pekko-actor</em> and <em>pekko-stream</em>. It&rsquo;s not a web-framework but rather a more general toolkit for providing and consuming HTTP-based services. While interaction with a browser is of course also in scope it is not the primary focus of Apache Pekko HTTP.</p>

<p>Apache Pekko HTTP follows a rather open design and many times offers several different API levels for &ldquo;doing the same thing&rdquo;. You get to pick the API level of abstraction that is most suitable for your application. This means that, if you have trouble achieving something using a high-level API, there&rsquo;s a good chance that you can get it done with a low-level API, which offers more flexibility but might require you to write more application code.</p>

<h2><a href="#philosophy" name="philosophy" class="anchor"><span class="anchor-link"></span></a>Philosophy</h2>

<p>Apache Pekko HTTP has been driven with a clear focus on providing tools for building integration layers rather than application cores. As such it regards itself as a suite of libraries rather than a framework.</p>

<p>A framework, as we’d like to think of the term, gives you a “frame”, in which you build your application. It comes with a lot of decisions already pre-made and provides a foundation including support structures that lets you get started and deliver results quickly. In a way a framework is like a skeleton onto which you put the “flesh” of your application in order to have it come alive. As such frameworks work best if you choose them before you start application development and try to stick to the framework&rsquo;s “way of doing things” as you go along.</p>

<p>For example, if you are building a browser-facing web application it makes sense to choose a web framework and build your application on top of it because the “core” of the application is the interaction of a browser with your code on the web-server. The framework makers have chosen one “proven” way of designing such applications and let you “fill in the blanks” of a more or less flexible “application-template”. Being able to rely on best-practice architecture like this can be a great asset for getting things done quickly.</p>

<p>However, if your application is not primarily a web application because its core is not browser-interaction but some specialized maybe complex business service and you are merely trying to connect it to the world via a REST/HTTP interface a web-framework might not be what you need. In this case the application architecture should be dictated by what makes sense for the core not the interface layer. Also, you probably won’t benefit from the possibly existing browser-specific framework components like view templating, asset management, JavaScript- and CSS generation/manipulation/minification, localization support, AJAX support, etc.</p>

<p>Apache Pekko HTTP was designed specifically as “not-a-framework”, not because we don’t like frameworks, but for use cases where a framework is not the right choice. Apache Pekko HTTP is made for building integration layers based on HTTP and as such tries to “stay on the sidelines”. Therefore you normally don’t build your application “on top of” Apache Pekko HTTP, but you build your application on top of whatever makes sense and use Apache Pekko HTTP merely for the HTTP integration needs.</p>

<p>On the other hand, if you prefer to build your applications with the guidance of a framework, you should give <a href="https://www.playframework.com/">Play Framework</a> a try, which is planning to use Apache Pekko internally. If you come from Play and want to try Apache Pekko HTTP, we collected a <a href="routing-dsl/play-comparison.html">side-by-side comparison</a> to show how some Play routing features map to the Apache Pekko HTTP routing DSL.</p>

<h2><a href="#using-apache-pekko-http" name="using-apache-pekko-http" class="anchor"><span class="anchor-link"></span></a>Using Apache Pekko HTTP</h2>

<p>Apache Pekko HTTP is provided as independent modules from Apache Pekko itself under its own release cycle. The modules, however, do <em>not</em> depend on <code>pekko-actor</code> or <code>pekko-stream</code>, so the user is required to choose an Apache Pekko version to run against and add a manual dependency to <code>pekko-stream</code> of the chosen version.</p>
<dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "0.0.0+26602-317cbb52-SNAPSHOT"
val PekkoHttpVersion = "0.0.0+4308-98f0ff9c-SNAPSHOT"
libraryDependencies ++= Seq(
  "org.apache.pekko" %% "pekko-actor-typed" % PekkoVersion,
  "org.apache.pekko" %% "pekko-stream" % PekkoVersion,
  "org.apache.pekko" %% "pekko-http" % PekkoHttpVersion
)</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  PekkoVersion: "0.0.0+26602-317cbb52-SNAPSHOT",
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT")

  implementation "org.apache.pekko:pekko-actor-typed_${versions.ScalaBinary}:${versions.PekkoVersion}"
  implementation "org.apache.pekko:pekko-stream_${versions.ScalaBinary}:${versions.PekkoVersion}"
  implementation "org.apache.pekko:pekko-http_${versions.ScalaBinary}"
}</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;pekko.version&gt;0.0.0+26602-317cbb52-SNAPSHOT&lt;/pekko.version&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-http-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;0.0.0+4308-98f0ff9c-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-actor-typed_${scala.binary.version}&lt;/artifactId&gt;
    &lt;version&gt;${pekko.version}&lt;/version&gt;
  &lt;/dependency&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-stream_${scala.binary.version}&lt;/artifactId&gt;
    &lt;version&gt;${pekko.version}&lt;/version&gt;
  &lt;/dependency&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-http_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd></dl>
<p>You may download a packaged version of this project by clicking &ldquo;Create a project for me!&rdquo; on the <span class="group-scala"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-http-quickstart-scala">Lightbend Getting Started page</a></span> <span class="group-java"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-http-quickstart-java">Lightbend Getting Started page</a></span>.</p>
<p>Alternatively, you can bootstrap a new project with Apache Pekko HTTP already configured using the <a href="http://www.foundweekends.org/giter8/">Giter8</a> template directly via sbt:</p><div class="group-scala">
<dl>
  <dt>For Scala (sbt)
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-sh">sbt new akka/akka-http-quickstart-scala.g8
</code></pre></dd>
</dl></div><div class="group-java">
<dl>
  <dt>For Java (Maven or Gradle)
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-sh">sbt new akka/akka-http-quickstart-java.g8
</code></pre>From there on the prepared project can be built using Gradle or Maven.</dd>
</dl></div>
<p>More instructions can be found on the <span class="group-scala"><a href="https://github.com/akka/akka-http-quickstart-scala.g8">template project</a></span><span class="group-java"><a href="https://github.com/akka/akka-http-quickstart-java.g8">template project</a></span>.</p>
<h2><a href="#routing-dsl-for-http-servers" name="routing-dsl-for-http-servers" class="anchor"><span class="anchor-link"></span></a>Routing DSL for HTTP servers</h2>
<p>The high-level, routing API of Apache Pekko HTTP provides a DSL to describe HTTP &ldquo;routes&rdquo; and how they should be handled. Each route is composed of one or more level of <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/server/Directives.html" title="org.apache.pekko.http.javadsl.server.Directives"><code>Directives</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/server/Directives.html" title="org.apache.pekko.http.scaladsl.server.Directives"><code>Directives</code></a></span> that narrows down to handling one specific type of request.</p>
<p>For example one route might start with matching the <code>path</code> of the request, only matching if it is &ldquo;/hello&rdquo;, then narrowing it down to only handle HTTP <code>get</code> requests and then <code>complete</code> those with a string literal, which will be sent back as an HTTP OK with the string as response body.</p>
<p>The <span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/server/index.html#Route=org.apache.pekko.http.scaladsl.server.RequestContext=%3Escala.concurrent.Future[org.apache.pekko.http.scaladsl.server.RouteResult]" title="org.apache.pekko.http.scaladsl.server"><code>Route</code></a></span> <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/server/Route.html" title="org.apache.pekko.http.javadsl.server.Route"><code>Route</code></a></span> created using the Route DSL is then &ldquo;bound&rdquo; to a port to start serving HTTP requests:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerRoutingMinimal.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.typed.ActorSystem
import pekko.actor.typed.scaladsl.Behaviors
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.model._
import pekko.http.scaladsl.server.Directives._
import scala.io.StdIn

object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    implicit val system = ActorSystem(Behaviors.empty, &quot;my-system&quot;)
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path(&quot;hello&quot;) {
        get {
          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, &quot;&lt;h1&gt;Say hello to akka-http&lt;/h1&gt;&quot;))
        }
      }

    val bindingFuture = Http().newServerAt(&quot;localhost&quot;, 8080).bind(route)

    println(s&quot;Server now online. Please navigate to http://localhost:8080/hello\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/HttpServerMinimalExampleTest.java#L16-L54" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;

import java.util.concurrent.CompletionStage;

public class HttpServerMinimalExampleTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem&lt;Void&gt; system = ActorSystem.create(Behaviors.empty(), &quot;routes&quot;);

    final Http http = Http.get(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerMinimalExampleTest app = new HttpServerMinimalExampleTest();

    final CompletionStage&lt;ServerBinding&gt; binding =
      http.newServerAt(&quot;localhost&quot;, 8080)
          .bind(app.createRoute());

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  private Route createRoute() {
    return concat(
        path(&quot;hello&quot;, () -&gt;
            get(() -&gt;
                complete(&quot;&lt;h1&gt;Say hello to pekko-http&lt;/h1&gt;&quot;))));
  }
}</code></pre></dd>
</dl>
<p>When you run this server, you can either open the page in a browser, at the following url: <a href="http://localhost:8080/hello">http://localhost:8080/hello</a>, or call it in your terminal, via <code>curl http://localhost:8080/hello</code>.</p>
<h2><a href="#marshalling" name="marshalling" class="anchor"><span class="anchor-link"></span></a>Marshalling</h2>
<p>Transforming request and response bodies between over-the-wire formats and objects to be used in your application is done separately from the route declarations, in marshallers, which are pulled in implicitly using the &ldquo;magnet&rdquo; pattern. This means that you can <code>complete</code> a request with any kind of object as long as there is an implicit marshaller available in scope.</p><div class="group-scala">
<p>Default marshallers are provided for simple objects like String or ByteString, and you can define your own for example for JSON. An additional module provides JSON serialization using the spray-json library (see <a href="common/json-support.html">JSON Support</a> for details):</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoHttpVersion = "0.0.0+4308-98f0ff9c-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-http-spray-json" % PekkoHttpVersion</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT")

  implementation "org.apache.pekko:pekko-http-spray-json_${versions.ScalaBinary}"
}</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-http-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;0.0.0+4308-98f0ff9c-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-http-spray-json_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd></dl></div><div class="group-java">
<p>JSON support is possible in <code>pekko-http</code> by the use of Jackson, an external artifact (see <a href="common/json-support.html#jackson-support">JSON Support</a> for details):</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoHttpVersion = "0.0.0+4308-98f0ff9c-SNAPSHOT"
libraryDependencies += "org.apache.pekko" %% "pekko-http-jackson" % PekkoHttpVersion</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-http-bom_${versions.ScalaBinary}:0.0.0+4308-98f0ff9c-SNAPSHOT")

  implementation "org.apache.pekko:pekko-http-jackson_${versions.ScalaBinary}"
}</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-http-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;0.0.0+4308-98f0ff9c-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-http-jackson_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd></dl></div>
<p>A common use case is to reply to a request using a model object having the marshaller transform it into JSON. In this case shown by two separate routes. The first route queries an asynchronous database and marshals the <span class="group-scala"><code>Future[Option[Item]]</code></span><span class="group-java"><code>CompletionStage&lt;Optional&lt;Item&gt;&gt;</code></span> result into a JSON response. The second unmarshals an <code>Order</code> from the incoming request, saves it to the database and replies with an OK when done.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/SprayJsonExample.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.typed.ActorSystem
import pekko.actor.typed.scaladsl.Behaviors
import pekko.http.scaladsl.Http
import pekko.Done
import pekko.http.scaladsl.server.Route
import pekko.http.scaladsl.server.Directives._
import pekko.http.scaladsl.model.StatusCodes
// for JSON serialization/deserialization following dependency is required:
// &quot;com.typesafe.akka&quot; %% &quot;akka-http-spray-json&quot; % &quot;10.1.7&quot;
import pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
import spray.json.DefaultJsonProtocol._

import scala.io.StdIn

import scala.concurrent.Future

object SprayJsonExample {

  // needed to run the route
  implicit val system = ActorSystem(Behaviors.empty, &quot;SprayExample&quot;)
  // needed for the future map/flatmap in the end and future in fetchItem and saveOrder
  implicit val executionContext = system.executionContext

  var orders: List[Item] = Nil

  // domain model
  final case class Item(name: String, id: Long)
  final case class Order(items: List[Item])

  // formats for unmarshalling and marshalling
  implicit val itemFormat = jsonFormat2(Item)
  implicit val orderFormat = jsonFormat1(Order)

  // (fake) async database query api
  def fetchItem(itemId: Long): Future[Option[Item]] = Future {
    orders.find(o =&gt; o.id == itemId)
  }
  def saveOrder(order: Order): Future[Done] = {
    orders = order match {
      case Order(items) =&gt; items ::: orders
      case _            =&gt; orders
    }
    Future { Done }
  }

  def main(args: Array[String]): Unit = {
    val route: Route =
      concat(
        get {
          pathPrefix(&quot;item&quot; / LongNumber) { id =&gt;
            // there might be no item for a given id
            val maybeItem: Future[Option[Item]] = fetchItem(id)

            onSuccess(maybeItem) {
              case Some(item) =&gt; complete(item)
              case None       =&gt; complete(StatusCodes.NotFound)
            }
          }
        },
        post {
          path(&quot;create-order&quot;) {
            entity(as[Order]) { order =&gt;
              val saved: Future[Done] = saveOrder(order)
              onSuccess(saved) { _ =&gt; // we are not interested in the result value `Done` but only in the fact that it was successful
                complete(&quot;order created&quot;)
              }
            }
          }
        })

    val bindingFuture = Http().newServerAt(&quot;localhost&quot;, 8080).bind(route)
    println(s&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/JacksonExampleTest.java#L16-L130" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.Done;
import org.apache.pekko.NotUsed;
import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.http.javadsl.ConnectHttp;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;
import org.apache.pekko.http.javadsl.model.HttpRequest;
import org.apache.pekko.http.javadsl.model.HttpResponse;
import org.apache.pekko.http.javadsl.model.StatusCodes;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;
import org.apache.pekko.stream.javadsl.Flow;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import static org.apache.pekko.http.javadsl.server.PathMatchers.longSegment;

public class JacksonExampleTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem&lt;Void&gt; system = ActorSystem.create(Behaviors.empty(), &quot;routes&quot;);

    final Http http = Http.get(system);

    //In order to access all directives we need an instance where the routes are define.
    JacksonExampleTest app = new JacksonExampleTest();

    final CompletionStage&lt;ServerBinding&gt; binding =
        http.newServerAt(&quot;localhost&quot;, 8080)
            .bind(app.createRoute());

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
      .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
      .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  // (fake) async database query api
  private CompletionStage&lt;Optional&lt;Item&gt;&gt; fetchItem(long itemId) {
    return CompletableFuture.completedFuture(Optional.of(new Item(&quot;foo&quot;, itemId)));
  }

  // (fake) async database query api
  private CompletionStage&lt;Done&gt; saveOrder(final Order order) {
    return CompletableFuture.completedFuture(Done.getInstance());
  }

  private Route createRoute() {

    return concat(
      get(() -&gt;
        pathPrefix(&quot;item&quot;, () -&gt;
          path(longSegment(), (Long id) -&gt; {
            final CompletionStage&lt;Optional&lt;Item&gt;&gt; futureMaybeItem = fetchItem(id);
            return onSuccess(futureMaybeItem, maybeItem -&gt;
              maybeItem.map(item -&gt; completeOK(item, Jackson.marshaller()))
                .orElseGet(() -&gt; complete(StatusCodes.NOT_FOUND, &quot;Not Found&quot;))
            );
          }))),
      post(() -&gt;
        path(&quot;create-order&quot;, () -&gt;
          entity(Jackson.unmarshaller(Order.class), order -&gt; {
            CompletionStage&lt;Done&gt; futureSaved = saveOrder(order);
            return onSuccess(futureSaved, done -&gt;
              complete(&quot;order created&quot;)
            );
          })))
    );
  }

  private static class Item {

    final String name;
    final long id;

    @JsonCreator
    Item(@JsonProperty(&quot;name&quot;) String name,
         @JsonProperty(&quot;id&quot;) long id) {
      this.name = name;
      this.id = id;
    }

    public String getName() {
      return name;
    }

    public long getId() {
      return id;
    }
  }

  private static class Order {

    final List&lt;Item&gt; items;

    @JsonCreator
    Order(@JsonProperty(&quot;items&quot;) List&lt;Item&gt; items) {
      this.items = items;
    }

    public List&lt;Item&gt; getItems() {
      return items;
    }
  }
}</code></pre></dd>
</dl>
<p>When you run this server, you can update the inventory via <code>curl -H &quot;Content-Type: application/json&quot; -X POST -d &#39;{&quot;items&quot;:[{&quot;name&quot;:&quot;hhgtg&quot;,&quot;id&quot;:42}]}&#39; http://localhost:8080/create-order</code> on your terminal - adding an item named <code>&quot;hhgtg&quot;</code> and having an <code>id=42</code>; and then view the inventory either in a browser, at a url like: <a href="http://localhost:8080/item/42">http://localhost:8080/item/42</a> - or on the terminal, via <code>curl http://localhost:8080/item/42</code>.</p>
<p>The logic for the marshalling and unmarshalling JSON in this example is provided by the <span class="group-scala">&ldquo;spray-json&rdquo;</span><span class="group-java">&ldquo;Jackson&rdquo;</span> library. See <span class="group-scala"><a href="common/json-support.html">JSON Support</a>)</span><span class="group-java"><a href="common/json-support.html#jackson-support">JSON Support</a>)</span> for more information about integration with this library.</p>
<h2><a href="#streaming" name="streaming" class="anchor"><span class="anchor-link"></span></a>Streaming</h2>
<p>One of the strengths of Apache Pekko HTTP is that streaming data is at its heart meaning that both request and response bodies can be streamed through the server achieving constant memory usage even for very large requests or responses. Streaming responses will be backpressured by the remote client so that the server will not push data faster than the client can handle, streaming requests means that the server decides how fast the remote client can push the data of the request body.</p>
<p>Example that streams random numbers as long as the client accepts them:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerStreamingRandomNumbers.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.typed.ActorSystem
import pekko.actor.typed.scaladsl.Behaviors
import pekko.stream.scaladsl._
import pekko.util.ByteString
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.model.{ ContentTypes, HttpEntity }
import pekko.http.scaladsl.server.Directives._
import scala.util.Random
import scala.io.StdIn

object HttpServerStreamingRandomNumbers {

  def main(args: Array[String]): Unit = {

    implicit val system = ActorSystem(Behaviors.empty, &quot;RandomNumbers&quot;)
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    // streams are re-usable so we can define it here
    // and use it for every request
    val numbers = Source.fromIterator(() =&gt;
      Iterator.continually(Random.nextInt()))

    val route =
      path(&quot;random&quot;) {
        get {
          complete(
            HttpEntity(
              ContentTypes.`text/plain(UTF-8)`,
              // transform each number to a chunk of bytes
              numbers.map(n =&gt; ByteString(s&quot;$n\n&quot;))))
        }
      }

    val bindingFuture = Http().newServerAt(&quot;localhost&quot;, 8080).bind(route)
    println(s&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/HttpServerStreamRandomNumbersTest.java#L17-L71" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.NotUsed;
import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.http.javadsl.ConnectHttp;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.model.*;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;
import org.apache.pekko.stream.javadsl.Flow;
import org.apache.pekko.stream.javadsl.Source;
import org.apache.pekko.util.ByteString;

import java.util.Random;
import java.util.concurrent.CompletionStage;
import java.util.stream.Stream;

public class HttpServerStreamRandomNumbersTest extends AllDirectives {

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem&lt;Void&gt; system = ActorSystem.create(Behaviors.empty(), &quot;routes&quot;);

    final Http http = Http.get(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerStreamRandomNumbersTest app = new HttpServerStreamRandomNumbersTest();

    final CompletionStage&lt;ServerBinding&gt; binding =
        http.newServerAt(&quot;localhost&quot;, 8080)
                .bind(app.createRoute());

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }


  private Route createRoute() {
    final Random rnd = new Random();
    // streams are re-usable so we can define it here
    // and use it for every request
    Source&lt;Integer, NotUsed&gt; numbers = Source.fromIterator(() -&gt; Stream.generate(rnd::nextInt).iterator());

    return concat(
        path(&quot;random&quot;, () -&gt;
            get(() -&gt;
                complete(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,
                    // transform each number to a chunk of bytes
                    numbers.map(x -&gt; ByteString.fromString(x + &quot;\n&quot;)))))));
  }
}</code></pre></dd>
</dl>
<p>Connecting to this service with a slow HTTP client would backpressure so that the next random number is produced on demand with constant memory usage on the server. This can be seen using curl and limiting the rate <code>curl --limit-rate 50b 127.0.0.1:8080/random</code></p>
<p>Apache Pekko HTTP routes easily interact with actors. In this example one route allows for placing bids in a fire-and-forget style while the second route contains a request-response interaction with an actor. The resulting response is rendered as JSON and returned when the response arrives from the actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerWithActorInteraction.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.typed.scaladsl.AskPattern._
import pekko.actor.typed.scaladsl.Behaviors
import pekko.actor.typed.{ ActorRef, ActorSystem }
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
import pekko.http.scaladsl.model.StatusCodes
import pekko.http.scaladsl.server.Directives._
import pekko.util.Timeout
import spray.json.DefaultJsonProtocol._

import scala.concurrent.duration._
import scala.concurrent.{ ExecutionContext, Future }
import scala.io.StdIn

object HttpServerWithActorInteraction {

  object Auction {

    sealed trait Message

    case class Bid(userId: String, offer: Int) extends Message

    case class GetBids(replyTo: ActorRef[Bids]) extends Message

    case class Bids(bids: List[Bid])

    def apply: Behaviors.Receive[Message] = apply(List.empty)

    def apply(bids: List[Bid]): Behaviors.Receive[Message] = Behaviors.receive {
      case (ctx, bid @ Bid(userId, offer)) =&gt;
        ctx.log.info(s&quot;Bid complete: $userId, $offer&quot;)
        apply(bids :+ bid)
      case (_, GetBids(replyTo)) =&gt;
        replyTo ! Bids(bids)
        Behaviors.same
    }

  }

  // these are from spray-json
  implicit val bidFormat = jsonFormat2(Auction.Bid)
  implicit val bidsFormat = jsonFormat1(Auction.Bids)

  def main(args: Array[String]): Unit = {
    implicit val system: ActorSystem[Auction.Message] = ActorSystem(Auction.apply, &quot;auction&quot;)
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext: ExecutionContext = system.executionContext

    val auction: ActorRef[Auction.Message] = system
    import Auction._

    val route =
      path(&quot;auction&quot;) {
        concat(
          put {
            parameters(&quot;bid&quot;.as[Int], &quot;user&quot;) { (bid, user) =&gt;
              // place a bid, fire-and-forget
              auction ! Bid(user, bid)
              complete(StatusCodes.Accepted, &quot;bid placed&quot;)
            }
          },
          get {
            implicit val timeout: Timeout = 5.seconds

            // query the actor for the current auction state
            val bids: Future[Bids] = (auction ? GetBids).mapTo[Bids]
            complete(bids)
          })
      }

    val bindingFuture = Http().newServerAt(&quot;localhost&quot;, 8080).bind(route)
    println(s&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done

  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/HttpServerActorInteractionExample.java#L17-L152" target="_blank" title="Go to snippet source">source</a><code class="language-java"><br/>import org.apache.pekko.NotUsed;
import org.apache.pekko.actor.typed.ActorRef;
import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.Behavior;
import org.apache.pekko.actor.typed.javadsl.AbstractBehavior;
import org.apache.pekko.actor.typed.javadsl.ActorContext;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.actor.typed.javadsl.Receive;
import org.apache.pekko.http.javadsl.ConnectHttp;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.marshallers.jackson.Jackson;
import org.apache.pekko.http.javadsl.model.HttpRequest;
import org.apache.pekko.http.javadsl.model.HttpResponse;
import org.apache.pekko.http.javadsl.model.StatusCodes;
import org.apache.pekko.http.javadsl.server.AllDirectives;
import org.apache.pekko.http.javadsl.server.Route;
import org.apache.pekko.http.javadsl.unmarshalling.StringUnmarshallers;
import org.apache.pekko.stream.javadsl.Flow;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletionStage;

import static org.apache.pekko.actor.typed.javadsl.AskPattern.ask;

public class HttpServerActorInteractionExample extends AllDirectives {

  private final ActorSystem&lt;Auction.Message&gt; system;
  private final ActorRef&lt;Auction.Message&gt; auction;

  public static void main(String[] args) throws Exception {
    // boot up server using the route as defined below
    ActorSystem&lt;Auction.Message&gt; system = ActorSystem.create(Auction.create(), &quot;routes&quot;);

    final Http http = Http.get(system);

    //In order to access all directives we need an instance where the routes are define.
    HttpServerActorInteractionExample app = new HttpServerActorInteractionExample(system);

    final CompletionStage&lt;ServerBinding&gt; binding =
      http.newServerAt(&quot;localhost&quot;, 8080)
        .bind(app.createRoute());

    System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
    System.in.read(); // let it run until user presses return

    binding
      .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
      .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done
  }

  private HttpServerActorInteractionExample(final ActorSystem&lt;Auction.Message&gt; system) {
    this.system = system;
    this.auction = system;
  }

  private Route createRoute() {
    return concat(
      path(&quot;auction&quot;, () -&gt; concat(
        put(() -&gt;
          parameter(StringUnmarshallers.INTEGER, &quot;bid&quot;, bid -&gt;
            parameter(&quot;user&quot;, user -&gt; {
              // place a bid, fire-and-forget
              auction.tell(new Auction.Bid(user, bid));
              return complete(StatusCodes.ACCEPTED, &quot;bid placed&quot;);
            })
          )),
        get(() -&gt; {
          // query the actor for the current auction state
          CompletionStage&lt;Auction.Bids&gt; bids = ask(auction, Auction.GetBids::new, Duration.ofSeconds(5), system.scheduler());
          return completeOKWithFuture(bids, Jackson.marshaller());
        }))));
  }

  static class Auction extends AbstractBehavior&lt;Auction.Message&gt; {
    interface Message {}

    static class Bid implements Message {
      public final String userId;
      public final int offer;

      Bid(String userId, int offer) {
        this.userId = userId;
        this.offer = offer;
      }
    }

    static class GetBids implements Message {
      final ActorRef&lt;Bids&gt; replyTo;

      GetBids(ActorRef&lt;Bids&gt; replyTo) {
        this.replyTo = replyTo;
      }
    }

    static class Bids {
      public final List&lt;Bid&gt; bids;

      Bids(List&lt;Bid&gt; bids) {
        this.bids = bids;
      }
    }

    public Auction(ActorContext&lt;Message&gt; context) {
      super(context);
    }

    private List&lt;Bid&gt; bids = new ArrayList&lt;&gt;();

    public static Behavior&lt;Message&gt; create() {
      return Behaviors.setup(Auction::new);
    }

    @Override
    public Receive&lt;Message&gt; createReceive() {
      return newReceiveBuilder()
        .onMessage(Bid.class, this::onBid)
        .onMessage(GetBids.class, this::onGetBids)
        .build();
    }

    private Behavior&lt;Message&gt; onBid(Bid bid) {
      bids.add(bid);
      getContext().getLog().info(&quot;Bid complete: {}, {}&quot;, bid.userId, bid.offer);
      return this;
    }

    private Behavior&lt;Message&gt; onGetBids(GetBids getBids) {
      getBids.replyTo.tell(new Bids(bids));
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>When you run this server, you can add an auction bid via <code>curl -X PUT &quot;http://localhost:8080/auction?bid=22&amp;user=MartinO&quot;</code> on the terminal; and then you can view the auction status either in a browser, at the url <a href="http://localhost:8080/auction">http://localhost:8080/auction</a>, or, on the terminal, via <code>curl http://localhost:8080/auction</code>.</p>
<p>More details on how JSON marshalling and unmarshalling works can be found in the <a href="common/json-support.html">JSON Support section</a>.</p>
<p>Read more about the details of the high level APIs in the section <a href="routing-dsl/index.html">High-level Server-Side API</a>.</p>
<h2><a href="#low-level-http-server-apis" name="low-level-http-server-apis" class="anchor"><span class="anchor-link"></span></a>Low-level HTTP server APIs</h2>
<p>The low-level Apache Pekko HTTP server APIs allows for handling connections or individual requests by accepting <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpRequest.html" title="org.apache.pekko.http.javadsl.model.HttpRequest"><code>HttpRequest</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpRequest.html" title="org.apache.pekko.http.scaladsl.model.HttpRequest"><code>HttpRequest</code></a></span> s and answering them by producing <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span> s. This is provided by the <code>pekko-http-core</code> module, which is included automatically when you depend on <code>pekko-http</code> but can also be used on its own. APIs for handling such request-responses as function calls and as a <span class="group-java"><a href="https://pekko.apache.org/japi/pekko/0.0/org/apache/pekko/stream/javadsl/Flow.html" title="org.apache.pekko.stream.javadsl.Flow"><code>Flow&lt;HttpRequest, HttpResponse, ?&gt;</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/api/pekko/0.0/org/apache/pekko/stream/scaladsl/Flow.html" title="org.apache.pekko.stream.scaladsl.Flow"><code>Flow[HttpRequest, HttpResponse, _]</code></a></span> are available.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpServerLowLevel.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.typed.ActorSystem
import pekko.actor.typed.scaladsl.Behaviors
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.model.HttpMethods._
import pekko.http.scaladsl.model._

import scala.concurrent.ExecutionContext
import scala.io.StdIn

object HttpServerLowLevel {

  def main(args: Array[String]): Unit = {
    implicit val system = ActorSystem(Behaviors.empty, &quot;lowlevel&quot;)
    // needed for the future map/flatmap in the end
    implicit val executionContext: ExecutionContext = system.executionContext

    val requestHandler: HttpRequest =&gt; HttpResponse = {
      case HttpRequest(GET, Uri.Path(&quot;/&quot;), _, _, _) =&gt;
        HttpResponse(entity = HttpEntity(
          ContentTypes.`text/html(UTF-8)`,
          &quot;&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;&quot;))

      case HttpRequest(GET, Uri.Path(&quot;/ping&quot;), _, _, _) =&gt;
        HttpResponse(entity = &quot;PONG!&quot;)

      case HttpRequest(GET, Uri.Path(&quot;/crash&quot;), _, _, _) =&gt;
        sys.error(&quot;BOOM!&quot;)

      case r: HttpRequest =&gt;
        r.discardEntityBytes() // important to drain incoming HTTP Entity stream
        HttpResponse(404, entity = &quot;Unknown resource!&quot;)
    }

    val bindingFuture = Http().newServerAt(&quot;localhost&quot;, 8080).bindSync(requestHandler)
    println(s&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;)
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ =&gt; system.terminate()) // and shutdown when done

  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/HttpServerLowLevelExample.java#L17-L63" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.http.javadsl.ConnectHttp;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.ServerBinding;
import org.apache.pekko.http.javadsl.model.ContentTypes;
import org.apache.pekko.http.javadsl.model.HttpResponse;
import org.apache.pekko.http.javadsl.model.StatusCodes;
import org.apache.pekko.stream.SystemMaterializer;
import org.apache.pekko.util.ByteString;

import java.util.concurrent.CompletionStage;

public class HttpServerLowLevelExample {

  public static void main(String[] args) throws Exception {
    ActorSystem&lt;Void&gt; system = ActorSystem.create(Behaviors.empty(), &quot;lowlevel&quot;);

    try {
      CompletionStage&lt;ServerBinding&gt; serverBindingFuture =
        Http.get(system).newServerAt(&quot;localhost&quot;, 8080).bindSync(
          request -&gt; {
            if (request.getUri().path().equals(&quot;/&quot;))
              return HttpResponse.create().withEntity(ContentTypes.TEXT_HTML_UTF8,
                ByteString.fromString(&quot;&lt;html&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;&quot;));
            else if (request.getUri().path().equals(&quot;/ping&quot;))
              return HttpResponse.create().withEntity(ByteString.fromString(&quot;PONG!&quot;));
            else if (request.getUri().path().equals(&quot;/crash&quot;))
              throw new RuntimeException(&quot;BOOM!&quot;);
            else {
              request.discardEntityBytes(system);
              return HttpResponse.create().withStatus(StatusCodes.NOT_FOUND).withEntity(&quot;Unknown resource!&quot;);
            }
          });

      System.out.println(&quot;Server online at http://localhost:8080/\nPress RETURN to stop...&quot;);
      System.in.read(); // let it run until user presses return

      serverBindingFuture
        .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
        .thenAccept(unbound -&gt; system.terminate()); // and shutdown when done

    } catch (RuntimeException e) {
      system.terminate();
    }
  }
}</code></pre></dd>
</dl>
<p>Read more details about the low level APIs in the section <a href="server-side/low-level-api.html">Core Server API</a>.</p>
<h2><a href="#http-client-api" name="http-client-api" class="anchor"><span class="anchor-link"></span></a>HTTP Client API</h2>
<p>The client APIs provide methods for calling an HTTP server using the same <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpRequest.html" title="org.apache.pekko.http.javadsl.model.HttpRequest"><code>HttpRequest</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpRequest.html" title="org.apache.pekko.http.scaladsl.model.HttpRequest"><code>HttpRequest</code></a></span> and <span class="group-java"><a href="https://pekko.apache.org/api/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/javadsl/model/HttpResponse.html" title="org.apache.pekko.http.javadsl.model.HttpResponse"><code>HttpResponse</code></a></span><span class="group-scala"><a href="https://pekko.apache.org/japi/pekko-http/0.0.0+4308-98f0ff9c-SNAPSHOT/org/apache/pekko/http/scaladsl/model/HttpResponse.html" title="org.apache.pekko.http.scaladsl.model.HttpResponse"><code>HttpResponse</code></a></span> abstractions that Apache Pekko HTTP server uses but adds the concept of connection pools to allow multiple requests to the same server to be handled more performantly by re-using TCP connections to the server.</p>
<p>Example simple request:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/scala/docs/http/scaladsl/HttpClientSingleRequest.scala" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * license agreements; and to You under the Apache License, version 2.0:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * This file is part of the Apache Pekko project, derived from Akka.
 */

/*
 * Copyright (C) 2020-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt;
 */

package docs.http.scaladsl

import org.apache.pekko
import pekko.actor.typed.ActorSystem
import pekko.actor.typed.scaladsl.Behaviors
import pekko.http.scaladsl.Http
import pekko.http.scaladsl.model._

import scala.concurrent.Future
import scala.util.{ Failure, Success }

object HttpClientSingleRequest {
  def main(args: Array[String]): Unit = {
    implicit val system = ActorSystem(Behaviors.empty, &quot;SingleRequest&quot;)
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val responseFuture: Future[HttpResponse] = Http().singleRequest(HttpRequest(uri = &quot;http://pekko.apache.org&quot;))

    responseFuture
      .onComplete {
        case Success(res) =&gt; println(res)
        case Failure(_)   =&gt; sys.error(&quot;something wrong&quot;)
      }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/test/java/docs/http/javadsl/ClientSingleRequestExample.java#L22-L40" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.typed.ActorSystem;
import org.apache.pekko.actor.typed.javadsl.Behaviors;
import org.apache.pekko.http.javadsl.Http;
import org.apache.pekko.http.javadsl.model.*;
import org.apache.pekko.http.javadsl.server.examples.petstore.Pet;
import org.apache.pekko.stream.SystemMaterializer;

import java.util.concurrent.CompletionStage;

public class ClientSingleRequestExample {

  public static void main(String[] args) {
    final ActorSystem&lt;Void&gt; system = ActorSystem.create(Behaviors.empty(), &quot;SingleRequest&quot;);

    final CompletionStage&lt;HttpResponse&gt; responseFuture =
      Http.get(system)
        .singleRequest(HttpRequest.create(&quot;https://pekko.apache.org&quot;));
  }
}</code></pre></dd>
</dl>
<p>Read more about the details of the client APIs in the section <a href="client-side/index.html">Consuming HTTP-based Services (Client-Side)</a>.</p>
<h2><a href="#the-modules-that-make-up-apache-pekko-http" name="the-modules-that-make-up-apache-pekko-http" class="anchor"><span class="anchor-link"></span></a>The modules that make up Apache Pekko HTTP</h2>
<p>Apache Pekko HTTP is structured into several modules:</p>
<dl>
  <dt>pekko-http
  </dt>
  <dd>Higher-level functionality, like (un)marshalling, (de)compression as well as a powerful DSL for defining HTTP-based APIs on the server-side, this is the recommended way to write HTTP servers with Apache Pekko HTTP. Details can be found in the section <a href="routing-dsl/index.html">High-level Server-Side API</a></dd>
  <dt>pekko-http-core
  </dt>
  <dd>A complete, mostly low-level, server- and client-side implementation of HTTP (incl. WebSockets) Details can be found in sections <a href="server-side/low-level-api.html">Core Server API</a> and <a href="client-side/index.html">Consuming HTTP-based Services (Client-Side)</a></dd>
  <dt>pekko-http-testkit
  </dt>
  <dd>A test harness and set of utilities for verifying server-side service implementations</dd>
  <dt>pekko-http2-support
  </dt>
  <dd>The HTTP/2 implementation to be included only if <a href="server-side/http2.html">HTTP/2 support</a> is needed.</dd>
</dl><div class="group-scala">
<dl>
  <dt>pekko-http-spray-json
  </dt>
  <dd>Predefined glue-code for (de)serializing custom types from/to JSON with <a href="https://github.com/spray/spray-json">spray-json</a> Details can be found here: <a href="common/json-support.html">JSON Support</a></dd>
</dl></div><div class="group-scala">
<dl>
  <dt>pekko-http-xml
  </dt>
  <dd>Predefined glue-code for (de)serializing custom types from/to XML with <a href="https://github.com/scala/scala-xml">scala-xml</a> Details can be found here: <a href="common/xml-support.html">XML Support</a></dd>
</dl></div><div class="group-java">
<dl>
  <dt>pekko-http-jackson
  </dt>
  <dd>Predefined glue-code for (de)serializing custom types from/to JSON with <a href="https://github.com/FasterXML/jackson">jackson</a></dd>
</dl></div>
</div>
<div>
<a href="https://github.com/apache/incubator-pekko-http/tree/main/docs/src/main/paradox/introduction.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.0.0+4308-98f0ff9c*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="release-notes/index.html" title="0. Release Notes" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
0. Release Notes
</span>
</div>
</a>
<a href="usage.html" title="2. Usage" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
2. Usage
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright © 2022, 2023 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the Apache License, Version 2.0.
 This product contains significant parts that were originally based on software from Lightbend (<a href="https://akka.io/">Akka</a>).
 Copyright (C) 2009-2022 Lightbend Inc. &lt;https://www.lightbend.com&gt; Apache Pekko is derived from Akka 2.6.x,
 the last version that was distributed under the Apache License, Version 2.0 License.
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="assets/javascripts/groups.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
