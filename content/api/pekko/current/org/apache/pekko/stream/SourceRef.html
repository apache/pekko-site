<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Apache Pekko 0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT - org.apache.pekko.stream.SourceRef</title><meta content="Apache Pekko 0.0.0 26605 - 0f20b284 20230301 - 2309 - SNAPSHOT - org.apache.pekko.stream.SourceRef" name="description"/><meta content="Apache Pekko 0.0.0 26605 0f20b284 20230301 2309 SNAPSHOT org.apache.pekko.stream.SourceRef" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="https://pekko.apache.org/api/pekko/current/org/apache/pekko/stream/SourceRef.html" rel="canonical"/><link href="../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../../lib/index.js"></script><script type="text/javascript" src="../../../../index.js"></script><script type="text/javascript" src="../../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../../lib/template.js"></script><script type="text/javascript" src="https://d3js.org/d3.v4.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../../';</script></head><body><div id="search"><span id="doc-title">Apache Pekko<span id="doc-version">0.0.0+26605-0f20b284+20230301-2309-SNAPSHOT</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.org" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="org" class="anchorToMember"></a><a id="org:org" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">org</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="org.apache" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apache" class="anchorToMember"></a><a id="apache:apache" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">apache</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="org" id="org" class="extype">org</a></dd></dl></div></li><li class="indented3 " name="org.apache.pekko" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pekko" class="anchorToMember"></a><a id="pekko:pekko" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">pekko</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="org.apache" id="org.apache" class="extype">apache</a></dd></dl></div></li><li class="indented4 " name="org.apache.pekko.stream" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="stream" class="anchorToMember"></a><a id="stream:stream" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">stream</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="org.apache.pekko" id="org.apache.pekko" class="extype">pekko</a></dd></dl></div></li><li class="indented5 " name="org.apache.pekko.stream.impl" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="impl" class="anchorToMember"></a><a id="impl:impl" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/impl/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="impl/index.html" title="The architecture of Akka Streams internally consists of several distinct layers:"><span class="name">impl</span></a></span><p class="shortcomment cmt">The architecture of Akka Streams internally consists of several distinct layers:</p><div class="fullcomment"><div class="comment cmt"><p>The architecture of Akka Streams internally consists of several distinct layers:</p><p> * The DSLs like <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">org.apache.pekko.stream.scaladsl.Flow</a>, <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">org.apache.pekko.stream.scaladsl.Source</a> etc. are the user facing API
   for composing streams. These DSLs are a thin wrappers around the internal <span name="org.apache.pekko.stream.impl.TraversalBuilder" class="extype">org.apache.pekko.stream.impl.TraversalBuilder</span>
   builder classes. There are Java alternatives of these DSLs in <a href="javadsl/index.html" name="org.apache.pekko.stream.javadsl" id="org.apache.pekko.stream.javadsl" class="extype">javadsl</a> which basically wrap their scala
   counterpart, delegating method calls.
 * The <a href="stage/GraphStage.html" name="org.apache.pekko.stream.stage.GraphStage" id="org.apache.pekko.stream.stage.GraphStage" class="extype">org.apache.pekko.stream.stage.GraphStage</a> API is the user facing API for creating new stream operators. These
   classes are used by the <span name="org.apache.pekko.stream.impl.fusing.GraphInterpreter" class="extype">org.apache.pekko.stream.impl.fusing.GraphInterpreter</span> which executes islands (subgraphs) of these
   operators
 * The high level DSLs use the <span name="org.apache.pekko.stream.impl.TraversalBuilder" class="extype">org.apache.pekko.stream.impl.TraversalBuilder</span> classes to build instances of
   <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> which are the representation of a materializable stream description. These builders
   are immutable and safely shareable. Unlike the top-level DSLs, these are classic, i.e. elements are treated as
   Any.
 * The <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> is the immutable, efficient representation of a stream processing graph that
   can be materialized. The builders exists solely for the purpose of producing a traversal in the end.
 * The <span name="org.apache.pekko.stream.impl.PhasedFusingActorMaterializer" class="extype">org.apache.pekko.stream.impl.PhasedFusingActorMaterializer</span> is the class that is responsible for traversing and
   interpreting a <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span>. It delegates the actual task of creating executable entities
   and Publishers/Producers to <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span>s which are plugins that understand atomic operators
   in the graph and able to turn them into executable entities.
 * The <span name="org.apache.pekko.stream.impl.fusing.GraphInterpreter" class="extype">org.apache.pekko.stream.impl.fusing.GraphInterpreter</span> and its actor backed wrapper <span name="org.apache.pekko.stream.impl.fusing.ActorGraphInterpreter" class="extype">org.apache.pekko.stream.impl.fusing.ActorGraphInterpreter</span>
   are used to execute synchronous islands (subgraphs) of <a href="stage/GraphStage.html" name="org.apache.pekko.stream.stage.GraphStage" id="org.apache.pekko.stream.stage.GraphStage" class="extype">org.apache.pekko.stream.stage.GraphStage</a>s.</p><p>For the execution layer, refer to <span name="org.apache.pekko.stream.impl.fusing.GraphInterpreter" class="extype">org.apache.pekko.stream.impl.fusing.GraphInterpreter</span>.</p><h4> Design goals </h4><p>The central piece for both the DSLs and materialization is the <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span>. This is the
representation of an Akka Stream, basically a <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">org.apache.pekko.stream.scaladsl.RunnableGraph</a>. The design goals
for <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> are:</p><p>  * Be able to materialize a graph in one pass over the traversal
  * Unify materialization and fusing. The materializer should be able to construct all the necessary data structures
    for the interpreters and for connecting them in one go.
  * Avoid allocations as much as possible.
  * Biased implementation for the 90% case. Common cases should be as fast as possible:
    * wiring linear chains should be very fast.
    * assume that most graphs are mostly linear, with only a few generalized graph constructs thrown in.
    * materialization should not pay the price of island tracking if there is only a single island
    * assume that the number of islands is low in general
    * avoid "copiedModule" i.e. wrappers that exist solely for the purpose of establishing new port identities
      for operators that are used multiple times in the same graph.
  * Avoid hashmaps and prefer direct array lookup wherever possible</p><p>Semantically, a traversal is a list of commands that the materializer must execute to turn the description to a
running stream. In fact, the traversal is nothing more than an immutable list, that is expressed as a tree. A
tree is used to make immutable appends fast (immutable lists only have prepend as O(1) operation, append is O(N)).
The materializer "recovers" the original sequence by using a local, mutable stack to properly traverse the tree
structure. This is way cheaper than to immutably append to the traversal at each addition.</p><p>The "tree-ness" is expressed by explicit <span name="org.apache.pekko.stream.impl.Concat" class="extype">org.apache.pekko.stream.impl.Concat</span> nodes that express that two traversals
need to be traversed in a certain sequence, stashing away the second on a local stack until the first is fully
traversed.</p><p>While traversing the traversal (basically following Concat nodes), the materializer will visit the following
command types:</p><p> * <span name="org.apache.pekko.stream.impl.MaterializeAtomic" class="extype">org.apache.pekko.stream.impl.MaterializeAtomic</span>: An atomic module needs to be materialized. This node also contains
   wiring information which we discuss later.
 * Materialized value computation. This is a stack based "sublanguage" to compute the final materialized value
   on a stack, maintained by the materializer
   * <span name="org.apache.pekko.stream.impl.PushNotUsed" class="extype">org.apache.pekko.stream.impl.PushNotUsed</span> push a NotUsed value on the stack
   * <span name="org.apache.pekko.stream.impl.Pop" class="extype">org.apache.pekko.stream.impl.Pop</span> pop the top of the stack and throw away
   * <span name="org.apache.pekko.stream.impl.Transform" class="extype">org.apache.pekko.stream.impl.Transform</span> take the top of the stack, transform it with the provided function and put
     the result back on the top of the stack
   * <span name="org.apache.pekko.stream.impl.Compose" class="extype">org.apache.pekko.stream.impl.Compose</span> take the top two values of the stack, invoke the provided function with these
     values as arguments, then put the calculated value on the top of the stack
   * Materialized values of atomic operators when visiting a <span name="org.apache.pekko.stream.impl.MaterializeAtomic" class="extype">org.apache.pekko.stream.impl.MaterializeAtomic</span> must be
     pushed to the stack automatically. There are no explicit PUSH commands for this
 * Attributes calculation. These also are a stack language, although much simpler than the materialized value
    commands. For any materialized operator, the top of the attributes stack should be provided as the current
    effective attributes.
   * <span name="org.apache.pekko.stream.impl.PushAttributes" class="extype">org.apache.pekko.stream.impl.PushAttributes</span> combines the attributes on the top of the stack with the given ones and
     puts the result on the attributes stack
   * <span name="org.apache.pekko.stream.impl.PopAttributes" class="extype">org.apache.pekko.stream.impl.PopAttributes</span> removes the top of the attributes stack.
 * Island tracking. Islands serve two purposes. First, they allow a large graph to be cut into parts that execute
   concurrently with each other, using asynchronous message passing between themselves. Second, they are an
   extension point where "plugins" (<span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span>) can be used to specially handle subgraphs.
   Islands can be nested in each other. This makes "holes" in the parent island. Islands also need a stack
   as exiting a "hole" means returning to the parent, enclosing island and continuing where left.
    * <span name="org.apache.pekko.stream.impl.EnterIsland" class="extype">org.apache.pekko.stream.impl.EnterIsland</span> instructs the materializer that the following commands will belong to
      the materialization of a new island (a subgraph). The <span name="org.apache.pekko.stream.impl.IslandTag" class="extype">org.apache.pekko.stream.impl.IslandTag</span> signals to
      the materializer which <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span> should be used to turn operators of this island into
      executable entities.
    * <span name="org.apache.pekko.stream.impl.ExitIsland" class="extype">org.apache.pekko.stream.impl.ExitIsland</span> instructs the materializer that the current island is done and the parent
      island is now the active one again.</p><p> Please note that the stack based materialized value computation eliminates the issues present in the older
 materializer which expressed these computations as an AST. We had to use optimizations for this tree so that
 long Keep.left chains don't explode the stack visiting a large AST. The stack based language sidesteps this issue
 completely as the number of these commands don't increase the stack space required to execute them, unless the
 computation itself requires it (which is not the case in any sane stream combination).</p><h4> Graph model, offsets, slots </h4><p> As a mental model, the wiring part of the Traversal (i.e. excluding the stack based sub-commands tracking
 materialized values, attributes, islands, i.e. things that don't contribute to the wiring structure of the graph)
 translates everything to a single, global, contiguous Array. Every input and output port of each operator is mapped
 to exactly one slot of this "mental array". Input and output ports that are considered wired together simply map
 to the same slot. (In practice, these slots might not be mapped to an actual global array, but multiple local arrays
 using some translation logic, but we will explain this later)</p><p> Input ports are mapped simply to contiguous numbers in the order they are visited. Take for example a simple
 traversal:</p><p>   Operator1[in1, in2, out] - Operator2[out] - Operator3[in]</p><p> This results in the following slot assignments:</p><p>   * Operator1.in1 -&gt; 0
   * Operator1.in2 -&gt; 1
   * Operator3.in  -&gt; 2</p><p> The materializer simply visits Stage1, Stage2, Stage3 in order, visiting the input ports of each operator in order.
 It then simply assigns numbers from a counter that is incremented after visiting an input port.
 (Please note that all <span name="org.apache.pekko.stream.impl.StreamLayout.AtomicModule" class="extype">org.apache.pekko.stream.impl.StreamLayout.AtomicModule</span>s maintain a stable order of their ports, so
 this global ordering is well defined)</p><p> Before explaining how output wiring works, it is important to settle some terminology. When we talk about ports
 we refer to their location in the "mental array" as slots. However, there are other entities that needs to
 reference various positions in this "mental array", but in these cases we use the term _offset_ to signify that
 these are only used for bookkeeping, they have no "place" in the "array" themselves. In particular:</p><p>  * offset of a module: The offset of an <span name="org.apache.pekko.stream.impl.StreamLayout.AtomicModule" class="extype">org.apache.pekko.stream.impl.StreamLayout.AtomicModule</span> is defined as the value of
    the input port counter when visiting the <span name="org.apache.pekko.stream.impl.MaterializeAtomic" class="extype">org.apache.pekko.stream.impl.MaterializeAtomic</span> node to materialize that module.
    In other words, the offset of a module is the slot of its first input port (if there is any). Since modules
    might not have any input ports it can be that different modules share the same offset, simply because the
    the first one visited does not increase the input port counter.
  * offset of segments, islands: Defined similarly to module. The offset of an island or a segment is simply the
    value of the input port counter (or the first unallocated slot).</p><p> For example:</p><p>   Module1[in1 = 0, in2 = 1] - Module2[out] - Module3[in = 2]</p><p> The offset of Module1 is 0, while Module2 and Module3 share the same offset of 2. Note that only input ports (slots)
 contribute to the offset of a module in a traversal.</p><p> Output ports are wired relative to the offset of the module they are contained in. When the materializer visits
 a <span name="org.apache.pekko.stream.impl.MaterializeAtomic" class="extype">org.apache.pekko.stream.impl.MaterializeAtomic</span> node, it contains an Array that maps ports to a relative offset. To
 calculate the slot that is assigned to an output port the following formula is used:</p><p>   slot = offsetOfModule + outToSlots(out.id)</p><p> Where outToSlots is the array contained in the <span name="org.apache.pekko.stream.impl.MaterializeAtomic" class="extype">org.apache.pekko.stream.impl.MaterializeAtomic</span> node.</p><h4> Relative addressing </h4><p> The power of this structure comes from the fact that slots are assigned in a relative manner:</p><p>  * input ports are assigned in sequence so the slots assigned to the input ports of a subgraph depend on the
    subgraph's position in the traversal
  * output ports are assigned relative to the offset of their owner module, which is in turn relative to its first
    (potential) input port (which is relative, too, because of the previous point)</p><p> This setup allows combining subgraphs without touching their internal wirings as all their internal wirings will
 properly resolve due to everything being relative:</p><p>      +---------------+                     +----+
      |               |                     |    |
   |---------Graph1---------|--- .... ---|----Graph2----|</p><p> It is important to note that due to reusability, an Akka Stream graph may contain the same atomic or composite
 multiple times in the same graph. Since these must be distinguished from each other somehow, they need port mapping
 (i.e. a new set of ports) to ensure that the ports of one graph are distinguishable from another. Because how
 the traversal relative addressing works, these are _temporary_ though, once all internal wirings are ready, these
 mappings can be effectively dropped as the global slot assignments uniquely identify what is wired to what. For
 example since Graph1 is visited before Graph2 all of the slots or offsets it uses are different from Graph2 leaving
 no room for misinterpretation.</p><h4> Port mapping </h4><p> Port mapping is the way how the DSL can distinguish between multiple instances of the same graph included multiple
 times. For example in the Graph DSL:</p><p>   val merge1 = builder.add(Merge)
   val merge2 = builder.add(Merge)</p><p> the port merge1.out must be different from merge2.out.</p><p> For efficiency reasons, the linear and graph DSLs use different <span name="org.apache.pekko.stream.impl.TraversalBuilder" class="extype">org.apache.pekko.stream.impl.TraversalBuilder</span> types to
 build the <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> (we will discuss these next). One of the differences between the two
 builders are their approach to port mapping.</p><p> The simpler case is the <span name="org.apache.pekko.stream.impl.LinearTraversalBuilder" class="extype">org.apache.pekko.stream.impl.LinearTraversalBuilder</span>. This builder only allows building linear
 chains of operators, hence, it can only have at most one <a href="OutPort.html" name="org.apache.pekko.stream.OutPort" id="org.apache.pekko.stream.OutPort" class="extype">OutPort</a> and <a href="InPort.html" name="org.apache.pekko.stream.InPort" id="org.apache.pekko.stream.InPort" class="extype">InPort</a> unwired. Since there is no
 possible ambiguity between these two port types, there is no need for port mapping for these. Conversely,
 for those internal ports that are already wired, there is no need for port mapping as their relative wiring
 is not ambiguous (see previous section). As a result, the <span name="org.apache.pekko.stream.impl.LinearTraversalBuilder" class="extype">org.apache.pekko.stream.impl.LinearTraversalBuilder</span> does not
 use any port mapping.</p><p> The generic graph builder class <span name="org.apache.pekko.stream.impl.CompositeTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompositeTraversalBuilder</span> needs port mapping as it allows
 adding any kind of builders in any order. When adding a module (encoded as another <span name="org.apache.pekko.stream.impl.TraversalBuilder" class="extype">org.apache.pekko.stream.impl.TraversalBuilder</span>)
 there are two entities in play:</p><p>  * The module (builder) to be added. This builder has a few ports unwired which are usually packaged in a <a href="Shape.html" name="org.apache.pekko.stream.Shape" id="org.apache.pekko.stream.Shape" class="extype">Shape</a>
    which is stored alongside with the builder in the <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a> of the DSL. When invoking methods on this builder
    these set of ports must be used.
  * The module that we are growing. This module needs a new set of ports to be used as it might add this module
    multiple times and needs to disambiguate these ports.</p><p> Adding to the <span name="org.apache.pekko.stream.impl.CompositeTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompositeTraversalBuilder</span> involves the following steps (pseudocode):</p><p>    val newShape = shape.deepCopy() // Copy the shape of the module we want to add
    val newBuilder = builder.add(submodule, newShape) // Add the module, and register it with the new shape
    newBuilder.wire(newShape.in, ...) // Use the new ports to wire</p><p> What happens in the background is that <a href="Shape.html#deepCopy():org.apache.pekko.stream.Shape" name="org.apache.pekko.stream.Shape#deepCopy" id="org.apache.pekko.stream.Shape#deepCopy" class="extmbr">Shape.deepCopy</a> creates copies of the ports, and fills their
 mappedTo field to point to their original port counterpart. Whenever we call wire in the outer module, it
 delegates calls to the submodule, but using the original port (as the submodule builder has no knowledge of
 the external mapping):</p><p>     submodule.assign(port.mappedTo, ...) // enclosing module delegating to submodule, translating ports back</p><p> Visualizing this relationship:</p><p>   +----------------------------------+
   | in', in" ---------+              | in' and in" both resolve to in
   |   | .mappedTo     v .mappedTo    | but they will be used on _different_ builders
   | +-------------+ +-------------+  |
   | | in          | | in          |  | (delegation happens recursively in AddedModule)
   | | AddedModule | | AddedModule |  |</p><p> It is worth to note that the submodule might also continue this map-and-delegate chain to further submodules until
 a builder is reached that can directly perform the operation. In other words, the depth of nesting is equal to
 the length of mappedTo chaining.</p><p> IMPORTANT: When wiring in the enclosing module the new ports/shape MUST be used, using the original ports/shape
 will lead to incorrect state.</p><h4> TraversalBuilders </h4><p> In order to understand why builders are needed, consider wiring two ports together. Actually, we don't need to
 wire input ports anywhere. Their slot is implicitly assigned by their position in the traversal, there is no
 additional state we need to track. On the other hand, we cannot build a <span name="org.apache.pekko.stream.impl.MaterializeAtomic" class="extype">org.apache.pekko.stream.impl.MaterializeAtomic</span>
 node until the mapping array outToSlots is fully calculated. In other words, in reality, we don't wire input ports
 anywhere, we only assign output ports to slots. The builders exist mainly to keep track all the necessary
 information to be able to assign output ports, build the outToSlots array and finally the <span name="org.apache.pekko.stream.impl.MaterializeAtomic" class="extype">org.apache.pekko.stream.impl.MaterializeAtomic</span>
 node. The consequence of this that a <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> can be constructed as soon as all output ports
 are wired ("unwired" inputs don't matter).</p><p> There is a specific builder that is used for the cases where all outputs have been wired:
 <span name="org.apache.pekko.stream.impl.CompletedTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompletedTraversalBuilder</span>. This builder type simply contains the completed traversal plus
 some additional data. The reason why this builder type exists is to keep auxiliary data structures required for
 output port mapping only while they are needed, and shed them as soon as they are not needed anymore. Since builders
 may recursively contain other builders, as soon as internals are completed those contained builders transition
 to completed state and drop all additional data structures. This is very GC friendly as many intermediate graphs
 exist only in a method call, and hence most of the additional data structures are dropped before method return and
 can be efficiently collected by the GC.</p><p> The most generic builder is <span name="org.apache.pekko.stream.impl.CompositeTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompositeTraversalBuilder</span>. There are two main considerations
 this builder needs to consider:</p><p>  * Enclosed modules (builders) must have a stable position in the final traversal for relative addressing to work.
    Since module offsets are calculated by traversal position, and outputs are wired relative to module offset, this
    is critical.
  * Enclosed builders might not be complete yet (i.e. have unwired outputs) and hence they cannot immediately give
    a Traversal.</p><p> The composite builder keeps a temporary list of traversal steps (in reverse order because of immutable lists)
 it needs to create once it is completed (all outputs wired). These steps refer to the traversal of submodules
 as a <span name="org.apache.pekko.stream.impl.BuilderKey" class="extype">org.apache.pekko.stream.impl.BuilderKey</span> which is just a placeholder where the traversal of the submodule will be
 stitched in. This <span name="org.apache.pekko.stream.impl.BuilderKey" class="extype">org.apache.pekko.stream.impl.BuilderKey</span> is also a key to a map which contains the evolving builder.
 The importance of this "preimage" traversal is that it keeps position of submodules stable, making relative
 addressing possible.</p><p> Once the composite is completed, it takes these steps (now reversing it back to normal), and builds the traversal
 using the submodule traversals referred to by <span name="org.apache.pekko.stream.impl.BuilderKey" class="extype">org.apache.pekko.stream.impl.BuilderKey</span>. Note that at this point all the
 submodules are <span name="org.apache.pekko.stream.impl.CompletedTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompletedTraversalBuilder</span>s because there are no unwired outputs and hence the
 Traversal can be assembled. As the builder evolves over time, more and more of its <span name="org.apache.pekko.stream.impl.BuilderKey" class="extype">org.apache.pekko.stream.impl.BuilderKey</span>s
 will refer to <span name="org.apache.pekko.stream.impl.CompletedTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompletedTraversalBuilder</span>s, shedding much of the temporary data structures.</p><p> Refer to <span name="org.apache.pekko.stream.impl.CompositeTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompositeTraversalBuilder</span> for more details.</p><p> The <span name="org.apache.pekko.stream.impl.LinearTraversalBuilder" class="extype">org.apache.pekko.stream.impl.LinearTraversalBuilder</span> is a much simpler beast. For efficiency, it tries to work as much
 as possible directly on the <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> avoiding auxiliary structures. The two main considerations
 for this builder are:</p><p>  * <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">org.apache.pekko.stream.scaladsl.Source</a> and <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">org.apache.pekko.stream.scaladsl.Flow</a> contain an unwired output port. Yet, we would
    like to build the traversal directly as much as possible, even though the builder is not yet completed
  * <span name="org.apache.pekko.stream.impl.CompositeTraversalBuilder" class="extype">org.apache.pekko.stream.impl.CompositeTraversalBuilder</span>s might be included in a linear chain. These cannot provide a
    traversal before they are fully completed.</p><p> The linear builder, although it is one class, comes in basically two flavors:</p><p>  * Purely linear builder: this contains only other linear builders, or all the composites that it includes
    have been fully wired before and hence their traversal is now fully incorporated. Basically this kind
    of builder only contains the <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> and only a couple of extra fields.
  * Linear builder with an incomplete composite at the end (output): In this case, we have an incomplete composite.
    It can only be at the end, since this is the only position where an output port can be unwired. We need to
    carry this builder with us until the output port is finally wired, in which case we incorporate its traversal
    into the already complete one, and hopefully transition to a purely linear builder.</p><p> If we consider the purely linear case, we still need to figure out how can we provide a traversal even though
 the last output port is unwired. The trick that is used is to wire this output port optimistically to the
 relative address -1 which is almost always correct (why -1? explained a bit later). If it turns out to be incorrect
 later, we fix it by the helper method <span name="org.apache.pekko.stream.impl.Traversal.rewireFirstTo" class="extype">org.apache.pekko.stream.impl.Traversal.rewireFirstTo</span> which tears down the traversal
 until the wrong module is found, then fixes the port assignment. This is only possible on purely linear layouts though.
 Again, this is an example of the 90% rule. Most appends will not need this rewiring and hence be as fast as possible
 while the rarer cases suffering a minor penalty.</p><p> In the case where the last module is a composite, the above trick would not work as nothing guarantees that the
 module that exposed its output port is at an expected position in the traversal. Instead, we simply keep around
 this composite and delay construction of its part of the traversal. For details see <span name="org.apache.pekko.stream.impl.LinearTraversalBuilder" class="extype">org.apache.pekko.stream.impl.LinearTraversalBuilder</span>
 as these cases are heavily commented and explained in the code.</p><p> There is another peculiarity of the linear builder we need to explain. Namely, it builds the traversal in reverse
 order, i.e. from Sinks towards Sources. THIS CAN BE SUPER CONFUSING AT TIMES SO PAY ATTENTION! There are two
 important reasons why this is needed:</p><p>  * Prepending to immutable lists is more efficient. Even though we encode our traversal list as a tree, we would
    need stack space at materialization time as much as the length of the list if we would append to it instead of
    prepending.
  * Prepending means that most output ports refer to slots visited before, i.e. output relative offsets are negative.
    This means that during materialization, output ports will be wired to slots that the materializer visited before
    which enables an efficient one-pass materialization design. The importance of this is discussed later below.</p><p> To visualize this, imagine a simple stream:</p><p>   [Source.out] -&gt; [Map.in, Map.out] -&gt; [Sink.in]</p><p> The traversal:</p><p>    offs = 0         offs = 1                      offs = 1
   [Sink.in = 0] &lt;- [Map.in = 1, Map.out = -1] &lt;- [Source.out = -1]</p><p> Since the traversal steps are reversed compared to the DSL order, it is important to reverse materialized value
 computation, too.</p><h4> Islands and local slots </h4><p> All what we have discussed so far referred to the "mental array", the global address space in which slots
 are assigned to ports. This model describes the wiring of the graph perfectly, but it does not map to the local
 data structures needed by materialization when there are islands present. One of the important goals of this
 layout data structure is to be able to produce the data structures used by the <span name="org.apache.pekko.stream.impl.fusing.GraphInterpreter" class="extype">org.apache.pekko.stream.impl.fusing.GraphInterpreter</span>
 directly, without much translation. Unfortunately if there is an island inside a traversal, it might leave gaps
 in the address space:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> Since we visit Island2 before returning to Island1, the naive approach would leave a large gap between the last
 input port visited before entering Island2 and the first input port visited when returning to Island1. What
 we would like to have instead is a contiguous slot assignment from the viewpoint of Island1. This is where
 <span name="org.apache.pekko.stream.impl.PhasedFusingActorMaterializer" class="extype">org.apache.pekko.stream.impl.PhasedFusingActorMaterializer</span> and its <span name="org.apache.pekko.stream.impl.IslandTracking" class="extype">org.apache.pekko.stream.impl.IslandTracking</span> helper comes into
 the picture. These classes do the heavy-lifting of traversing the traversal and then mapping global slots to
 slots local to the island, delegating then the local wiring to <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span> implementations.
 For example the <span name="org.apache.pekko.stream.impl.GraphStageIsland" class="extype">org.apache.pekko.stream.impl.GraphStageIsland</span> sees only a contigous slot-space and hence it can directly
 construct the array for the interpreter. It is not aware of the presence of other islands or how it is represented
 in the global slot-space.</p><h4> Materialization </h4><p> Materialzation is orchestrated by the <span name="org.apache.pekko.stream.impl.PhasedFusingActorMaterializer" class="extype">org.apache.pekko.stream.impl.PhasedFusingActorMaterializer</span>. It basically decodes the
 traversal and handles islands. This top-level materializer does not really handle the wiring _inside_ an island,
 it only handles wiring of Publishers and Subscribers that connect islands. Instead it delegates in-island wiring
 to <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span>s. For example a default fused island will be actually wired by
 <span name="org.apache.pekko.stream.impl.GraphStageIsland" class="extype">org.apache.pekko.stream.impl.GraphStageIsland</span>.</p><p> First, look at a traversal that has two islands:</p><p>   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this traversal, we have two islands, and three, so called _segments_. Segments are simply contiguous range of
 slots between <span name="org.apache.pekko.stream.impl.EnterIsland" class="extype">org.apache.pekko.stream.impl.EnterIsland</span> or <span name="org.apache.pekko.stream.impl.ExitIsland" class="extype">org.apache.pekko.stream.impl.ExitIsland</span> tags (in any combination). When
 the materializer encounters either an enter or exit command, it saves various information about the segment it
 just completed (what is its offset, how long it is measured in input slots, etc.). This information is later
 used to figure out if a wiring crosses island boundaries or is it local to the island.</p><p> It is important to note that the data structure for this is only allocated when there are islands. This is again
 the 90% rule in action. In addition, these data structures are <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" name="java.util.ArrayList" id="java.util.ArrayList" class="extype">java.util.ArrayList</a> instances, where lookups
 according to some value are implemented as simple linear scans. Since in 90% of the cases these structures are
 very short, this is the most efficient approach. Cases where this can be a performance problem are very-very special
 and likely not happen in practice (no graph should contain more than a dozen of islands for example).</p><p> When it comes to deciding whether a wiring is cross-island or local, there are two cases possible:</p><p>  * we encountered an output port that is wired backwards (relative address is negative). In this case we already
    have all the data necessary to resolve the question.
  * we encountered an output port that is wired forward (relative address is positive). In this case we have not
    yet visited that part of the traversal where the assignment points.</p><p> If we want to keep the one-pass design of the materializer, we need to delay forward wirings until we have all
 the information needed, i.e. we visit the target in port. The <span name="org.apache.pekko.stream.impl.PhasedFusingActorMaterializer" class="extype">org.apache.pekko.stream.impl.PhasedFusingActorMaterializer</span>
 has a data structure for tracking forward wires which it consults whenever it visits an input port. Again, this
 is only allocated if needed, and it is again an array with linear scan lookup. Once the target input port have
 been found, the rules of the wiring are the same as for backwards wiring.</p><p>       backward wire (to the visited part) &lt;------+ +------&gt; forward wire (into the unknown)
                                                  | |
  |----Island1-----|----Island2(enclosed)-------- ... (this is where we are now)</p><p> Remember, the <span name="org.apache.pekko.stream.impl.LinearTraversalBuilder" class="extype">org.apache.pekko.stream.impl.LinearTraversalBuilder</span> builds its <span name="org.apache.pekko.stream.impl.Traversal" class="extype">org.apache.pekko.stream.impl.Traversal</span> in backwards
 order, so since most of the graphs are constructed by the linear DSLs almost all wirings will be backwards
 (90% rule in action again).</p><h5> Backward wirings </h5><p> When it comes to resolving wirings and calculating the local slots for all the islands involved there are three
 distinct cases.</p><p> A wiring can be in-segment:</p><p>                        +--------------+
                        |              |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means that the slot assigned to the output port still belongs to the current segment. This is easy to detect
 as the <span name="org.apache.pekko.stream.impl.IslandTracking" class="extype">org.apache.pekko.stream.impl.IslandTracking</span> class tracks the offset of the current segment. If the target input
 slot is larger or equal than this offset, and the wiring is backwards, then the wiring is strictly local to the
 island. The materializer will simply delegate to the <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span> to do the internal wiring.
 Since we know the offset of the segment in the local space of this island, calculating the local slot for the
 <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span> is simple. (This is fully documented with diagrams
 in <span name="org.apache.pekko.stream.impl.IslandTracking" class="extype">org.apache.pekko.stream.impl.IslandTracking</span>)</p><p> A wiring can be cross-segment, in-island:</p><p>               +---------------------------------+
               |                                 |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> In this case, the target slot is in another, but already visited segment. The <span name="org.apache.pekko.stream.impl.IslandTracking" class="extype">org.apache.pekko.stream.impl.IslandTracking</span>
 class needs to first find the segment in which the target slot is. Since each segment keeps a reference to its
 <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span> instance that handles the internal wiring a simple reference equality check
 will tell us if the target segment is in the same island or not. In this case it is, so all we need is to
 compensate for any possible holes (punched by enclosed islands) to calculate the local slot for the island
 and call the appropriate callback on the <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span>. (This is fully documented with diagrams
 in <span name="org.apache.pekko.stream.impl.IslandTracking" class="extype">org.apache.pekko.stream.impl.IslandTracking</span>)</p><p> Finally a wiring can be cross-segment, cross-island:</p><p>                        +------------------------+
                        |                        |
   |----Island1-----|----Island2(enclosed)----|-----Island1-----|</p><p> This means, that the steps were similar as in the previous case until that point where we check the reference
 equality of the current <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span> with that of the target segment (we have already found
 the target segment). In this case, we need to calculate the local slot in the target island (similar to the
 previous case) and try to wire the two islands together. Now, instead of delegating the wiring to the phases, we
 ask the output <span name="org.apache.pekko.stream.impl.PhaseIsland" class="extype">org.apache.pekko.stream.impl.PhaseIsland</span> to provide a Publisher and then we ask the target island to
 take this Publisher.</p><p> Refer to <span name="org.apache.pekko.stream.impl.IslandTracking" class="extype">org.apache.pekko.stream.impl.IslandTracking</span> for all the nasty details of local slot resolution. It is also
 recommended to try out a few examples with <span name="org.apache.pekko.stream.impl.PhasedFusingActorMaterializer.Debug" class="extype">org.apache.pekko.stream.impl.PhasedFusingActorMaterializer.Debug</span> turned on, it
 will detail every step of the island tracking and slot resolution steps.</p><h4> Utilities </h4><p> Useful utilities are:</p><p>  * <span name="org.apache.pekko.stream.impl.PhasedFusingActorMaterializer.Debug" class="extype">org.apache.pekko.stream.impl.PhasedFusingActorMaterializer.Debug</span>: if this flag is turned on, the materializer will
    log the steps it takes
  * <span name="org.apache.pekko.stream.impl.TraversalBuilder.printTraversal" class="extype">org.apache.pekko.stream.impl.TraversalBuilder.printTraversal</span>: Prints the Traversal in a readable format
  * <span name="org.apache.pekko.stream.impl.TraversalBuilder.printWiring" class="extype">org.apache.pekko.stream.impl.TraversalBuilder.printWiring</span>: Prints the calculated port assignments. Useful for
    debugging if everything is wired to the right thing.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></dd></dl></div></li><li class="indented5 " name="org.apache.pekko.stream.javadsl" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="javadsl" class="anchorToMember"></a><a id="javadsl:javadsl" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/javadsl/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="javadsl/index.html" title=""><span class="name">javadsl</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></dd></dl></div></li><li class="indented5 " name="org.apache.pekko.stream.scaladsl" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scaladsl" class="anchorToMember"></a><a id="scaladsl:scaladsl" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/scaladsl/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="scaladsl/index.html" title="Scala API: The flow DSL allows the formulation of stream transformations based on some input."><span class="name">scaladsl</span></a></span><p class="shortcomment cmt">Scala API: The flow DSL allows the formulation of stream transformations based on some
input.</p><div class="fullcomment"><div class="comment cmt"><p>Scala API: The flow DSL allows the formulation of stream transformations based on some
input. The starting point is called <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> and can be a collection, an iterator,
a block of code which is evaluated repeatedly or a <span name="org.reactivestreams.Publisher" class="extype">org.reactivestreams.Publisher</span>.
A flow with an attached input and open output is also a <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>.</p><p>A flow may also be defined without an attached input or output and that is then
a <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>. The <code>Flow</code> can be connected to the <code>Source</code> later by using <a href="scaladsl/Source.html#via[T,Mat2](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2]):Source.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.Source#via" id="org.apache.pekko.stream.scaladsl.Source#via" class="extmbr">Source#via</a> with
the flow as argument, and it remains a <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>.</p><p>Transformations can be appended to <code>Source</code> and <code>Flow</code> with the operations
defined in <a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a>. Each DSL element produces a new flow that can be further transformed,
building up a description of the complete transformation pipeline.</p><p>The termination point of a flow is called <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> and can for example be a <code>Future</code> or
<span name="org.reactivestreams.Subscriber" class="extype">org.reactivestreams.Subscriber</span>. A flow with an attached output and open input
is also a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>.</p><p>If a flow has both an attached input and an attached output it becomes a <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>.
In order to execute this pipeline the flow must be materialized by calling <a href="scaladsl/RunnableGraph.html#run()(implicitmaterializer:org.apache.pekko.stream.Materializer):Mat" name="org.apache.pekko.stream.scaladsl.RunnableGraph#run" id="org.apache.pekko.stream.scaladsl.RunnableGraph#run" class="extmbr">RunnableGraph#run</a> on it.</p><p>You can create your <code>Source</code>, <code>Flow</code> and <code>Sink</code> in any order and then wire them together before
they are materialized by connecting them using <a href="scaladsl/Flow.html#via[T,Mat2](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2]):Flow.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.Flow#via" id="org.apache.pekko.stream.scaladsl.Flow#via" class="extmbr">Flow#via</a> and <a href="scaladsl/Flow.html#to[Mat2](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2]):org.apache.pekko.stream.scaladsl.Sink[In,Mat]" name="org.apache.pekko.stream.scaladsl.Flow#to" id="org.apache.pekko.stream.scaladsl.Flow#to" class="extmbr">Flow#to</a>, or connecting them into a
<a href="scaladsl/GraphDSL$.html" name="org.apache.pekko.stream.scaladsl.GraphDSL" id="org.apache.pekko.stream.scaladsl.GraphDSL" class="extype">GraphDSL</a> with fan-in and fan-out elements.</p><p>See <a href="https://github.com/reactive-streams/reactive-streams/">Reactive Streams</a> for
details on <span name="org.reactivestreams.Publisher" class="extype">org.reactivestreams.Publisher</span> and <span name="org.reactivestreams.Subscriber" class="extype">org.reactivestreams.Subscriber</span>.</p><p>It should be noted that the streams modeled by this library are “hot”,
meaning that they asynchronously flow through a series of processors without
detailed control by the user. In particular it is not predictable how many
elements a given transformation step might buffer before handing elements
downstream, which means that transformation functions may be invoked more
often than for corresponding transformations on strict collections like
<span name="List" class="extype">List</span>. *An important consequence* is that elements that were produced
into a stream may be discarded by later processors, e.g. when using the
<span name="#take" class="extype">#take</span> operator.</p><p>By default every operation is executed within its own <a href="../actor/Actor.html" name="org.apache.pekko.actor.Actor" id="org.apache.pekko.actor.Actor" class="extype">org.apache.pekko.actor.Actor</a>
to enable full pipelining of the chained set of computations. This behavior
is determined by the <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">org.apache.pekko.stream.Materializer</a> which is required
by those methods that materialize the Flow into a series of
<span name="org.reactivestreams.Processor" class="extype">org.reactivestreams.Processor</span> instances. The returned reactive stream
is fully started and active.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></dd></dl></div></li><li class="indented5 " name="org.apache.pekko.stream.snapshot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="snapshot" class="anchorToMember"></a><a id="snapshot:snapshot" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/snapshot/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="snapshot/index.html" title=""><span class="name">snapshot</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></dd></dl></div></li><li class="indented5 " name="org.apache.pekko.stream.stage" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="stage" class="anchorToMember"></a><a id="stage:stage" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/stage/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="stage/index.html" title=""><span class="name">stage</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></dd></dl></div></li><li class="indented5 " name="org.apache.pekko.stream.testkit" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="testkit" class="anchorToMember"></a><a id="testkit:testkit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/testkit/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="testkit/index.html" title=""><span class="name">testkit</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></dd></dl></div></li><li class="indented5 " name="org.apache.pekko.stream.typed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="typed" class="anchorToMember"></a><a id="typed:typed" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/typed/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="typed/index.html" title=""><span class="name">typed</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></dd></dl></div></li><li class="current-entities indented4"><span class="separator"></span> <a href="AbruptIOTerminationException.html" title="This exception signals that a stream has been completed by an onError signal while there was still IO operations in progress." class="class"></a><a href="AbruptIOTerminationException.html" title="This exception signals that a stream has been completed by an onError signal while there was still IO operations in progress.">AbruptIOTerminationException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="AbruptStageTerminationException.html" title="Signal that the operator was abruptly terminated, usually seen as a call to postStop of the GraphStageLogic without any of the handler callbacks seeing completion or failure from upstream or cancellation from downstream." class="class"></a><a href="AbruptStageTerminationException.html" title="Signal that the operator was abruptly terminated, usually seen as a call to postStop of the GraphStageLogic without any of the handler callbacks seeing completion or failure from upstream or cancellation from downstream.">AbruptStageTerminationException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="AbruptTerminationException.html" title="This exception signals that an actor implementing a Reactive Streams Subscriber, Publisher or Processor has been terminated without being notified by an onError, onComplete or cancel signal." class="class"></a><a href="AbruptTerminationException.html" title="This exception signals that an actor implementing a Reactive Streams Subscriber, Publisher or Processor has been terminated without being notified by an onError, onComplete or cancel signal.">AbruptTerminationException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="AbstractShape.html" title="Java API for creating custom Shape types." class="class"></a><a href="AbstractShape.html" title="Java API for creating custom Shape types.">AbstractShape</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="ActorAttributes$.html" title="Attributes for the Materializer." class="object"></a><a href="ActorAttributes$.html" title="Attributes for the Materializer.">ActorAttributes</a></li><li class="current-entities indented4"><a href="ActorMaterializer$.html" title="" class="object"></a> <a href="ActorMaterializer.html" title="An ActorMaterializer takes a stream blueprint and turns it into a running stream." class="class"></a><a href="ActorMaterializer.html" title="An ActorMaterializer takes a stream blueprint and turns it into a running stream.">ActorMaterializer</a></li><li class="current-entities indented4"><a href="ActorMaterializerSettings$.html" title="" class="object"></a> <a href="ActorMaterializerSettings.html" title="This class describes the configurable properties of the ActorMaterializer." class="class"></a><a href="ActorMaterializerSettings.html" title="This class describes the configurable properties of the ActorMaterializer.">ActorMaterializerSettings</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="AmorphousShape.html" title="This type of Shape can express any number of inputs and outputs at the expense of forgetting about their specific types." class="class"></a><a href="AmorphousShape.html" title="This type of Shape can express any number of inputs and outputs at the expense of forgetting about their specific types.">AmorphousShape</a></li><li class="current-entities indented4"><a href="Attributes$.html" title="Note that more attributes for the Materializer are defined in ActorAttributes." class="object"></a> <a href="Attributes.html" title="Holds attributes which can be used to alter pekko.stream.scaladsl.Flow / pekko.stream.javadsl.Flow or pekko.stream.scaladsl.GraphDSL / pekko.stream.javadsl.GraphDSL materialization." class="class"></a><a href="Attributes.html" title="Holds attributes which can be used to alter pekko.stream.scaladsl.Flow / pekko.stream.javadsl.Flow or pekko.stream.scaladsl.GraphDSL / pekko.stream.javadsl.GraphDSL materialization.">Attributes</a></li><li class="current-entities indented4"><a href="BidiShape$.html" title="" class="object"></a> <a href="BidiShape.html" title="A bidirectional flow of elements that consequently has two inputs and two outputs, arranged like this:" class="class"></a><a href="BidiShape.html" title="A bidirectional flow of elements that consequently has two inputs and two outputs, arranged like this:">BidiShape</a></li><li class="current-entities indented4"><a href="BindFailedException$.html" title="" class="object"></a> <a href="BindFailedException.html" title="" class="class"></a><a href="BindFailedException.html" title="">BindFailedException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="BoundedSourceQueue.html" title="A queue of the given size that gives immediate feedback whether an element could be enqueued or not." class="trait"></a><a href="BoundedSourceQueue.html" title="A queue of the given size that gives immediate feedback whether an element could be enqueued or not.">BoundedSourceQueue</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="BufferOverflowException.html" title="" class="class"></a><a href="BufferOverflowException.html" title="">BufferOverflowException</a></li><li class="current-entities indented4"><a href="Client$.html" title="" class="object"></a> <a href="Client.html" title="The client is usually the side that consumes the service provided by its interlocutor." class="class"></a><a href="Client.html" title="The client is usually the side that consumes the service provided by its interlocutor.">Client</a></li><li class="current-entities indented4"><a href="ClosedShape$.html" title="" class="object"></a> <a href="ClosedShape.html" title="This Shape is used for graphs that have neither open inputs nor open outputs." class="class"></a><a href="ClosedShape.html" title="This Shape is used for graphs that have neither open inputs nor open outputs.">ClosedShape</a></li><li class="current-entities indented4"><a href="CompletionStrategy$.html" title="" class="object"></a> <a href="CompletionStrategy.html" title="" class="trait"></a><a href="CompletionStrategy.html" title="">CompletionStrategy</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="ConnectionException.html" title="" class="class"></a><a href="ConnectionException.html" title="">ConnectionException</a></li><li class="current-entities indented4"><a href="DelayOverflowStrategy$.html" title="" class="object"></a> <a href="DelayOverflowStrategy.html" title="Represents a strategy that decides how to deal with a buffer of time based operator that is full but is about to receive a new element." class="class"></a><a href="DelayOverflowStrategy.html" title="Represents a strategy that decides how to deal with a buffer of time based operator that is full but is about to receive a new element.">DelayOverflowStrategy</a></li><li class="current-entities indented4"><a href="EagerClose$.html" title="" class="object"></a> <a href="EagerClose.html" title="see TLSClosing" class="class"></a><a href="EagerClose.html" title="see TLSClosing">EagerClose</a></li><li class="current-entities indented4"><a href="FanInShape$.html" title="" class="object"></a> <a href="FanInShape.html" title="" class="class"></a><a href="FanInShape.html" title="">FanInShape</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape10.html" title="" class="class"></a><a href="FanInShape10.html" title="">FanInShape10</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape11.html" title="" class="class"></a><a href="FanInShape11.html" title="">FanInShape11</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape12.html" title="" class="class"></a><a href="FanInShape12.html" title="">FanInShape12</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape13.html" title="" class="class"></a><a href="FanInShape13.html" title="">FanInShape13</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape14.html" title="" class="class"></a><a href="FanInShape14.html" title="">FanInShape14</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape15.html" title="" class="class"></a><a href="FanInShape15.html" title="">FanInShape15</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape16.html" title="" class="class"></a><a href="FanInShape16.html" title="">FanInShape16</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape17.html" title="" class="class"></a><a href="FanInShape17.html" title="">FanInShape17</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape18.html" title="" class="class"></a><a href="FanInShape18.html" title="">FanInShape18</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape19.html" title="" class="class"></a><a href="FanInShape19.html" title="">FanInShape19</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape1N.html" title="" class="class"></a><a href="FanInShape1N.html" title="">FanInShape1N</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape2.html" title="" class="class"></a><a href="FanInShape2.html" title="">FanInShape2</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape20.html" title="" class="class"></a><a href="FanInShape20.html" title="">FanInShape20</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape21.html" title="" class="class"></a><a href="FanInShape21.html" title="">FanInShape21</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape22.html" title="" class="class"></a><a href="FanInShape22.html" title="">FanInShape22</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape3.html" title="" class="class"></a><a href="FanInShape3.html" title="">FanInShape3</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape4.html" title="" class="class"></a><a href="FanInShape4.html" title="">FanInShape4</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape5.html" title="" class="class"></a><a href="FanInShape5.html" title="">FanInShape5</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape6.html" title="" class="class"></a><a href="FanInShape6.html" title="">FanInShape6</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape7.html" title="" class="class"></a><a href="FanInShape7.html" title="">FanInShape7</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape8.html" title="" class="class"></a><a href="FanInShape8.html" title="">FanInShape8</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanInShape9.html" title="" class="class"></a><a href="FanInShape9.html" title="">FanInShape9</a></li><li class="current-entities indented4"><a href="FanOutShape$.html" title="" class="object"></a> <a href="FanOutShape.html" title="" class="class"></a><a href="FanOutShape.html" title="">FanOutShape</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape10.html" title="" class="class"></a><a href="FanOutShape10.html" title="">FanOutShape10</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape11.html" title="" class="class"></a><a href="FanOutShape11.html" title="">FanOutShape11</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape12.html" title="" class="class"></a><a href="FanOutShape12.html" title="">FanOutShape12</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape13.html" title="" class="class"></a><a href="FanOutShape13.html" title="">FanOutShape13</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape14.html" title="" class="class"></a><a href="FanOutShape14.html" title="">FanOutShape14</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape15.html" title="" class="class"></a><a href="FanOutShape15.html" title="">FanOutShape15</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape16.html" title="" class="class"></a><a href="FanOutShape16.html" title="">FanOutShape16</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape17.html" title="" class="class"></a><a href="FanOutShape17.html" title="">FanOutShape17</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape18.html" title="" class="class"></a><a href="FanOutShape18.html" title="">FanOutShape18</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape19.html" title="" class="class"></a><a href="FanOutShape19.html" title="">FanOutShape19</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape2.html" title="" class="class"></a><a href="FanOutShape2.html" title="">FanOutShape2</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape20.html" title="" class="class"></a><a href="FanOutShape20.html" title="">FanOutShape20</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape21.html" title="" class="class"></a><a href="FanOutShape21.html" title="">FanOutShape21</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape22.html" title="" class="class"></a><a href="FanOutShape22.html" title="">FanOutShape22</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape3.html" title="" class="class"></a><a href="FanOutShape3.html" title="">FanOutShape3</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape4.html" title="" class="class"></a><a href="FanOutShape4.html" title="">FanOutShape4</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape5.html" title="" class="class"></a><a href="FanOutShape5.html" title="">FanOutShape5</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape6.html" title="" class="class"></a><a href="FanOutShape6.html" title="">FanOutShape6</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape7.html" title="" class="class"></a><a href="FanOutShape7.html" title="">FanOutShape7</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape8.html" title="" class="class"></a><a href="FanOutShape8.html" title="">FanOutShape8</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FanOutShape9.html" title="" class="class"></a><a href="FanOutShape9.html" title="">FanOutShape9</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FlowMonitor.html" title="Used to monitor the state of a stream" class="trait"></a><a href="FlowMonitor.html" title="Used to monitor the state of a stream">FlowMonitor</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="FlowMonitorState$.html" title="" class="object"></a><a href="FlowMonitorState$.html" title="">FlowMonitorState</a></li><li class="current-entities indented4"><a href="FlowShape$.html" title="" class="object"></a> <a href="FlowShape.html" title="A Flow Shape has exactly one input and one output, it looks from the outside like a pipe (but it can be a complex topology of streams within of course)." class="class"></a><a href="FlowShape.html" title="A Flow Shape has exactly one input and one output, it looks from the outside like a pipe (but it can be a complex topology of streams within of course).">FlowShape</a></li><li class="current-entities indented4"><a href="Graph$.html" title="" class="object"></a> <a href="Graph.html" title="Not intended to be directly extended by user classes" class="trait"></a><a href="Graph.html" title="Not intended to be directly extended by user classes">Graph</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="IOOperationIncompleteException.html" title="This exception signals that a stream has been completed or has an error while there was still IO operations in progress" class="class"></a><a href="IOOperationIncompleteException.html" title="This exception signals that a stream has been completed or has an error while there was still IO operations in progress">IOOperationIncompleteException</a></li><li class="current-entities indented4"><a href="IOResult$.html" title="" class="object"></a> <a href="IOResult.html" title="Holds a result of an IO operation." class="class"></a><a href="IOResult.html" title="Holds a result of an IO operation.">IOResult</a></li><li class="current-entities indented4"><a href="IOSettings$.html" title="" class="object"></a> <a href="IOSettings.html" title="" class="class"></a><a href="IOSettings.html" title="">IOSettings</a></li><li class="current-entities indented4"><a href="IgnoreBoth$.html" title="" class="object"></a> <a href="IgnoreBoth.html" title="see TLSClosing" class="class"></a><a href="IgnoreBoth.html" title="see TLSClosing">IgnoreBoth</a></li><li class="current-entities indented4"><a href="IgnoreCancel$.html" title="" class="object"></a> <a href="IgnoreCancel.html" title="see TLSClosing" class="class"></a><a href="IgnoreCancel.html" title="see TLSClosing">IgnoreCancel</a></li><li class="current-entities indented4"><a href="IgnoreComplete$.html" title="" class="object"></a> <a href="IgnoreComplete.html" title="see TLSClosing" class="class"></a><a href="IgnoreComplete.html" title="see TLSClosing">IgnoreComplete</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="InPort.html" title="An input port of a StreamLayout.Module." class="class"></a><a href="InPort.html" title="An input port of a StreamLayout.Module.">InPort</a></li><li class="current-entities indented4"><a href="Inlet$.html" title="An Inlet is a typed input to a Shape." class="object"></a> <a href="Inlet.html" title="" class="class"></a><a href="Inlet.html" title="">Inlet</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="InvalidPartnerActorException.html" title="Stream refs establish a connection between a local and remote actor, representing the origin and remote sides of a stream." class="class"></a><a href="InvalidPartnerActorException.html" title="Stream refs establish a connection between a local and remote actor, representing the origin and remote sides of a stream.">InvalidPartnerActorException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="InvalidSequenceNumberException.html" title="" class="class"></a><a href="InvalidSequenceNumberException.html" title="">InvalidSequenceNumberException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="KillSwitch.html" title="A KillSwitch allows completion of Graphs from the outside by completing Graphs of FlowShape linked to the switch." class="trait"></a><a href="KillSwitch.html" title="A KillSwitch allows completion of Graphs from the outside by completing Graphs of FlowShape linked to the switch.">KillSwitch</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="KillSwitches$.html" title="Creates shared or single kill switches which can be used to control completion of graphs from the outside." class="object"></a><a href="KillSwitches$.html" title="Creates shared or single kill switches which can be used to control completion of graphs from the outside.">KillSwitches</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="MaterializationException.html" title="This exception or subtypes thereof should be used to signal materialization failures." class="class"></a><a href="MaterializationException.html" title="This exception or subtypes thereof should be used to signal materialization failures.">MaterializationException</a></li><li class="current-entities indented4"><a href="Materializer$.html" title="" class="object"></a> <a href="Materializer.html" title="The Materializer is the component responsible for turning a stream blueprint into a running stream." class="class"></a><a href="Materializer.html" title="The Materializer is the component responsible for turning a stream blueprint into a running stream.">Materializer</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="MaterializerLoggingProvider.html" title="Not for user extension" class="trait"></a><a href="MaterializerLoggingProvider.html" title="Not for user extension">MaterializerLoggingProvider</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="NeverMaterializedException.html" title="" class="class"></a><a href="NeverMaterializedException.html" title="">NeverMaterializedException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="OutPort.html" title="An output port of a StreamLayout.Module." class="class"></a><a href="OutPort.html" title="An output port of a StreamLayout.Module.">OutPort</a></li><li class="current-entities indented4"><a href="Outlet$.html" title="An Outlet is a typed output to a Shape." class="object"></a> <a href="Outlet.html" title="" class="class"></a><a href="Outlet.html" title="">Outlet</a></li><li class="current-entities indented4"><a href="OverflowStrategy$.html" title="" class="object"></a> <a href="OverflowStrategy.html" title="Represents a strategy that decides how to deal with a buffer that is full but is about to receive a new element." class="class"></a><a href="OverflowStrategy.html" title="Represents a strategy that decides how to deal with a buffer that is full but is about to receive a new element.">OverflowStrategy</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="QueueCompletionResult.html" title="Not for user extension" class="class"></a><a href="QueueCompletionResult.html" title="Not for user extension">QueueCompletionResult</a></li><li class="current-entities indented4"><a href="QueueOfferResult$.html" title="Contains types that is used as return types for streams Source queues" class="object"></a> <a href="QueueOfferResult.html" title="Not for user extension" class="class"></a><a href="QueueOfferResult.html" title="Not for user extension">QueueOfferResult</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="RateExceededException.html" title="Exception that is thrown when rated controlled by stream is exceeded" class="class"></a><a href="RateExceededException.html" title="Exception that is thrown when rated controlled by stream is exceeded">RateExceededException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="RemoteStreamRefActorTerminatedException.html" title="" class="class"></a><a href="RemoteStreamRefActorTerminatedException.html" title="">RemoteStreamRefActorTerminatedException</a></li><li class="current-entities indented4"><a href="RestartSettings$.html" title="" class="object"></a> <a href="RestartSettings.html" title="" class="class"></a><a href="RestartSettings.html" title="">RestartSettings</a></li><li class="current-entities indented4"><a href="Server$.html" title="" class="object"></a> <a href="Server.html" title="The server is usually the side the provides the service to its interlocutor." class="class"></a><a href="Server.html" title="The server is usually the side the provides the service to its interlocutor.">Server</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="Shape.html" title="A Shape describes the inlets and outlets of a Graph." class="class"></a><a href="Shape.html" title="A Shape describes the inlets and outlets of a Graph.">Shape</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="SharedKillSwitch.html" title="A SharedKillSwitch is a provider for Graphs of FlowShape that can be completed or failed from the outside." class="class"></a><a href="SharedKillSwitch.html" title="A SharedKillSwitch is a provider for Graphs of FlowShape that can be completed or failed from the outside.">SharedKillSwitch</a></li><li class="current-entities indented4"><a href="SinkRef$.html" title="See full documentation on SinkRef." class="object"></a> <a href="SinkRef.html" title="A SinkRef allows sharing a &quot;reference&quot; to a Sink with others, with the main purpose of crossing a network boundary." class="trait"></a><a href="SinkRef.html" title="A SinkRef allows sharing a &quot;reference&quot; to a Sink with others, with the main purpose of crossing a network boundary.">SinkRef</a></li><li class="current-entities indented4"><a href="SinkShape$.html" title="" class="object"></a> <a href="SinkShape.html" title="A Sink Shape has exactly one input and no outputs, it models a data sink." class="class"></a><a href="SinkShape.html" title="A Sink Shape has exactly one input and no outputs, it models a data sink.">SinkShape</a></li><li class="current-entities indented4"><a href="SourceRef$.html" title="See full documentation on SourceRef." class="object"></a> <a href="" title="A SourceRef allows sharing a &quot;reference&quot; with others, with the main purpose of crossing a network boundary." class="trait"></a><a href="" title="A SourceRef allows sharing a &quot;reference&quot; with others, with the main purpose of crossing a network boundary.">SourceRef</a></li><li class="current-entities indented4"><a href="SourceShape$.html" title="" class="object"></a> <a href="SourceShape.html" title="A Source Shape has exactly one output and no inputs, it models a source of data." class="class"></a><a href="SourceShape.html" title="A Source Shape has exactly one output and no inputs, it models a source of data.">SourceShape</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="StreamDetachedException.html" title="This exception signals that materialized value is already detached from stream." class="class"></a><a href="StreamDetachedException.html" title="This exception signals that materialized value is already detached from stream.">StreamDetachedException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="StreamLimitReachedException.html" title="" class="class"></a><a href="StreamLimitReachedException.html" title="">StreamLimitReachedException</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="StreamRefAttributes$.html" title="Attributes for stream refs (pekko.stream.SourceRef and pekko.stream.SinkRef)." class="object"></a><a href="StreamRefAttributes$.html" title="Attributes for stream refs (pekko.stream.SourceRef and pekko.stream.SinkRef).">StreamRefAttributes</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="StreamRefMessages.html" title="" class="class"></a><a href="StreamRefMessages.html" title="">StreamRefMessages</a></li><li class="current-entities indented4"><a href="StreamRefResolver$.html" title="The stream ref resolver extension provides a way to serialize and deserialize streamrefs in user serializers." class="object"></a> <a href="StreamRefResolver.html" title="The stream ref resolver provides a way to serialize and deserialize streamrefs in user serializers." class="trait"></a><a href="StreamRefResolver.html" title="The stream ref resolver provides a way to serialize and deserialize streamrefs in user serializers.">StreamRefResolver</a></li><li class="current-entities indented4"><a href="StreamRefSettings$.html" title="" class="object"></a> <a href="StreamRefSettings.html" title="Settings specific to SourceRef and SinkRef." class="trait"></a><a href="StreamRefSettings.html" title="Settings specific to SourceRef and SinkRef.">StreamRefSettings</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="StreamRefSubscriptionTimeoutException.html" title="" class="class"></a><a href="StreamRefSubscriptionTimeoutException.html" title="">StreamRefSubscriptionTimeoutException</a></li><li class="current-entities indented4"><a href="StreamSubscriptionTimeoutSettings$.html" title="" class="object"></a> <a href="StreamSubscriptionTimeoutSettings.html" title="Leaked publishers and subscribers are cleaned up when they are not used within a given deadline, configured by StreamSubscriptionTimeoutSettings." class="class"></a><a href="StreamSubscriptionTimeoutSettings.html" title="Leaked publishers and subscribers are cleaned up when they are not used within a given deadline, configured by StreamSubscriptionTimeoutSettings.">StreamSubscriptionTimeoutSettings</a></li><li class="current-entities indented4"><a href="StreamSubscriptionTimeoutTerminationMode$.html" title="" class="object"></a> <a href="StreamSubscriptionTimeoutTerminationMode.html" title="This mode describes what shall happen when the subscription timeout expires for substream Publishers created by operations like prefixAndTail." class="class"></a><a href="StreamSubscriptionTimeoutTerminationMode.html" title="This mode describes what shall happen when the subscription timeout expires for substream Publishers created by operations like prefixAndTail.">StreamSubscriptionTimeoutTerminationMode</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="StreamTcpException.html" title="" class="class"></a><a href="StreamTcpException.html" title="">StreamTcpException</a></li><li class="current-entities indented4"><a href="SubscriptionWithCancelException$.html" title="" class="object"></a> <a href="SubscriptionWithCancelException.html" title="Extension of Subscription that allows to pass a cause when a subscription is cancelled." class="trait"></a><a href="SubscriptionWithCancelException.html" title="Extension of Subscription that allows to pass a cause when a subscription is cancelled.">SubscriptionWithCancelException</a></li><li class="current-entities indented4"><a href="SubstreamCancelStrategy$.html" title="" class="object"></a> <a href="SubstreamCancelStrategy.html" title="Represents a strategy that decides how to deal with substream events." class="class"></a><a href="SubstreamCancelStrategy.html" title="Represents a strategy that decides how to deal with substream events.">SubstreamCancelStrategy</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="Supervision$.html" title="" class="object"></a><a href="Supervision$.html" title="">Supervision</a></li><li class="current-entities indented4"><a href="SystemMaterializer$.html" title="The system materializer is a default materializer to use for most cases running streams, it is a single instance per actor system that is tied to the lifecycle of that system." class="object"></a> <a href="SystemMaterializer.html" title="" class="class"></a><a href="SystemMaterializer.html" title="">SystemMaterializer</a></li><li class="current-entities indented4"><a href="TLSClientAuth$.html" title="" class="object"></a> <a href="TLSClientAuth.html" title="An SSLEngine can either demand, allow or ignore its peer’s authentication (via certificates), where Need will fail the handshake if the peer does not provide valid credentials, Want allows the peer to send credentials and verifies them if provided, and None disables peer certificate verification." class="class"></a><a href="TLSClientAuth.html" title="An SSLEngine can either demand, allow or ignore its peer’s authentication (via certificates), where Need will fail the handshake if the peer does not provide valid credentials, Want allows the peer to send credentials and verifies them if provided, and None disables peer certificate verification.">TLSClientAuth</a></li><li class="current-entities indented4"><a href="TLSClosing$.html" title="" class="object"></a> <a href="TLSClosing.html" title="All streams in Akka are unidirectional: while in a complex flow graph data may flow in multiple directions these individual flows are independent from each other." class="class"></a><a href="TLSClosing.html" title="All streams in Akka are unidirectional: while in a complex flow graph data may flow in multiple directions these individual flows are independent from each other.">TLSClosing</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="TLSProtocol$.html" title="" class="object"></a><a href="TLSProtocol$.html" title="">TLSProtocol</a></li><li class="current-entities indented4"><a href="TLSRole$.html" title="Many protocols are asymmetric and distinguish between the client and the server, where the latter listens passively for messages and the former actively initiates the exchange." class="object"></a> <a href="TLSRole.html" title="" class="class"></a><a href="TLSRole.html" title="">TLSRole</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="TargetRefNotInitializedYetException.html" title="" class="class"></a><a href="TargetRefNotInitializedYetException.html" title="">TargetRefNotInitializedYetException</a></li><li class="current-entities indented4"><a href="ThrottleMode$.html" title="" class="object"></a> <a href="ThrottleMode.html" title="Represents a mode that decides how to deal exceed rate for Throttle operator" class="class"></a><a href="ThrottleMode.html" title="Represents a mode that decides how to deal exceed rate for Throttle operator">ThrottleMode</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="TooManySubstreamsOpenException.html" title="This exception signals that the maximum number of substreams declared has been exceeded." class="class"></a><a href="TooManySubstreamsOpenException.html" title="This exception signals that the maximum number of substreams declared has been exceeded.">TooManySubstreamsOpenException</a></li><li class="current-entities indented4"><a href="UniformFanInShape$.html" title="" class="object"></a> <a href="UniformFanInShape.html" title="" class="class"></a><a href="UniformFanInShape.html" title="">UniformFanInShape</a></li><li class="current-entities indented4"><a href="UniformFanOutShape$.html" title="" class="object"></a> <a href="UniformFanOutShape.html" title="" class="class"></a><a href="UniformFanOutShape.html" title="">UniformFanOutShape</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="UniqueKillSwitch.html" title="A UniqueKillSwitch is always a result of a materialization (unlike SharedKillSwitch which is constructed before any materialization) and it always controls that graph and operator which yielded the materialized value." class="class"></a><a href="UniqueKillSwitch.html" title="A UniqueKillSwitch is always a result of a materialization (unlike SharedKillSwitch which is constructed before any materialization) and it always controls that graph and operator which yielded the materialized value.">UniqueKillSwitch</a></li><li class="current-entities indented4"><span class="separator"></span> <a href="WatchedActorTerminatedException.html" title="Used as failure exception by an ask operator if the target actor terminates." class="class"></a><a href="WatchedActorTerminatedException.html" title="Used as failure exception by an ask operator if the target actor terminates.">WatchedActorTerminatedException</a></li></ul></div></div><div id="content"><body class="trait type"><div id="definition"><a href="SourceRef$.html" title="See companion object"><div class="big-circle trait-companion-object">t</div></a><p id="owner"><a href="../../../index.html" name="org" id="org" class="extype">org</a>.<a href="../../index.html" name="org.apache" id="org.apache" class="extype">apache</a>.<a href="../index.html" name="org.apache.pekko" id="org.apache.pekko" class="extype">pekko</a>.<a href="index.html" name="org.apache.pekko.stream" id="org.apache.pekko.stream" class="extype">stream</a></p><h1><a href="SourceRef$.html" title="See companion object">SourceRef</a><span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="SourceRef$.html" title="See companion object">object SourceRef</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><span class="name">SourceRef</span><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>A SourceRef allows sharing a "reference" with others, with the main purpose of crossing a network boundary.
Usually obtaining a SourceRef would be done via Actor messaging, in which one system asks a remote one,
to share some data with it, and the remote one decides to do so in a back-pressured streaming fashion -- using a stream ref.</p><p>To create a <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a> you have to materialize the <code>Source</code> that you want to obtain a reference to by attaching it to a <code>Sink.sourceRef</code>.</p><p>Stream refs can be seen as Reactive Streams over network boundaries.
See also <a href="SinkRef.html" name="org.apache.pekko.stream.SinkRef" id="org.apache.pekko.stream.SinkRef" class="extype">pekko.stream.SinkRef</a> which is the dual of a <code>SourceRef</code>.</p><p>For additional configuration see <code>reference.conf</code> as well as <a href="StreamRefAttributes$.html" name="org.apache.pekko.stream.StreamRefAttributes" id="org.apache.pekko.stream.StreamRefAttributes" class="extype">pekko.stream.StreamRefAttributes</a>.</p><p>Not for user extension.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../annotation/DoNotInherit.html" name="org.apache.pekko.annotation.DoNotInherit" id="org.apache.pekko.annotation.DoNotInherit" class="extype">DoNotInherit</a></span><span class="args">()</span> </dd><dt>Source</dt><dd><a href="https://github.com/apache/incubator-pekko/tree/main//stream/src/main/scala/org/apache/pekko/stream/StreamRefs.scala#L89" target="_blank">StreamRefs.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div><div id="inheritance-diagram-container" class="toggleContainer block diagram-container"><span class="toggle diagram-link">Type Hierarchy</span><div id="inheritance-diagram" class="diagram hiddenContent"><svg id="graph1" class="class-diagram" width="800" height="600"></svg><script type="text/dot" id="dot1">
digraph G {
  
  subgraph clusterAll {
  style = "invis"
  subgraph clusterOutgoing {
  style = "invis"
  node2 [URL="scaladsl/Source.html#inheritance-diagram-container", label="Source[T, NotUsed]", id="graph1_2", class="implicit-outgoing class", tooltip="org.apache.pekko.stream.SourceRef can be implicitly converted to Source[T, NotUsed] by the implicit method convertRefToSource in object org.apache.pekko.stream.SourceRef"] ;
  
               }
  subgraph clusterThis {
  style="invis"
  node0 [URL="#inheritance-diagram-container", label="SourceRef[T]", id="graph1_0", class="this trait", tooltip="org.apache.pekko.stream.SourceRef (this trait)"] ;
}
  
  
  node0 -> node2[label="implicitly", id="0_2", minlen="2", ltail="clusterThis", lhead="clusterOutgoing", constraint="false", class="implicit-outgoing", tooltip="SourceRef[T] can be implicitly converted to Source[T, NotUsed]"]
}
  
  
  node1 [label="AnyRef", id="graph1_1", class="default", tooltip="scala.AnyRef"] ;
  node1 -> node0 [arrowtail="empty", dir="back", id="graph1_1_0", class="inheritance", tooltip="SourceRef[T] is a subtype of AnyRef"] ;
}
</script><script>$("#inheritance-diagram").bind('beforeShow', function() {
  if ($("svg#graph1").children().length == 0) {
    var dot = document.querySelector("#dot1").text;
    var svg = d3.select("#graph1");
    var inner = svg.append("g");

    // Set up zoom support
    var zoom = d3.zoom()
        .on("zoom", function() {
          inner.attr("transform", d3.event.transform);
        });
    svg.call(zoom);

    var render = new dagreD3.render();
    var g = graphlibDot.read(dot);
    render(inner, g);

    inner.selectAll("g.node").each(function(v) {
      // https://stackoverflow.com/questions/27381452/wrapping-existing-inline-svg-g-element-with-a-element
      var tgt = $("#"+ g.node(v).id +" g.label text")[0];
      var parent = tgt.parentNode;
      var a = document.createElementNS('http://www.w3.org/2000/svg', 'a');
      a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', g.node(v).URL);
      a.appendChild(tgt);
      parent.appendChild(a);
    });
  }
})</script></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="org.apache.pekko.stream.SourceRef"><span>SourceRef</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype">Implicitly<br/></span><ol id="implicits"><li class="in" name="org.apache.pekko.stream.SourceRef.convertRefToSource" data-hidden="false"><span>by convertRefToSource</span></li><li class="in" name="scala.Predef.any2stringadd" data-hidden="true"><span>by any2stringadd</span></li><li class="in" name="scala.Predef.StringFormat" data-hidden="true"><span>by StringFormat</span></li><li class="in" name="scala.Predef.Ensuring" data-hidden="true"><span>by Ensuring</span></li><li class="in" name="scala.Predef.ArrowAssoc" data-hidden="true"><span>by ArrowAssoc</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Abstract Value Members</h3><ol><li class="indented0 " name="org.apache.pekko.stream.SourceRef#source" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="source:org.apache.pekko.stream.scaladsl.Source[T,org.apache.pekko.NotUsed]" class="anchorToMember"></a><a id="source:Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#source:org.apache.pekko.stream.scaladsl.Source[T,org.apache.pekko.NotUsed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">source</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Scala API: Get <span name="Source" class="extype">Source</span> underlying to this source ref.</p></li></ol></div><div class="values members"><h3>Concrete Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean" class="anchorToMember"></a><a id="!=(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Predef.any2stringadd#+" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="+(other:String):String" class="anchorToMember"></a><a id="+(String):String" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#+(other:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $plus">+</span><span class="params">(<span name="other">other: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method any2stringadd in scala.Predef.</dd><dt>Definition Classes</dt><dd>any2stringadd</dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#++" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="++[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="++[U&gt;:Out,M](Graph[SourceShape[U],M]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#++[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $plus$plus">++</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="M">M</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.++.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.++.M" class="extype">M</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.++.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Concatenates this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> with the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> so the first element
emitted by that source is emitted after the last element of this
flow.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenates this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> with the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> so the first element
emitted by that source is emitted after the last element of this
flow.</p><p>This is a shorthand for <a href="scaladsl/Source.html#concat[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#concat" id="org.apache.pekko.stream.scaladsl.Source#concat" class="extmbr">concat</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#-&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="-&gt;[B](y:B):(A,B)" class="anchorToMember"></a><a id="-&gt;[B](B):(SourceRef[T],B)" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#-&gt;[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit" title="gt4s: $minus$greater">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="scala.Predef.ArrowAssoc.-&gt;.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean" class="anchorToMember"></a><a id="==(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#addAttributes" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="addAttributes(attr:org.apache.pekko.stream.Attributes):Source.this.Repr[Out]" class="anchorToMember"></a><a id="addAttributes(Attributes):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#addAttributes(attr:org.apache.pekko.stream.Attributes):Source.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">addAttributes</span><span class="params">(<span name="attr">attr: <a href="Attributes.html" name="org.apache.pekko.stream.Attributes" id="org.apache.pekko.stream.Attributes" class="extype">Attributes</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Add the given attributes to this Source.</p><div class="fullcomment"><div class="comment cmt"><p>Add the given attributes to this Source. If the specific attribute was already on this source
it will replace the previous value. If this Source is a composite
of multiple graphs, the added attributes will be on the composite and therefore less specific than attributes
set directly on the individual graphs of the composite.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a> → <a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#aggregateWithBoundary" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="aggregateWithBoundary[Agg,Emit](allocate:()=&gt;Agg)(aggregate:(Agg,Out)=&gt;(Agg,Boolean),harvest:Agg=&gt;Emit,emitOnTimer:Option[(Agg=&gt;Boolean,scala.concurrent.duration.FiniteDuration)]):FlowOps.this.Repr[Emit]" class="anchorToMember"></a><a id="aggregateWithBoundary[Agg,Emit](()=&gt;Agg)((Agg,T)=&gt;(Agg,Boolean),(Agg)=&gt;Emit,Option[((Agg)=&gt;Boolean,FiniteDuration)]):Source[Emit,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#aggregateWithBoundary[Agg,Emit](allocate:()=&gt;Agg)(aggregate:(Agg,Out)=&gt;(Agg,Boolean),harvest:Agg=&gt;Emit,emitOnTimer:Option[(Agg=&gt;Boolean,scala.concurrent.duration.FiniteDuration)]):FlowOps.this.Repr[Emit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">aggregateWithBoundary</span><span class="tparams">[<span name="Agg">Agg</span>, <span name="Emit">Emit</span>]</span><span class="params">(<span name="allocate">allocate: () =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.aggregateWithBoundary.Agg" class="extype">Agg</span></span>)</span><span class="params">(<span name="aggregate">aggregate: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.aggregateWithBoundary.Agg" class="extype">Agg</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; (<span name="org.apache.pekko.stream.scaladsl.FlowOps.aggregateWithBoundary.Agg" class="extype">Agg</span>, <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>)</span>, <span name="harvest">harvest: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.aggregateWithBoundary.Agg" class="extype">Agg</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.aggregateWithBoundary.Emit" class="extype">Emit</span></span>, <span name="emitOnTimer">emitOnTimer: <a href="https://www.scala-lang.org/api/2.13.8/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[((<span name="org.apache.pekko.stream.scaladsl.FlowOps.aggregateWithBoundary.Agg" class="extype">Agg</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>, <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a>)]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.aggregateWithBoundary.Emit" class="extype">Emit</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Aggregate input elements into an arbitrary data structure that can be completed and emitted downstream
when custom condition is met which can be triggered by aggregate or timer.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregate input elements into an arbitrary data structure that can be completed and emitted downstream
when custom condition is met which can be triggered by aggregate or timer.
It can be thought of a more general <a href="scaladsl/Source.html#groupedWeightedWithin(maxWeight:Long,maxNumber:Int,d:scala.concurrent.duration.FiniteDuration)(costFn:Out=&gt;Long):FlowOps.this.Repr[Seq[Out]]" name="org.apache.pekko.stream.scaladsl.Source#groupedWeightedWithin" id="org.apache.pekko.stream.scaladsl.Source#groupedWeightedWithin" class="extmbr">groupedWeightedWithin</a>.</p><p><b>Emits when</b> the aggregation function decides the aggregate is complete or the timer function returns true</p><p><b>Backpressures when</b> downstream backpressures and the aggregate is complete</p><p><b>Completes when</b> upstream completes and the last aggregate has been emitted downstream</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">allocate</dt><dd class="cmt"><p>allocate the initial data structure for aggregated elements</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>update the aggregated elements, return true if ready to emit after update.</p></dd><dt class="param">harvest</dt><dd class="cmt"><p>this is invoked before emit within the current stage/operator</p></dd><dt class="param">emitOnTimer</dt><dd class="cmt"><p>decide whether the current aggregated elements can be emitted, the custom function is invoked on every interval</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>Annotations</dt><dd><span class="name">@<a href="../annotation/ApiMayChange.html" name="org.apache.pekko.annotation.ApiMayChange" id="org.apache.pekko.annotation.ApiMayChange" class="extype">ApiMayChange</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#alsoTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="alsoTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="alsoTo(Graph[SinkShape[T],_]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#alsoTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">alsoTo</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], _]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>, meaning that elements that pass
through will also be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>, meaning that elements that pass
through will also be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>.</p><p>It is similar to <a href="scaladsl/Source.html#wireTap(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#wireTap" id="org.apache.pekko.stream.scaladsl.Source#wireTap" class="extmbr">#wireTap</a> but will backpressure instead of dropping elements when the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> is not ready.</p><p><b>Emits when</b> element is available and demand exists both from the Sink and the downstream.</p><p><b>Backpressures when</b> downstream or Sink backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream or Sink cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#alsoToAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="alsoToAll(those:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]*):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="alsoToAll(Graph[SinkShape[T],_]*):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#alsoToAll(those:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]*):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">alsoToAll</span><span class="params">(<span name="those">those: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], _]*</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>s to this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>, meaning that elements that pass
through will also be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>s to this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>, meaning that elements that pass
through will also be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>.</p><p>It is similar to <a href="scaladsl/Source.html#wireTap(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#wireTap" id="org.apache.pekko.stream.scaladsl.Source#wireTap" class="extmbr">#wireTap</a> but will backpressure instead of dropping elements when the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>s is not ready.</p><p><b>Emits when</b> element is available and demand exists both from the Sinks and the downstream.</p><p><b>Backpressures when</b> downstream or any of the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>s backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream or any of the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>s cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#alsoToMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="alsoToMat[Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out,Mat3]" class="anchorToMember"></a><a id="alsoToMat[Mat2,Mat3](Graph[SinkShape[T],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[T,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#alsoToMat[Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">alsoToMat</span><span class="tparams">[<span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.alsoToMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.alsoToMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.alsoToMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.alsoToMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that elements that pass
through will also be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that elements that pass
through will also be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#alsoTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#alsoTo" id="org.apache.pekko.stream.scaladsl.Source#alsoTo" class="extmbr">#alsoTo</a>
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#asJava" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asJava:org.apache.pekko.stream.javadsl.Source[Out@scala.annotation.unchecked.uncheckedVariance,Mat@scala.annotation.unchecked.uncheckedVariance]" class="anchorToMember"></a><a id="asJava:Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#asJava:org.apache.pekko.stream.javadsl.Source[Out@scala.annotation.unchecked.uncheckedVariance,Mat@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">asJava</span><span class="result">: <a href="javadsl/Source.html" name="org.apache.pekko.stream.javadsl.Source" id="org.apache.pekko.stream.javadsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Converts this Scala DSL element to it's Java DSL counterpart.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this Scala DSL element to it's Java DSL counterpart.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#asSourceWithContext" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asSourceWithContext[Ctx](f:Out=&gt;Ctx):org.apache.pekko.stream.scaladsl.SourceWithContext[Out,Ctx,Mat]" class="anchorToMember"></a><a id="asSourceWithContext[Ctx]((T)=&gt;Ctx):SourceWithContext[T,Ctx,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#asSourceWithContext[Ctx](f:Out=&gt;Ctx):org.apache.pekko.stream.scaladsl.SourceWithContext[Out,Ctx,Mat]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">asSourceWithContext</span><span class="tparams">[<span name="Ctx">Ctx</span>]</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.Source.asSourceWithContext.Ctx" class="extype">Ctx</span></span>)</span><span class="result">: <a href="scaladsl/SourceWithContext.html" name="org.apache.pekko.stream.scaladsl.SourceWithContext" id="org.apache.pekko.stream.scaladsl.SourceWithContext" class="extype">SourceWithContext</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.Source.asSourceWithContext.Ctx" class="extype">Ctx</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform this source whose element is <code><code>e</code></code> into a source producing tuple <code><code>(e, f(e))</code></code>
</p><div class="fullcomment"><div class="comment cmt"><p>Transform this source whose element is <code><code>e</code></code> into a source producing tuple <code><code>(e, f(e))</code></code>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#ask" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ask[S](parallelism:Int)(ref:org.apache.pekko.actor.ActorRef)(implicittimeout:org.apache.pekko.util.Timeout,implicittag:scala.reflect.ClassTag[S]):FlowOps.this.Repr[S]" class="anchorToMember"></a><a id="ask[S](Int)(ActorRef)(Timeout,ClassTag[S]):Source[S,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#ask[S](parallelism:Int)(ref:org.apache.pekko.actor.ActorRef)(implicittimeout:org.apache.pekko.util.Timeout,implicittag:scala.reflect.ClassTag[S]):FlowOps.this.Repr[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ask</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="ref">ref: <a href="../actor/ActorRef.html" name="org.apache.pekko.actor.ActorRef" id="org.apache.pekko.actor.ActorRef" class="extype">ActorRef</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="timeout">timeout: <a href="../util/Timeout.html" name="org.apache.pekko.util.Timeout" id="org.apache.pekko.util.Timeout" class="extype">Timeout</a></span>, <span name="tag">tag: <a href="https://www.scala-lang.org/api/2.13.8/scala/reflect/ClassTag.html#scala.reflect.ClassTag" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype">ClassTag</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.ask.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.ask.S" class="extype">S</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.</p><div class="fullcomment"><div class="comment cmt"><p>Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.
If any of the asks times out it will fail the stream with a <a href="../pattern/AskTimeoutException.html" name="org.apache.pekko.pattern.AskTimeoutException" id="org.apache.pekko.pattern.AskTimeoutException" class="extype">pekko.pattern.AskTimeoutException</a>.</p><p>Do not forget to include the expected response type in the method call, like so:</p><pre>flow.ask[ExpectedReply](parallelism = <span class="num">4</span>)(ref)</pre><p>otherwise <code>Nothing</code> will be assumed, which is most likely not what you want.</p><p>Parallelism limits the number of how many asks can be "in flight" at the same time.
Please note that the elements emitted by this operator are in-order with regards to the asks being issued
(i.e. same behaviour as mapAsync).</p><p>The operator fails with an <a href="WatchedActorTerminatedException.html" name="org.apache.pekko.stream.WatchedActorTerminatedException" id="org.apache.pekko.stream.WatchedActorTerminatedException" class="extype">pekko.stream.WatchedActorTerminatedException</a> if the target actor is terminated,
or with an <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeoutException.html" name="java.util.concurrent.TimeoutException" id="java.util.concurrent.TimeoutException" class="extype">java.util.concurrent.TimeoutException</a> in case the ask exceeds the timeout passed in.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the futures (in submission order) created by the ask pattern internally are completed</p><p><b>Backpressures when</b> the number of futures reaches the configured parallelism and the downstream backpressures</p><p><b>Completes when</b> upstream completes and all futures have been completed and all elements have been emitted</p><p><b>Fails when</b> the passed in actor terminates, or a timeout is exceeded in any of the asks performed</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>Annotations</dt><dd><span class="name">@implicitNotFound</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#ask" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ask[S](ref:org.apache.pekko.actor.ActorRef)(implicittimeout:org.apache.pekko.util.Timeout,implicittag:scala.reflect.ClassTag[S]):FlowOps.this.Repr[S]" class="anchorToMember"></a><a id="ask[S](ActorRef)(Timeout,ClassTag[S]):Source[S,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#ask[S](ref:org.apache.pekko.actor.ActorRef)(implicittimeout:org.apache.pekko.util.Timeout,implicittag:scala.reflect.ClassTag[S]):FlowOps.this.Repr[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ask</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="ref">ref: <a href="../actor/ActorRef.html" name="org.apache.pekko.actor.ActorRef" id="org.apache.pekko.actor.ActorRef" class="extype">ActorRef</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="timeout">timeout: <a href="../util/Timeout.html" name="org.apache.pekko.util.Timeout" id="org.apache.pekko.util.Timeout" class="extype">Timeout</a></span>, <span name="tag">tag: <a href="https://www.scala-lang.org/api/2.13.8/scala/reflect/ClassTag.html#scala.reflect.ClassTag" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype">ClassTag</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.ask.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.ask.S" class="extype">S</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.</p><div class="fullcomment"><div class="comment cmt"><p>Use the <code>ask</code> pattern to send a request-reply message to the target <code>ref</code> actor.
If any of the asks times out it will fail the stream with a <a href="../pattern/AskTimeoutException.html" name="org.apache.pekko.pattern.AskTimeoutException" id="org.apache.pekko.pattern.AskTimeoutException" class="extype">pekko.pattern.AskTimeoutException</a>.</p><p>Do not forget to include the expected response type in the method call, like so:</p><pre>flow.ask[ExpectedReply](ref)</pre><p>otherwise <code>Nothing</code> will be assumed, which is most likely not what you want.</p><p>Defaults to parallelism of 2 messages in flight, since while one ask message may be being worked on, the second one
still be in the mailbox, so defaulting to sending the second one a bit earlier than when first ask has replied maintains
a slightly healthier throughput.</p><p>Similar to the plain ask pattern, the target actor is allowed to reply with <code>org.apache.pekko.util.Status</code>.
An <code>org.apache.pekko.util.Status#Failure</code> will cause the operator to fail with the cause carried in the <code>Failure</code> message.</p><p>The operator fails with an <a href="WatchedActorTerminatedException.html" name="org.apache.pekko.stream.WatchedActorTerminatedException" id="org.apache.pekko.stream.WatchedActorTerminatedException" class="extype">pekko.stream.WatchedActorTerminatedException</a> if the target actor is terminated.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the futures (in submission order) created by the ask pattern internally are completed</p><p><b>Backpressures when</b> the number of futures reaches the configured parallelism and the downstream backpressures</p><p><b>Completes when</b> upstream completes and all futures have been completed and all elements have been emitted</p><p><b>Fails when</b> the passed in actor terminates, or a timeout is exceeded in any of the asks performed</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>Annotations</dt><dd><span class="name">@implicitNotFound</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#async" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="async(dispatcher:String,inputBufferSize:Int):Source.this.Repr[Out]" class="anchorToMember"></a><a id="async(String,Int):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#async(dispatcher:String,inputBufferSize:Int):Source.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">async</span><span class="params">(<span name="dispatcher">dispatcher: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span>, <span name="inputBufferSize">inputBufferSize: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Put an asynchronous boundary around this <code>Graph</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Put an asynchronous boundary around this <code>Graph</code>
</p></div><dl class="paramcmts block"><dt class="param">dispatcher</dt><dd class="cmt"><p>Run the graph on this dispatcher</p></dd><dt class="param">inputBufferSize</dt><dd class="cmt"><p>Set the input buffer to this size for the graph</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#async" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="async(dispatcher:String):Source.this.Repr[Out]" class="anchorToMember"></a><a id="async(String):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#async(dispatcher:String):Source.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">async</span><span class="params">(<span name="dispatcher">dispatcher: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Put an asynchronous boundary around this <code>Graph</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Put an asynchronous boundary around this <code>Graph</code>
</p></div><dl class="paramcmts block"><dt class="param">dispatcher</dt><dd class="cmt"><p>Run the graph on this dispatcher</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#async" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="async:Source.this.Repr[Out]" class="anchorToMember"></a><a id="async:Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#async:Source.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">async</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Put an asynchronous boundary around this <code>Source</code>
</p><div class="fullcomment"><div class="comment cmt"><p>Put an asynchronous boundary around this <code>Source</code>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a> → <a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#backpressureTimeout" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="backpressureTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="backpressureTimeout(FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#backpressureTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">backpressureTimeout</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
the stream is failed with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>.</p><div class="fullcomment"><div class="comment cmt"><p>If the time between the emission of an element and the following downstream demand exceeds the provided timeout,
the stream is failed with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>. The timeout is checked periodically,
so the resolution of the check is one period (equals to timeout value).</p><p><b>Emits when</b> upstream emits an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or fails if timeout elapses between element emission and downstream demand.</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#batch" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="batch[S](max:Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" class="anchorToMember"></a><a id="batch[S](Long,(T)=&gt;S)((S,T)=&gt;S):Source[S,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#batch[S](max:Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">batch</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="max">max: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="seed">seed: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.batch.S" class="extype">S</span></span>)</span><span class="params">(<span name="aggregate">aggregate: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.batch.S" class="extype">S</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.batch.S" class="extype">S</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.batch.S" class="extype">S</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
until the subscriber is ready to accept them.</p><div class="fullcomment"><div class="comment cmt"><p>Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
until the subscriber is ready to accept them. For example a batch step might store received elements in
an array up to the allowed max limit if the upstream publisher is faster.</p><p>This only rolls up elements if the upstream is faster, but if the downstream is faster it will not
duplicate elements.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> downstream stops backpressuring and there is an aggregated element available</p><p><b>Backpressures when</b> there are <code>max</code> batched elements and 1 pending element and downstream backpressures</p><p><b>Completes when</b> upstream completes and there is no batched/pending element waiting</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#conflateWithSeed[S](seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#conflateWithSeed" id="org.apache.pekko.stream.scaladsl.FlowOps#conflateWithSeed" class="extmbr">FlowOps.conflateWithSeed</a>, <a href="scaladsl/FlowOps.html#batchWeighted[S](max:Long,costFn:Out=&gt;Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#batchWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#batchWeighted" class="extmbr">FlowOps.batchWeighted</a>
</p></div><dl class="paramcmts block"><dt class="param">max</dt><dd class="cmt"><p>maximum number of elements to batch before backpressuring upstream (must be positive non-zero)</p></dd><dt class="param">seed</dt><dd class="cmt"><p>Provides the first state for a batched value using the first unconsumed element as a start</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>Takes the currently batched value and the current pending element to produce a new aggregate</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#batchWeighted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="batchWeighted[S](max:Long,costFn:Out=&gt;Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" class="anchorToMember"></a><a id="batchWeighted[S](Long,(T)=&gt;Long,(T)=&gt;S)((S,T)=&gt;S):Source[S,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#batchWeighted[S](max:Long,costFn:Out=&gt;Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">batchWeighted</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="max">max: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="costFn">costFn: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="seed">seed: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.batchWeighted.S" class="extype">S</span></span>)</span><span class="params">(<span name="aggregate">aggregate: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.batchWeighted.S" class="extype">S</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.batchWeighted.S" class="extype">S</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.batchWeighted.S" class="extype">S</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
until the subscriber is ready to accept them.</p><div class="fullcomment"><div class="comment cmt"><p>Allows a faster upstream to progress independently of a slower subscriber by aggregating elements into batches
until the subscriber is ready to accept them. For example a batch step might concatenate <code>ByteString</code>
elements up to the allowed max limit if the upstream publisher is faster.</p><p>This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
duplicate elements.</p><p>Batching will apply for all elements, even if a single element cost is greater than the total allowed limit.
In this case, previous batched elements will be emitted, then the "heavy" element will be emitted (after
being applied with the <code>seed</code> function) without batching further elements with it, and then the rest of the
incoming elements are batched.</p><p><b>Emits when</b> downstream stops backpressuring and there is a batched element available</p><p><b>Backpressures when</b> there are <code>max</code> weighted batched elements + 1 pending element and downstream backpressures</p><p><b>Completes when</b> upstream completes and there is no batched/pending element waiting</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#conflateWithSeed[S](seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#conflateWithSeed" id="org.apache.pekko.stream.scaladsl.FlowOps#conflateWithSeed" class="extmbr">FlowOps.conflateWithSeed</a>, <a href="scaladsl/FlowOps.html#batch[S](max:Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#batch" id="org.apache.pekko.stream.scaladsl.FlowOps#batch" class="extmbr">FlowOps.batch</a>
</p></div><dl class="paramcmts block"><dt class="param">max</dt><dd class="cmt"><p>maximum weight of elements to batch before backpressuring upstream (must be positive non-zero)</p></dd><dt class="param">costFn</dt><dd class="cmt"><p>a function to compute a single element weight</p></dd><dt class="param">seed</dt><dd class="cmt"><p>Provides the first state for a batched value using the first unconsumed element as a start</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>Takes the currently batched value and the current pending element to produce a new batch</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#buffer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="buffer(size:Int,overflowStrategy:org.apache.pekko.stream.OverflowStrategy):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="buffer(Int,OverflowStrategy):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#buffer(size:Int,overflowStrategy:org.apache.pekko.stream.OverflowStrategy):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">buffer</span><span class="params">(<span name="size">size: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="overflowStrategy">overflowStrategy: <a href="OverflowStrategy.html" name="org.apache.pekko.stream.OverflowStrategy" id="org.apache.pekko.stream.OverflowStrategy" class="extype">OverflowStrategy</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.</p><div class="fullcomment"><div class="comment cmt"><p>Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
Depending on the defined <a href="OverflowStrategy.html" name="org.apache.pekko.stream.OverflowStrategy" id="org.apache.pekko.stream.OverflowStrategy" class="extype">pekko.stream.OverflowStrategy</a> it might drop elements or backpressure the upstream if
there is no space available</p><p><b>Emits when</b> downstream stops backpressuring and there is a pending element in the buffer</p><p><b>Backpressures when</b> downstream backpressures or depending on OverflowStrategy:</p><ul><li>Backpressure - backpressures when buffer is full</li><li>DropHead, DropTail, DropBuffer - never backpressures</li><li>Fail - fails the stream if buffer gets full</li></ul><p><b>Completes when</b> upstream completes and buffered elements have been drained</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">size</dt><dd class="cmt"><p>The size of the buffer in element count</p></dd><dt class="param">overflowStrategy</dt><dd class="cmt"><p>Strategy that is used when incoming elements cannot fit inside the buffer</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object" class="anchorToMember"></a><a id="clone():AnyRef" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#collect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="collect[T](pf:PartialFunction[Out,T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="collect[T](PartialFunction[T,T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#collect[T](pf:PartialFunction[Out,T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">collect</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.8/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.collect.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.collect.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform this stream by applying the given partial function to each of the elements
on which the function is defined as they pass through this processing step.</p><div class="fullcomment"><div class="comment cmt"><p>Transform this stream by applying the given partial function to each of the elements
on which the function is defined as they pass through this processing step.
Non-matching elements are filtered out.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the provided partial function is defined for the element</p><p><b>Backpressures when</b> the partial function is defined for the element and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#collectType" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="collectType[T](implicittag:scala.reflect.ClassTag[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="collectType[T](ClassTag[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#collectType[T](implicittag:scala.reflect.ClassTag[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">collectType</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="tag">tag: <a href="https://www.scala-lang.org/api/2.13.8/scala/reflect/ClassTag.html#scala.reflect.ClassTag" name="scala.reflect.ClassTag" id="scala.reflect.ClassTag" class="extype">ClassTag</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.collectType.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.collectType.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform this stream by testing the type of each of the elements
on which the element is an instance of the provided type as they pass through this processing step.</p><div class="fullcomment"><div class="comment cmt"><p>Transform this stream by testing the type of each of the elements
on which the element is an instance of the provided type as they pass through this processing step.</p><p>Non-matching elements are filtered out.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the element is an instance of the provided type</p><p><b>Backpressures when</b> the element is an instance of the provided type and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#completionTimeout" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="completionTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="completionTimeout(FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#completionTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">completionTimeout</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">If the completion of the stream does not happen until the provided timeout, the stream is failed
with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>.</p><div class="fullcomment"><div class="comment cmt"><p>If the completion of the stream does not happen until the provided timeout, the stream is failed
with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>.</p><p><b>Emits when</b> upstream emits an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or fails if timeout elapses before upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#concat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concat[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="concat[U&gt;:Out,Mat2](Graph[SourceShape[U],Mat2]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#concat[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">concat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.concat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.concat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.concat.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is materialized together with this Flow and is "detached" meaning it will
in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
(so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).</p><p>The second source is then kept from producing elements by asserting back-pressure until its time comes.</p><p>When needing a concat operator that is not detached use <a href="scaladsl/Source.html#concatLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#concatLazy" id="org.apache.pekko.stream.scaladsl.Source#concatLazy" class="extmbr">#concatLazy</a></p><p>If this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> gets upstream error - no elements from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> will be pulled.</p><p><b>Emits when</b> element is available from current stream or from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> when current is completed</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#concatAllLazy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatAllLazy[U&gt;:Out](those:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]*):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="concatAllLazy[U&gt;:Out](Graph[SourceShape[U],_]*):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#concatAllLazy[U&gt;:Out](those:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]*):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">concatAllLazy</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="those">those: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.concatAllLazy.U" class="extype">U</span>], _]*</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.concatAllLazy.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s' elements will be produced.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s' elements will be produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s are materialized together with this Flow. If <code>lazy</code> materialization is what is needed
the operator can be combined with for example <code>Source.lazySource</code> to defer materialization of <code>that</code> until the
time when this source completes.</p><p>The second source is then kept from producing elements by asserting back-pressure until its time comes.</p><p>For a concat operator that is detached, use <a href="scaladsl/Source.html#concat[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#concat" id="org.apache.pekko.stream.scaladsl.Source#concat" class="extmbr">#concat</a></p><p>If this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> gets upstream error - no elements from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s will be pulled.</p><p><b>Emits when</b> element is available from current stream or from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s when current is completed</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> given all those <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#concatLazy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="concatLazy[U&gt;:Out,Mat2](Graph[SourceShape[U],Mat2]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#concatLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">concatLazy</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.concatLazy.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.concatLazy.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.concatLazy.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is materialized together with this Flow. If <code>lazy</code> materialization is what is needed
the operator can be combined with for example <code>Source.lazySource</code> to defer materialization of <code>that</code> until the
time when this source completes.</p><p>The second source is then kept from producing elements by asserting back-pressure until its time comes.</p><p>For a concat operator that is detached, use <a href="scaladsl/Source.html#concat[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#concat" id="org.apache.pekko.stream.scaladsl.Source#concat" class="extmbr">#concat</a></p><p>If this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> gets upstream error - no elements from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> will be pulled.</p><p><b>Emits when</b> element is available from current stream or from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> when current is completed</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#concatLazyMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatLazyMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="concatLazyMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#concatLazyMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">concatLazyMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatLazyMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatLazyMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatLazyMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatLazyMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatLazyMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatLazyMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is materialized together with this Flow, if <code>lazy</code> materialization is what is needed
the operator can be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>.</p><p>The second source is then kept from producing elements by asserting back-pressure until its time comes.</p><p>For a concat operator that is detached, use <a href="scaladsl/Source.html#concatMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" name="org.apache.pekko.stream.scaladsl.Source#concatMat" id="org.apache.pekko.stream.scaladsl.Source#concatMat" class="extmbr">#concatMat</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#concatLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#concatLazy" id="org.apache.pekko.stream.scaladsl.Source#concatLazy" class="extmbr">#concatLazy</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#concatMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="concatMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#concatMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">concatMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.concatMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenate the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that once this
Flow’s input is exhausted and all result elements have been generated,
the Source’s elements will be produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is materialized together with this Flow and is "detached" meaning it will
in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
(so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).</p><p>The second source is then kept from producing elements by asserting back-pressure until its time comes.</p><p>When needing a concat operator that is not detached use <a href="scaladsl/Source.html#concatLazyMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" name="org.apache.pekko.stream.scaladsl.Source#concatLazyMat" id="org.apache.pekko.stream.scaladsl.Source#concatLazyMat" class="extmbr">#concatLazyMat</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#concat[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#concat" id="org.apache.pekko.stream.scaladsl.Source#concat" class="extmbr">#concat</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#conflate" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="conflate[O2&gt;:Out](aggregate:(O2,O2)=&gt;O2):FlowOps.this.Repr[O2]" class="anchorToMember"></a><a id="conflate[O2&gt;:Out]((O2,O2)=&gt;O2):Source[O2,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#conflate[O2&gt;:Out](aggregate:(O2,O2)=&gt;O2):FlowOps.this.Repr[O2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">conflate</span><span class="tparams">[<span name="O2">O2 &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="aggregate">aggregate: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.conflate.O2" class="extype">O2</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.conflate.O2" class="extype">O2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.conflate.O2" class="extype">O2</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.conflate.O2" class="extype">O2</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
until the subscriber is ready to accept them.</p><div class="fullcomment"><div class="comment cmt"><p>Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
upstream publisher is faster.</p><p>This version of conflate does not change the output type of the stream. See <a href="scaladsl/FlowOps.html#conflateWithSeed[S](seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#conflateWithSeed" id="org.apache.pekko.stream.scaladsl.FlowOps#conflateWithSeed" class="extmbr">FlowOps.conflateWithSeed</a> for a
more flexible version that can take a seed function and transform elements while rolling up.</p><p>This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
duplicate elements.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> downstream stops backpressuring and there is a conflated element available</p><p><b>Backpressures when</b> never</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">aggregate</dt><dd class="cmt"><p>Takes the currently aggregated value and the current pending element to produce a new aggregate
See also <a href="scaladsl/FlowOps.html#conflate[O2&gt;:Out](aggregate:(O2,O2)=&gt;O2):FlowOps.this.Repr[O2]" name="org.apache.pekko.stream.scaladsl.FlowOps#conflate" id="org.apache.pekko.stream.scaladsl.FlowOps#conflate" class="extmbr">FlowOps.conflate</a>, <a href="scaladsl/FlowOps.html#limit(max:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limit" id="org.apache.pekko.stream.scaladsl.FlowOps#limit" class="extmbr">FlowOps.limit</a>, <a href="scaladsl/FlowOps.html#limitWeighted[T](max:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" class="extmbr">FlowOps.limitWeighted</a> <a href="scaladsl/FlowOps.html#batch[S](max:Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#batch" id="org.apache.pekko.stream.scaladsl.FlowOps#batch" class="extmbr">FlowOps.batch</a> <a href="scaladsl/FlowOps.html#batchWeighted[S](max:Long,costFn:Out=&gt;Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#batchWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#batchWeighted" class="extmbr">FlowOps.batchWeighted</a></p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#conflateWithSeed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="conflateWithSeed[S](seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" class="anchorToMember"></a><a id="conflateWithSeed[S]((T)=&gt;S)((S,T)=&gt;S):Source[S,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#conflateWithSeed[S](seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">conflateWithSeed</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.conflateWithSeed.S" class="extype">S</span></span>)</span><span class="params">(<span name="aggregate">aggregate: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.conflateWithSeed.S" class="extype">S</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.conflateWithSeed.S" class="extype">S</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.conflateWithSeed.S" class="extype">S</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
until the subscriber is ready to accept them.</p><div class="fullcomment"><div class="comment cmt"><p>Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
upstream publisher is faster.</p><p>This version of conflate allows to derive a seed from the first element and change the aggregated type to be
different than the input type. See <a href="scaladsl/FlowOps.html#conflate[O2&gt;:Out](aggregate:(O2,O2)=&gt;O2):FlowOps.this.Repr[O2]" name="org.apache.pekko.stream.scaladsl.FlowOps#conflate" id="org.apache.pekko.stream.scaladsl.FlowOps#conflate" class="extmbr">FlowOps.conflate</a> for a simpler version that does not change types.</p><p>This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
duplicate elements.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> downstream stops backpressuring and there is a conflated element available</p><p><b>Backpressures when</b> never</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>Provides the first state for a conflated value using the first unconsumed element as a start</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>Takes the currently aggregated value and the current pending element to produce a new aggregate
See also <a href="scaladsl/FlowOps.html#conflate[O2&gt;:Out](aggregate:(O2,O2)=&gt;O2):FlowOps.this.Repr[O2]" name="org.apache.pekko.stream.scaladsl.FlowOps#conflate" id="org.apache.pekko.stream.scaladsl.FlowOps#conflate" class="extmbr">FlowOps.conflate</a>, <a href="scaladsl/FlowOps.html#limit(max:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limit" id="org.apache.pekko.stream.scaladsl.FlowOps#limit" class="extmbr">FlowOps.limit</a>, <a href="scaladsl/FlowOps.html#limitWeighted[T](max:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" class="extmbr">FlowOps.limitWeighted</a> <a href="scaladsl/FlowOps.html#batch[S](max:Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#batch" id="org.apache.pekko.stream.scaladsl.FlowOps#batch" class="extmbr">FlowOps.batch</a> <a href="scaladsl/FlowOps.html#batchWeighted[S](max:Long,costFn:Out=&gt;Long,seed:Out=&gt;S)(aggregate:(S,Out)=&gt;S):FlowOps.this.Repr[S]" name="org.apache.pekko.stream.scaladsl.FlowOps#batchWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#batchWeighted" class="extmbr">FlowOps.batchWeighted</a></p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#delay" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delay(of:scala.concurrent.duration.FiniteDuration,strategy:org.apache.pekko.stream.DelayOverflowStrategy):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="delay(FiniteDuration,DelayOverflowStrategy):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#delay(of:scala.concurrent.duration.FiniteDuration,strategy:org.apache.pekko.stream.DelayOverflowStrategy):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">delay</span><span class="params">(<span name="of">of: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="strategy">strategy: <a href="DelayOverflowStrategy.html" name="org.apache.pekko.stream.DelayOverflowStrategy" id="org.apache.pekko.stream.DelayOverflowStrategy" class="extype">DelayOverflowStrategy</a> = <span class="symbol"><span class="name"><a href="../../../index.html">DelayOverflowStrategy.dropTail</a></span></span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Shifts elements emission in time by a specified amount.</p><div class="fullcomment"><div class="comment cmt"><p>Shifts elements emission in time by a specified amount. It allows to store elements
in internal buffer while waiting for next element to be emitted. Depending on the defined
<a href="DelayOverflowStrategy.html" name="org.apache.pekko.stream.DelayOverflowStrategy" id="org.apache.pekko.stream.DelayOverflowStrategy" class="extype">pekko.stream.DelayOverflowStrategy</a> it might drop elements or backpressure the upstream if
there is no space available in the buffer.</p><p>Delay precision is 10ms to avoid unnecessary timer scheduling cycles</p><p>Internal buffer has default capacity 16. You can set buffer size by calling <code>addAttributes(inputBuffer)</code></p><p><b>Emits when</b> there is a pending element in the buffer and configured time for this element elapsed
 * EmitEarly - strategy do not wait to emit element if buffer is full</p><p><b>Backpressures when</b> depending on OverflowStrategy
 * Backpressure - backpressures when buffer is full
 * DropHead, DropTail, DropBuffer - never backpressures
 * Fail - fails the stream if buffer gets full</p><p><b>Completes when</b> upstream completes and buffered elements have been drained</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">of</dt><dd class="cmt"><p>time to shift all messages</p></dd><dt class="param">strategy</dt><dd class="cmt"><p>Strategy that is used when incoming elements cannot fit inside the buffer</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#delayWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayWith(delayStrategySupplier:()=&gt;org.apache.pekko.stream.scaladsl.DelayStrategy[Out],overFlowStrategy:org.apache.pekko.stream.DelayOverflowStrategy):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="delayWith(()=&gt;DelayStrategy[T],DelayOverflowStrategy):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#delayWith(delayStrategySupplier:()=&gt;org.apache.pekko.stream.scaladsl.DelayStrategy[Out],overFlowStrategy:org.apache.pekko.stream.DelayOverflowStrategy):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">delayWith</span><span class="params">(<span name="delayStrategySupplier">delayStrategySupplier: () =&gt; <a href="scaladsl/DelayStrategy.html" name="org.apache.pekko.stream.scaladsl.DelayStrategy" id="org.apache.pekko.stream.scaladsl.DelayStrategy" class="extype">DelayStrategy</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]</span>, <span name="overFlowStrategy">overFlowStrategy: <a href="DelayOverflowStrategy.html" name="org.apache.pekko.stream.DelayOverflowStrategy" id="org.apache.pekko.stream.DelayOverflowStrategy" class="extype">DelayOverflowStrategy</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Shifts elements emission in time by an amount individually determined through delay strategy a specified amount.</p><div class="fullcomment"><div class="comment cmt"><p>Shifts elements emission in time by an amount individually determined through delay strategy a specified amount.
It allows to store elements in internal buffer while waiting for next element to be emitted. Depending on the defined
<a href="DelayOverflowStrategy.html" name="org.apache.pekko.stream.DelayOverflowStrategy" id="org.apache.pekko.stream.DelayOverflowStrategy" class="extype">pekko.stream.DelayOverflowStrategy</a> it might drop elements or backpressure the upstream if
there is no space available in the buffer.</p><p>It determines delay for each ongoing element invoking <code>DelayStrategy.nextDelay(elem: T): FiniteDuration</code>.</p><p>Note that elements are not re-ordered: if an element is given a delay much shorter than its predecessor,
it will still have to wait for the preceding element before being emitted.
It is also important to notice that <a href="scaladsl/DelayStrategy.html" name="org.apache.pekko.stream.scaladsl.DelayStrategy" id="org.apache.pekko.stream.scaladsl.DelayStrategy" class="extype">scaladsl.DelayStrategy</a> can be stateful.</p><p>Delay precision is 10ms to avoid unnecessary timer scheduling cycles.</p><p>Internal buffer has default capacity 16. You can set buffer size by calling <code>addAttributes(inputBuffer)</code></p><p><b>Emits when</b> there is a pending element in the buffer and configured time for this element elapsed
 * EmitEarly - strategy do not wait to emit element if buffer is full</p><p><b>Backpressures when</b> depending on OverflowStrategy
 * Backpressure - backpressures when buffer is full
 * DropHead, DropTail, DropBuffer - never backpressures
 * Fail - fails the stream if buffer gets full</p><p><b>Completes when</b> upstream completes and buffered elements have been drained</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">delayStrategySupplier</dt><dd class="cmt"><p>creates new <a href="scaladsl/DelayStrategy.html" name="org.apache.pekko.stream.scaladsl.DelayStrategy" id="org.apache.pekko.stream.scaladsl.DelayStrategy" class="extype">DelayStrategy</a> object for each materialization</p></dd><dt class="param">overFlowStrategy</dt><dd class="cmt"><p>Strategy that is used when incoming elements cannot fit inside the buffer</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#detach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="detach:FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="detach:Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#detach:FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">detach</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Detaches upstream demand from downstream demand without detaching the
stream rates; in other words acts like a buffer of size 1.</p><div class="fullcomment"><div class="comment cmt"><p>Detaches upstream demand from downstream demand without detaching the
stream rates; in other words acts like a buffer of size 1.</p><p><b>Emits when</b> upstream emits an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#divertTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="divertTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_],when:Out=&gt;Boolean):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="divertTo(Graph[SinkShape[T],_],(T)=&gt;Boolean):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#divertTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_],when:Out=&gt;Boolean):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">divertTo</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], _]</span>, <span name="when">when: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that elements will be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>
instead of being passed through if the predicate <code>when</code> returns <code>true</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that elements will be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>
instead of being passed through if the predicate <code>when</code> returns <code>true</code>.</p><p><b>Emits when</b> emits when an element is available from the input and the chosen output has demand</p><p><b>Backpressures when</b> the currently chosen output back-pressures</p><p><b>Completes when</b> upstream completes and no output is pending</p><p><b>Cancels when</b> any of the downstreams cancel
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#divertToMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="divertToMat[Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2],when:Out=&gt;Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out,Mat3]" class="anchorToMember"></a><a id="divertToMat[Mat2,Mat3](Graph[SinkShape[T],Mat2],(T)=&gt;Boolean)((NotUsed,Mat2)=&gt;Mat3):Source[T,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#divertToMat[Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2],when:Out=&gt;Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">divertToMat</span><span class="tparams">[<span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.divertToMat.Mat2" class="extype">Mat2</span>]</span>, <span name="when">when: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.divertToMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.divertToMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.divertToMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that elements will be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>
instead of being passed through if the predicate <code>when</code> returns <code>true</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that elements will be sent to the <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>
instead of being passed through if the predicate <code>when</code> returns <code>true</code>.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#divertTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_],when:Out=&gt;Boolean):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#divertTo" id="org.apache.pekko.stream.scaladsl.Source#divertTo" class="extmbr">#divertTo</a>
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#drop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="drop(n:Long):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="drop(Long):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#drop(n:Long):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">drop</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Discard the given number of elements at the beginning of the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Discard the given number of elements at the beginning of the stream.
No elements will be dropped if <code>n</code> is zero or negative.</p><p><b>Emits when</b> the specified number of elements has been dropped already</p><p><b>Backpressures when</b> the specified number of elements has been dropped and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#dropWhile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropWhile(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="dropWhile((T)=&gt;Boolean):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#dropWhile(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">dropWhile</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Discard elements at the beginning of the stream while predicate is true.</p><div class="fullcomment"><div class="comment cmt"><p>Discard elements at the beginning of the stream while predicate is true.
All elements will be taken after predicate returns false first time.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> predicate returned false and for all following stream elements</p><p><b>Backpressures when</b> predicate returned false and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#dropWithin" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropWithin(d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="dropWithin(FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#dropWithin(d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">dropWithin</span><span class="params">(<span name="d">d: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Discard the elements received within the given duration at beginning of the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Discard the elements received within the given duration at beginning of the stream.</p><p><b>Emits when</b> the specified time elapsed and a new upstream element arrives</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" class="anchorToMember"></a><a id="ensuring((SourceRef[T])=&gt;Boolean,=&gt;Any):SourceRef[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#ensuring(cond:A=&gt;Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="msg">msg: =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:A=&gt;Boolean):A" class="anchorToMember"></a><a id="ensuring((SourceRef[T])=&gt;Boolean):SourceRef[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#ensuring(cond:A=&gt;Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean,msg:=&gt;Any):A" class="anchorToMember"></a><a id="ensuring(Boolean,=&gt;Any):SourceRef[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#ensuring(cond:Boolean,msg:=&gt;Any):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="msg">msg: =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.Predef.Ensuring#ensuring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ensuring(cond:Boolean):A" class="anchorToMember"></a><a id="ensuring(Boolean):SourceRef[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#ensuring(cond:Boolean):A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method Ensuring in scala.Predef.</dd><dt>Definition Classes</dt><dd>Ensuring</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="eq(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean" class="anchorToMember"></a><a id="equals(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#expand" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="expand[U](expander:Out=&gt;Iterator[U]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="expand[U]((T)=&gt;Iterator[U]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#expand[U](expander:Out=&gt;Iterator[U]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">expand</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expander">expander: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/Iterator.html#scala.collection.Iterator" name="scala.collection.Iterator" id="scala.collection.Iterator" class="extype">Iterator</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.expand.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.expand.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Allows a faster downstream to progress independently of a slower upstream by extrapolating elements from an older
element until new element comes from the upstream.</p><div class="fullcomment"><div class="comment cmt"><p>Allows a faster downstream to progress independently of a slower upstream by extrapolating elements from an older
element until new element comes from the upstream. For example an expand step might repeat the last element for
the subscriber until it receives an update from upstream.</p><p>This element will never "drop" upstream elements as all elements go through at least one extrapolation step.
This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
subscriber.</p><p>Expand does not support <a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> and <a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a>.
Exceptions from the <code>seed</code> function will complete the stream with failure.</p><p><b>Emits when</b> downstream stops backpressuring</p><p><b>Backpressures when</b> downstream backpressures or iterator runs empty</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">expander</dt><dd class="cmt"><p>Takes the current extrapolation state to produce an output element and the next extrapolation
                      state.</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#extrapolate[U&gt;:Out](extrapolator:U=&gt;Iterator[U],initial:Option[U]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#extrapolate" id="org.apache.pekko.stream.scaladsl.Source#extrapolate" class="extmbr">#extrapolate</a> for a version that always preserves the original element and allows for an initial "startup"
                      element.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#extrapolate" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="extrapolate[U&gt;:Out](extrapolator:U=&gt;Iterator[U],initial:Option[U]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="extrapolate[U&gt;:Out]((U)=&gt;Iterator[U],Option[U]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#extrapolate[U&gt;:Out](extrapolator:U=&gt;Iterator[U],initial:Option[U]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">extrapolate</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="extrapolator">extrapolator: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.extrapolate.U" class="extype">U</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/Iterator.html#scala.collection.Iterator" name="scala.collection.Iterator" id="scala.collection.Iterator" class="extype">Iterator</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.extrapolate.U" class="extype">U</span>]</span>, <span name="initial">initial: <a href="https://www.scala-lang.org/api/2.13.8/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.extrapolate.U" class="extype">U</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.extrapolate.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Allows a faster downstream to progress independent of a slower upstream.</p><div class="fullcomment"><div class="comment cmt"><p>Allows a faster downstream to progress independent of a slower upstream.</p><p>This is achieved by introducing "extrapolated" elements - based on those from upstream - whenever downstream
signals demand.</p><p>Extrapolate does not support <a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> and <a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a>.
Exceptions from the <code>extrapolate</code> function will complete the stream with failure.</p><p><b>Emits when</b> downstream stops backpressuring, AND EITHER upstream emits OR initial element is present OR
<code>extrapolate</code> is non-empty and applicable</p><p><b>Backpressures when</b> downstream backpressures or current <code>extrapolate</code> runs empty</p><p><b>Completes when</b> upstream completes and current <code>extrapolate</code> runs empty</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">extrapolator</dt><dd class="cmt"><p>takes the current upstream element and provides a sequence of "extrapolated" elements based
                   on the original, to be emitted in case downstream signals demand.</p></dd><dt class="param">initial</dt><dd class="cmt"><p>the initial element to be emitted, in case upstream is able to stall the entire stream.</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#expand[U](expander:Out=&gt;Iterator[U]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#expand" id="org.apache.pekko.stream.scaladsl.Source#expand" class="extmbr">#expand</a>    for a version that can overwrite the original element.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#filter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filter(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="filter((T)=&gt;Boolean):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#filter(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">filter</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Only pass on those elements that satisfy the given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Only pass on those elements that satisfy the given predicate.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the given predicate returns true for the element</p><p><b>Backpressures when</b> the given predicate returns true for the element and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#filterNot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filterNot(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="filterNot((T)=&gt;Boolean):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#filterNot(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">filterNot</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Only pass on those elements that NOT satisfy the given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Only pass on those elements that NOT satisfy the given predicate.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the given predicate returns false for the element</p><p><b>Backpressures when</b> the given predicate returns false for the element and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#flatMapConcat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMapConcat[T,M](f:Out=&gt;org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],M]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="flatMapConcat[T,M]((T)=&gt;Graph[SourceShape[T],M]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#flatMapConcat[T,M](f:Out=&gt;org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],M]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">flatMapConcat</span><span class="tparams">[<span name="T">T</span>, <span name="M">M</span>]</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapConcat.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapConcat.M" class="extype">M</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapConcat.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform each input element into a <code>Source</code> of output elements that is
then flattened into the output stream by concatenation,
fully consuming one Source after the other.</p><div class="fullcomment"><div class="comment cmt"><p>Transform each input element into a <code>Source</code> of output elements that is
then flattened into the output stream by concatenation,
fully consuming one Source after the other.</p><p><b>Emits when</b> a currently consumed substream has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes and all consumed substreams complete</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#flatMapMerge" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMapMerge[T,M](breadth:Int,f:Out=&gt;org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],M]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="flatMapMerge[T,M](Int,(T)=&gt;Graph[SourceShape[T],M]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#flatMapMerge[T,M](breadth:Int,f:Out=&gt;org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],M]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">flatMapMerge</span><span class="tparams">[<span name="T">T</span>, <span name="M">M</span>]</span><span class="params">(<span name="breadth">breadth: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapMerge.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapMerge.M" class="extype">M</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapMerge.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform each input element into a <code>Source</code> of output elements that is
then flattened into the output stream by merging, where at most <code>breadth</code>
substreams are being consumed at any given time.</p><div class="fullcomment"><div class="comment cmt"><p>Transform each input element into a <code>Source</code> of output elements that is
then flattened into the output stream by merging, where at most <code>breadth</code>
substreams are being consumed at any given time.</p><p><b>Emits when</b> a currently consumed substream has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes and all consumed substreams complete</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#flatMapPrefix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMapPrefix[Out2,Mat2](n:Int)(f:Seq[Out]=&gt;org.apache.pekko.stream.scaladsl.Flow[Out,Out2,Mat2]):FlowOps.this.Repr[Out2]" class="anchorToMember"></a><a id="flatMapPrefix[Out2,Mat2](Int)((Seq[T])=&gt;Flow[T,Out2,Mat2]):Source[Out2,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#flatMapPrefix[Out2,Mat2](n:Int)(f:Seq[Out]=&gt;org.apache.pekko.stream.scaladsl.Flow[Out,Out2,Mat2]):FlowOps.this.Repr[Out2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">flatMapPrefix</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Mat2">Mat2</span>]</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]) =&gt; <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapPrefix.Out2" class="extype">Out2</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapPrefix.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.flatMapPrefix.Out2" class="extype">Out2</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Takes up to <code>n</code> elements from the stream (less than <code>n</code> only if the upstream completes before emitting <code>n</code> elements),
then apply <code>f</code> on these elements in order to obtain a flow, this flow is then materialized and the rest of the input is processed by this flow (similar to via).</p><div class="fullcomment"><div class="comment cmt"><p>Takes up to <code>n</code> elements from the stream (less than <code>n</code> only if the upstream completes before emitting <code>n</code> elements),
then apply <code>f</code> on these elements in order to obtain a flow, this flow is then materialized and the rest of the input is processed by this flow (similar to via).
This method returns a flow consuming the rest of the stream producing the materialized flow's output.</p><p><b>Emits when</b> the materialized flow emits.
 Notice the first <code>n</code> elements are buffered internally before materializing the flow and connecting it to the rest of the upstream - producing elements at its own discretion (might 'swallow' or multiply elements).</p><p><b>Backpressures when</b> the materialized flow backpressures</p><p><b>Completes when</b> the materialized flow completes.
 If upstream completes before producing <code>n</code> elements, <code>f</code> will be applied with the provided elements,
 the resulting flow will be materialized and signalled for upstream completion, it can then complete or continue to emit elements at its own discretion.</p><p><b>Cancels when</b> the materialized flow cancels.
 When downstream cancels before materialization of the nested flow, the operator's default behaviour is to cancel immediately,
 this behaviour can be controlled by setting the <a href="Attributes$$NestedMaterializationCancellationPolicy.html" name="org.apache.pekko.stream.Attributes.NestedMaterializationCancellationPolicy" id="org.apache.pekko.stream.Attributes.NestedMaterializationCancellationPolicy" class="extype">pekko.stream.Attributes.NestedMaterializationCancellationPolicy</a> attribute on the flow.
 When this attribute is configured to true, downstream cancellation is delayed until the nested flow's materialization which is then immediately cancelled (with the original cancellation cause).
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number of elements to accumulate before materializing the downstream flow.</p></dd><dt class="param">f</dt><dd class="cmt"><p>a function that produces the downstream flow based on the upstream's prefix.</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#flatMapPrefixMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMapPrefixMat[Out2,Mat2,Mat3](n:Int)(f:Seq[Out]=&gt;org.apache.pekko.stream.scaladsl.Flow[Out,Out2,Mat2])(matF:(Mat,scala.concurrent.Future[Mat2])=&gt;Mat3):FlowOpsMat.this.ReprMat[Out2,Mat3]" class="anchorToMember"></a><a id="flatMapPrefixMat[Out2,Mat2,Mat3](Int)((Seq[T])=&gt;Flow[T,Out2,Mat2])((NotUsed,Future[Mat2])=&gt;Mat3):Source[Out2,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#flatMapPrefixMat[Out2,Mat2,Mat3](n:Int)(f:Seq[Out]=&gt;org.apache.pekko.stream.scaladsl.Flow[Out,Out2,Mat2])(matF:(Mat,scala.concurrent.Future[Mat2])=&gt;Mat3):FlowOpsMat.this.ReprMat[Out2,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">flatMapPrefixMat</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]) =&gt; <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.flatMapPrefixMat.Out2" class="extype">Out2</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.flatMapPrefixMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.flatMapPrefixMat.Mat2" class="extype">Mat2</span>]) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.flatMapPrefixMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.flatMapPrefixMat.Out2" class="extype">Out2</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.flatMapPrefixMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">mat version of <a href="scaladsl/Source.html#flatMapPrefix[Out2,Mat2](n:Int)(f:Seq[Out]=&gt;org.apache.pekko.stream.scaladsl.Flow[Out,Out2,Mat2]):FlowOps.this.Repr[Out2]" name="org.apache.pekko.stream.scaladsl.Source#flatMapPrefix" id="org.apache.pekko.stream.scaladsl.Source#flatMapPrefix" class="extmbr">#flatMapPrefix</a>, this method gives access to a future materialized value of the downstream flow.</p><div class="fullcomment"><div class="comment cmt"><p>mat version of <a href="scaladsl/Source.html#flatMapPrefix[Out2,Mat2](n:Int)(f:Seq[Out]=&gt;org.apache.pekko.stream.scaladsl.Flow[Out,Out2,Mat2]):FlowOps.this.Repr[Out2]" name="org.apache.pekko.stream.scaladsl.Source#flatMapPrefix" id="org.apache.pekko.stream.scaladsl.Source#flatMapPrefix" class="extmbr">#flatMapPrefix</a>, this method gives access to a future materialized value of the downstream flow.
see <a href="scaladsl/Source.html#flatMapPrefix[Out2,Mat2](n:Int)(f:Seq[Out]=&gt;org.apache.pekko.stream.scaladsl.Flow[Out,Out2,Mat2]):FlowOps.this.Repr[Out2]" name="org.apache.pekko.stream.scaladsl.Source#flatMapPrefix" id="org.apache.pekko.stream.scaladsl.Source#flatMapPrefix" class="extmbr">#flatMapPrefix</a> for details.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#fold" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fold[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="fold[T](T)((T,T)=&gt;T):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#fold[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">fold</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="zero">zero: <span name="org.apache.pekko.stream.scaladsl.FlowOps.fold.T" class="extype">T</span></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.fold.T" class="extype">T</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.fold.T" class="extype">T</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.fold.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Similar to <code>scan</code> but only emits its result when the upstream completes,
after which it also completes.</p><div class="fullcomment"><div class="comment cmt"><p>Similar to <code>scan</code> but only emits its result when the upstream completes,
after which it also completes. Applies the given function towards its current and next value,
yielding the next current value.</p><p>If the function <code>f</code> throws an exception and the supervision decision is
<a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> current value starts at <code>zero</code> again
the stream will continue.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p>Note that the <code>zero</code> value must be immutable.</p><p><b>Emits when</b> upstream completes</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#scan[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#scan" id="org.apache.pekko.stream.scaladsl.FlowOps#scan" class="extmbr">FlowOps.scan</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#foldAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldAsync[T](zero:T)(f:(T,Out)=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="foldAsync[T](T)((T,T)=&gt;Future[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#foldAsync[T](zero:T)(f:(T,Out)=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">foldAsync</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="zero">zero: <span name="org.apache.pekko.stream.scaladsl.FlowOps.foldAsync.T" class="extype">T</span></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.foldAsync.T" class="extype">T</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.foldAsync.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.foldAsync.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Similar to <code>fold</code> but with an asynchronous function.</p><div class="fullcomment"><div class="comment cmt"><p>Similar to <code>fold</code> but with an asynchronous function.
Applies the given function towards its current and next value,
yielding the next current value.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p>If the function <code>f</code> returns a failure and the supervision decision is
<a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> current value starts at <code>zero</code> again
the stream will continue.</p><p>Note that the <code>zero</code> value must be immutable.</p><p><b>Emits when</b> upstream completes</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#fold[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#fold" id="org.apache.pekko.stream.scaladsl.FlowOps#fold" class="extmbr">FlowOps.fold</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#getAttributes" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAttributes:org.apache.pekko.stream.Attributes" class="anchorToMember"></a><a id="getAttributes:Attributes" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#getAttributes:org.apache.pekko.stream.Attributes" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">getAttributes</span><span class="result">: <a href="Attributes.html" name="org.apache.pekko.stream.Attributes" id="org.apache.pekko.stream.Attributes" class="extype">Attributes</a></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]" class="anchorToMember"></a><a id="getClass():Class[_&lt;:AnyRef]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef#getSource" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="getSource:org.apache.pekko.stream.javadsl.Source[T,org.apache.pekko.NotUsed]" class="anchorToMember"></a><a id="getSource:Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#getSource:org.apache.pekko.stream.javadsl.Source[T,org.apache.pekko.NotUsed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSource</span><span class="result">: <a href="javadsl/Source.html" name="org.apache.pekko.stream.javadsl.Source" id="org.apache.pekko.stream.javadsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Java API: Get <a href="javadsl/Source.html" name="org.apache.pekko.stream.javadsl.Source" id="org.apache.pekko.stream.javadsl.Source" class="extype">javadsl.Source</a> underlying to this source ref.</p></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#groupBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="groupBy[K](maxSubstreams:Int,f:Out=&gt;K):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" class="anchorToMember"></a><a id="groupBy[K](Int,(T)=&gt;K):SubFlow[T,NotUsed,[+O]Source[O,NotUsed],RunnableGraph[NotUsed]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#groupBy[K](maxSubstreams:Int,f:Out=&gt;K):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="maxSubstreams">maxSubstreams: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.groupBy.K" class="extype">K</span></span>)</span><span class="result">: <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, [+O]<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.Repr.&lt;local Repr&gt;.O" class="extype">O</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>], <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span></span><p class="shortcomment cmt">This operation demultiplexes the incoming stream into separate output
streams, one for each element key.</p><div class="fullcomment"><div class="comment cmt"><p>This operation demultiplexes the incoming stream into separate output
streams, one for each element key. The key is computed for each element
using the given function. When a new key is encountered for the first time
a new substream is opened and subsequently fed with all elements belonging to
that key.</p><p>WARNING: The operator keeps track of all keys of streams that have already been closed.
If you expect an infinite number of keys this can cause memory issues. Elements belonging
to those keys are drained directly and not send to the substream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#groupBy[K](maxSubstreams:Int,f:Out=&gt;K):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" name="org.apache.pekko.stream.scaladsl.Source#groupBy" id="org.apache.pekko.stream.scaladsl.Source#groupBy" class="extmbr">#groupBy</a></p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#groupBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="groupBy[K](maxSubstreams:Int,f:Out=&gt;K,allowClosedSubstreamRecreation:Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" class="anchorToMember"></a><a id="groupBy[K](Int,(T)=&gt;K,Boolean):SubFlow[T,NotUsed,[+O]Source[O,NotUsed],RunnableGraph[NotUsed]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#groupBy[K](maxSubstreams:Int,f:Out=&gt;K,allowClosedSubstreamRecreation:Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="maxSubstreams">maxSubstreams: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.groupBy.K" class="extype">K</span></span>, <span name="allowClosedSubstreamRecreation">allowClosedSubstreamRecreation: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, [+O]<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.Repr.&lt;local Repr&gt;.O" class="extype">O</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>], <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span></span><p class="shortcomment cmt">This operation demultiplexes the incoming stream into separate output
streams, one for each element key.</p><div class="fullcomment"><div class="comment cmt"><p>This operation demultiplexes the incoming stream into separate output
streams, one for each element key. The key is computed for each element
using the given function. When a new key is encountered for the first time
a new substream is opened and subsequently fed with all elements belonging to
that key.</p><p>WARNING: If <code>allowClosedSubstreamRecreation</code> is set to <code>false</code> (default behavior) the operator
keeps track of all keys of streams that have already been closed. If you expect an infinite
number of keys this can cause memory issues. Elements belonging to those keys are drained
directly and not send to the substream.</p><p>Note: If <code>allowClosedSubstreamRecreation</code> is set to <code>true</code> substream completion and incoming
elements are subject to race-conditions. If elements arrive for a stream that is in the process
of closing these elements might get lost.</p><p>The object returned from this method is not a normal <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> or <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>,
it is a <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>. This means that after this operator all transformations
are applied to all encountered substreams in the same fashion. Substream mode
is exited either by closing the substream (i.e. connecting it to a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>)
or by merging the substreams back together; see the <code>to</code> and <code>mergeBack</code> methods
on <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a> for more information.</p><p>It is important to note that the substreams also propagate back-pressure as
any other stream, which means that blocking one substream will block the <code>groupBy</code>
operator itself—and thereby all substreams—once all internal or
explicit buffers are filled.</p><p>If the group by function <code>f</code> throws an exception and the supervision decision
is <a href="Supervision$$Stop$.html" name="org.apache.pekko.stream.Supervision.Stop" id="org.apache.pekko.stream.Supervision.Stop" class="extype">pekko.stream.Supervision.Stop</a> the stream and substreams will be completed
with failure.</p><p>If the group by function <code>f</code> throws an exception and the supervision decision
is <a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a> or <a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a>
the element is dropped and the stream and substreams continue.</p><p>Function <code>f</code>  MUST NOT return <code>null</code>. This will throw exception and trigger supervision decision mechanism.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> an element for which the grouping function returns a group that has not yet been created.
Emits the new group</p><p><b>Backpressures when</b> there is an element pending for a group whose substream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels and all substreams cancel
</p></div><dl class="paramcmts block"><dt class="param">maxSubstreams</dt><dd class="cmt"><p>configures the maximum number of substreams (keys)
       that are supported; if more distinct keys are encountered then the stream fails</p></dd><dt class="param">f</dt><dd class="cmt"><p>computes the key for each element</p></dd><dt class="param">allowClosedSubstreamRecreation</dt><dd class="cmt"><p>enables recreation of already closed substreams if elements with their
       corresponding keys arrive after completion</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#grouped" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="grouped(n:Int):FlowOps.this.Repr[Seq[Out]]" class="anchorToMember"></a><a id="grouped(Int):Source[Seq[T],NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#grouped(n:Int):FlowOps.this.Repr[Seq[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">grouped</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Chunk up this stream into groups of the given size, with the last group
possibly smaller than requested due to end-of-stream.</p><div class="fullcomment"><div class="comment cmt"><p>Chunk up this stream into groups of the given size, with the last group
possibly smaller than requested due to end-of-stream.</p><p><code>n</code> must be positive, otherwise IllegalArgumentException is thrown.</p><p><b>Emits when</b> the specified number of elements have been accumulated or upstream completed</p><p><b>Backpressures when</b> a group has been assembled and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#groupedWeighted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="groupedWeighted(minWeight:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Seq[Out]]" class="anchorToMember"></a><a id="groupedWeighted(Long)((T)=&gt;Long):Source[Seq[T],NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#groupedWeighted(minWeight:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Seq[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">groupedWeighted</span><span class="params">(<span name="minWeight">minWeight: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="params">(<span name="costFn">costFn: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Chunk up this stream into groups of elements that have a cumulative weight greater than or equal to
the <code>minWeight</code>, with the last group possibly smaller than requested <code>minWeight</code> due to end-of-stream.</p><div class="fullcomment"><div class="comment cmt"><p>Chunk up this stream into groups of elements that have a cumulative weight greater than or equal to
the <code>minWeight</code>, with the last group possibly smaller than requested <code>minWeight</code> due to end-of-stream.</p><p><code>minWeight</code> must be positive, otherwise IllegalArgumentException is thrown.
<code>costFn</code> must return a non-negative result for all inputs, otherwise the stage will fail
with an IllegalArgumentException.</p><p><b>Emits when</b> the cumulative weight of elements is greater than or equal to the <code>minWeight</code> or upstream completed</p><p><b>Backpressures when</b> a buffered group weighs more than <code>minWeight</code> and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#groupedWeightedWithin" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="groupedWeightedWithin(maxWeight:Long,maxNumber:Int,d:scala.concurrent.duration.FiniteDuration)(costFn:Out=&gt;Long):FlowOps.this.Repr[Seq[Out]]" class="anchorToMember"></a><a id="groupedWeightedWithin(Long,Int,FiniteDuration)((T)=&gt;Long):Source[Seq[T],NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#groupedWeightedWithin(maxWeight:Long,maxNumber:Int,d:scala.concurrent.duration.FiniteDuration)(costFn:Out=&gt;Long):FlowOps.this.Repr[Seq[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">groupedWeightedWithin</span><span class="params">(<span name="maxWeight">maxWeight: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="maxNumber">maxNumber: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="params">(<span name="costFn">costFn: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Chunk up this stream into groups of elements received within a time window,
or limited by the weight and number of the elements, whatever happens first.</p><div class="fullcomment"><div class="comment cmt"><p>Chunk up this stream into groups of elements received within a time window,
or limited by the weight and number of the elements, whatever happens first.
Empty groups will not be emitted if no elements are received from upstream.
The last group before end-of-stream will contain the buffered elements
since the previously emitted group.</p><p><code>maxWeight</code> must be positive, <code>maxNumber</code> must be positive, and <code>d</code> must be greater than 0 seconds,
otherwise IllegalArgumentException is thrown.</p><p><b>Emits when</b> the configured time elapses since the last group has been emitted or weight limit reached</p><p><b>Backpressures when</b> downstream backpressures, and buffered group (+ pending element) weighs more than
<code>maxWeight</code> or has more than <code>maxNumber</code> elements</p><p><b>Completes when</b> upstream completes (emits last group)</p><p><b>Cancels when</b> downstream completes
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#groupedWeightedWithin" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="groupedWeightedWithin(maxWeight:Long,d:scala.concurrent.duration.FiniteDuration)(costFn:Out=&gt;Long):FlowOps.this.Repr[Seq[Out]]" class="anchorToMember"></a><a id="groupedWeightedWithin(Long,FiniteDuration)((T)=&gt;Long):Source[Seq[T],NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#groupedWeightedWithin(maxWeight:Long,d:scala.concurrent.duration.FiniteDuration)(costFn:Out=&gt;Long):FlowOps.this.Repr[Seq[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">groupedWeightedWithin</span><span class="params">(<span name="maxWeight">maxWeight: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="params">(<span name="costFn">costFn: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Chunk up this stream into groups of elements received within a time window,
or limited by the weight of the elements, whatever happens first.</p><div class="fullcomment"><div class="comment cmt"><p>Chunk up this stream into groups of elements received within a time window,
or limited by the weight of the elements, whatever happens first.
Empty groups will not be emitted if no elements are received from upstream.
The last group before end-of-stream will contain the buffered elements
since the previously emitted group.</p><p><code>maxWeight</code> must be positive, and <code>d</code> must be greater than 0 seconds, otherwise
IllegalArgumentException is thrown.</p><p><b>Emits when</b> the configured time elapses since the last group has been emitted or weight limit reached</p><p><b>Backpressures when</b> downstream backpressures, and buffered group (+ pending element) weighs more than <code>maxWeight</code></p><p><b>Completes when</b> upstream completes (emits last group)</p><p><b>Cancels when</b> downstream completes
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#groupedWithin" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="groupedWithin(n:Int,d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Seq[Out]]" class="anchorToMember"></a><a id="groupedWithin(Int,FiniteDuration):Source[Seq[T],NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#groupedWithin(n:Int,d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Seq[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">groupedWithin</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Chunk up this stream into groups of elements received within a time window,
or limited by the given number of elements, whatever happens first.</p><div class="fullcomment"><div class="comment cmt"><p>Chunk up this stream into groups of elements received within a time window,
or limited by the given number of elements, whatever happens first.
Empty groups will not be emitted if no elements are received from upstream.
The last group before end-of-stream will contain the buffered elements
since the previously emitted group.</p><p><code>n</code> must be positive, and <code>d</code> must be greater than 0 seconds, otherwise
IllegalArgumentException is thrown.</p><p><b>Emits when</b> the configured time elapses since the last group has been emitted or <code>n</code> elements is buffered</p><p><b>Backpressures when</b> downstream backpressures, and there are <code>n+1</code> buffered elements</p><p><b>Completes when</b> upstream completes (emits last group)</p><p><b>Cancels when</b> downstream completes
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#idleTimeout" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="idleTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="idleTimeout(FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#idleTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">idleTimeout</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">If the time between two processed elements exceeds the provided timeout, the stream is failed
with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>.</p><div class="fullcomment"><div class="comment cmt"><p>If the time between two processed elements exceeds the provided timeout, the stream is failed
with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>. The timeout is checked periodically,
so the resolution of the check is one period (equals to timeout value).</p><p><b>Emits when</b> upstream emits an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or fails if timeout elapses between two emitted elements</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#initialDelay" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="initialDelay(delay:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="initialDelay(FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#initialDelay(delay:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">initialDelay</span><span class="params">(<span name="delay">delay: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Delays the initial element by the specified duration.</p><div class="fullcomment"><div class="comment cmt"><p>Delays the initial element by the specified duration.</p><p><b>Emits when</b> upstream emits an element if the initial delay is already elapsed</p><p><b>Backpressures when</b> downstream backpressures or initial delay is not yet elapsed</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#initialTimeout" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="initialTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="initialTimeout(FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#initialTimeout(timeout:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">initialTimeout</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">If the first element has not passed through this operator before the provided timeout, the stream is failed
with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>.</p><div class="fullcomment"><div class="comment cmt"><p>If the first element has not passed through this operator before the provided timeout, the stream is failed
with a <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/index.html#TimeoutException=java.util.concurrent.TimeoutException" name="scala.concurrent" id="scala.concurrent" class="extype">scala.concurrent.TimeoutException</a>.</p><p><b>Emits when</b> upstream emits an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or fails if timeout elapses before first element arrives</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#interleave" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interleave[U&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],segmentSize:Int,eagerClose:Boolean):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="interleave[U&gt;:Out](Graph[SourceShape[U],_],Int,Boolean):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#interleave[U&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],segmentSize:Int,eagerClose:Boolean):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">interleave</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.interleave.U" class="extype">U</span>], _]</span>, <span name="segmentSize">segmentSize: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="eagerClose">eagerClose: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.interleave.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.
It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code>
source, then repeat process.</p><p>If eagerClose is false and one of the upstreams complete the elements from the other upstream will continue passing
through the interleave operator. If eagerClose is true and one of the upstream complete interleave will cancel the
other upstream and complete itself.</p><p>If it gets error from one of upstreams - stream completes with failure.</p><p><b>Emits when</b> element is available from the currently consumed upstream</p><p><b>Backpressures when</b> downstream backpressures. Signal to current
upstream, switch to next upstream when received <code>segmentSize</code> elements</p><p><b>Completes when</b> the <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> and given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#interleave" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interleave[U&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],segmentSize:Int):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="interleave[U&gt;:Out](Graph[SourceShape[U],_],Int):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#interleave[U&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],segmentSize:Int):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">interleave</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.interleave.U" class="extype">U</span>], _]</span>, <span name="segmentSize">segmentSize: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.interleave.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.
It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code>
source, then repeat process.</p><p>Example:</p><pre>Source(<span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)).interleave(<span class="std">List</span>(<span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>), <span class="num">2</span>) <span class="cmt">// 1, 2, 4, 5, 3, 6, 7</span></pre><p>After one of upstreams is complete then all the rest elements will be emitted from the second one</p><p>If it gets error from one of upstreams - stream completes with failure.</p><p><b>Emits when</b> element is available from the currently consumed upstream</p><p><b>Backpressures when</b> downstream backpressures. Signal to current
upstream, switch to next upstream when received <code>segmentSize</code> elements</p><p><b>Completes when</b> the <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> and given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#interleaveAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interleaveAll[U&gt;:Out](those:Seq[org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]],segmentSize:Int,eagerClose:Boolean):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="interleaveAll[U&gt;:Out](Seq[Graph[SourceShape[U],_]],Int,Boolean):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#interleaveAll[U&gt;:Out](those:Seq[org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]],segmentSize:Int,eagerClose:Boolean):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">interleaveAll</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="those">those: <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.interleaveAll.U" class="extype">U</span>], _]]</span>, <span name="segmentSize">segmentSize: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="eagerClose">eagerClose: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.interleaveAll.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.
It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code>
source, then repeat process.</p><p>If eagerClose is false and one of the upstreams complete the elements from the other upstream will continue passing
through the interleave operator. If eagerClose is true and one of the upstream complete interleave will cancel the
other upstream and complete itself.</p><p>If it gets error from one of upstreams - stream completes with failure.</p><p><b>Emits when</b> element is available from the currently consumed upstream</p><p><b>Backpressures when</b> downstream backpressures. Signal to current
upstream, switch to next upstream when received <code>segmentSize</code> elements</p><p><b>Completes when</b> the <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> and given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#interleaveMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interleaveMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],segmentSize:Int,eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="interleaveMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2],Int,Boolean)((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#interleaveMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],segmentSize:Int,eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">interleaveMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat2" class="extype">Mat2</span>]</span>, <span name="segmentSize">segmentSize: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="eagerClose">eagerClose: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.
It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
then repeat process.</p><p>If eagerClose is false and one of the upstreams complete the elements from the other upstream will continue passing
through the interleave operator. If eagerClose is true and one of the upstream complete interleave will cancel the
other upstream and complete itself.</p><p>If it gets error from one of upstreams - stream completes with failure.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>Annotations</dt><dd><span class="name">@nowarn</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#interleave[U&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],segmentSize:Int,eagerClose:Boolean):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#interleave" id="org.apache.pekko.stream.scaladsl.Source#interleave" class="extmbr">#interleave</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#interleaveMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interleaveMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],segmentSize:Int)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="interleaveMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2],Int)((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#interleaveMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],segmentSize:Int)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">interleaveMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat2" class="extype">Mat2</span>]</span>, <span name="segmentSize">segmentSize: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.interleaveMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Interleave is a deterministic merge of the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with elements of this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>.
It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
then repeat process.</p><p>After one of upstreams is complete then all the rest elements will be emitted from the second one</p><p>If it gets error from one of upstreams - stream completes with failure.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>Annotations</dt><dd><span class="name">@nowarn</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#interleave[U&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],segmentSize:Int,eagerClose:Boolean):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#interleave" id="org.apache.pekko.stream.scaladsl.Source#interleave" class="extmbr">#interleave</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#intersperse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="intersperse[T&gt;:Out](inject:T):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="intersperse[T&gt;:Out](T):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#intersperse[T&gt;:Out](inject:T):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">intersperse</span><span class="tparams">[<span name="T">T &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="inject">inject: <span name="org.apache.pekko.stream.scaladsl.FlowOps.intersperse.T" class="extype">T</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.intersperse.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Intersperses stream with provided element, similar to how <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/List.html#mkString:String" name="scala.collection.immutable.List" id="scala.collection.immutable.List" class="extype">scala.collection.immutable.List.mkString</a>
injects a separator between a List's elements.</p><div class="fullcomment"><div class="comment cmt"><p>Intersperses stream with provided element, similar to how <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/List.html#mkString:String" name="scala.collection.immutable.List" id="scala.collection.immutable.List" class="extype">scala.collection.immutable.List.mkString</a>
injects a separator between a List's elements.</p><p>Additionally can inject start and end marker elements to stream.</p><p>Examples:</p><pre><span class="kw">val</span> nums = Source(<span class="std">List</span>(<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>)).map(_.toString)
nums.intersperse(<span class="lit">","</span>)            <span class="cmt">//   1 , 2 , 3</span>
nums.intersperse(<span class="lit">"["</span>, <span class="lit">","</span>, <span class="lit">"]"</span>)  <span class="cmt">// [ 1 , 2 , 3 ]</span></pre><p><b>Emits when</b> upstream emits (or before with the <code>start</code> element if provided)</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#intersperse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="intersperse[T&gt;:Out](start:T,inject:T,end:T):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="intersperse[T&gt;:Out](T,T,T):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#intersperse[T&gt;:Out](start:T,inject:T,end:T):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">intersperse</span><span class="tparams">[<span name="T">T &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="start">start: <span name="org.apache.pekko.stream.scaladsl.FlowOps.intersperse.T" class="extype">T</span></span>, <span name="inject">inject: <span name="org.apache.pekko.stream.scaladsl.FlowOps.intersperse.T" class="extype">T</span></span>, <span name="end">end: <span name="org.apache.pekko.stream.scaladsl.FlowOps.intersperse.T" class="extype">T</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.intersperse.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Intersperses stream with provided element, similar to how <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/List.html#mkString:String" name="scala.collection.immutable.List" id="scala.collection.immutable.List" class="extype">scala.collection.immutable.List.mkString</a>
injects a separator between a List's elements.</p><div class="fullcomment"><div class="comment cmt"><p>Intersperses stream with provided element, similar to how <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/List.html#mkString:String" name="scala.collection.immutable.List" id="scala.collection.immutable.List" class="extype">scala.collection.immutable.List.mkString</a>
injects a separator between a List's elements.</p><p>Additionally can inject start and end marker elements to stream.</p><p>Examples:</p><pre><span class="kw">val</span> nums = Source(<span class="std">List</span>(<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>)).map(_.toString)
nums.intersperse(<span class="lit">","</span>)            <span class="cmt">//   1 , 2 , 3</span>
nums.intersperse(<span class="lit">"["</span>, <span class="lit">","</span>, <span class="lit">"]"</span>)  <span class="cmt">// [ 1 , 2 , 3 ]</span></pre><p>In case you want to only prepend or only append an element (yet still use the <code>intercept</code> feature
to inject a separator between elements, you may want to use the following pattern instead of the 3-argument
version of intersperse (See <a href="scaladsl/Source.html#concat[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#concat" id="org.apache.pekko.stream.scaladsl.Source#concat" class="extmbr">Source.concat</a> for semantics details):</p><pre>Source.single(<span class="lit">"&gt;&gt; "</span>) ++ Source(<span class="std">List</span>(<span class="lit">"1"</span>, <span class="lit">"2"</span>, <span class="lit">"3"</span>)).intersperse(<span class="lit">","</span>)
Source(<span class="std">List</span>(<span class="lit">"1"</span>, <span class="lit">"2"</span>, <span class="lit">"3"</span>)).intersperse(<span class="lit">","</span>) ++ Source.single(<span class="lit">"END"</span>)</pre><p><b>Emits when</b> upstream emits (or before with the <code>start</code> element if provided)</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#keepAlive" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="keepAlive[U&gt;:Out](maxIdle:scala.concurrent.duration.FiniteDuration,injectedElem:()=&gt;U):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="keepAlive[U&gt;:Out](FiniteDuration,()=&gt;U):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#keepAlive[U&gt;:Out](maxIdle:scala.concurrent.duration.FiniteDuration,injectedElem:()=&gt;U):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">keepAlive</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="maxIdle">maxIdle: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="injectedElem">injectedElem: () =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.keepAlive.U" class="extype">U</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.keepAlive.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Injects additional elements if upstream does not emit for a configured amount of time.</p><div class="fullcomment"><div class="comment cmt"><p>Injects additional elements if upstream does not emit for a configured amount of time. In other words, this
operator attempts to maintains a base rate of emitted elements towards the downstream.</p><p>If the downstream backpressures then no element is injected until downstream demand arrives. Injected elements
do not accumulate during this period.</p><p>Upstream elements are always preferred over injected elements.</p><p><b>Emits when</b> upstream emits an element or if the upstream was idle for the configured period</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#limit" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="limit(max:Long):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="limit(Long):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#limit(max:Long):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">limit</span><span class="params">(<span name="max">max: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Ensure stream boundedness by limiting the number of elements from upstream.</p><div class="fullcomment"><div class="comment cmt"><p>Ensure stream boundedness by limiting the number of elements from upstream.
If the number of incoming elements exceeds max, it will signal
upstream failure <code>StreamLimitException</code> downstream.</p><p>Due to input buffering some elements may have been
requested from upstream publishers that will then not be processed downstream
of this step.</p><p><b>Emits when</b> upstream emits and the number of emitted elements has not reached max</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes and the number of emitted elements has not reached max</p><p><b>Errors when</b> the total number of incoming element exceeds max</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#take(n:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#take" id="org.apache.pekko.stream.scaladsl.FlowOps#take" class="extmbr">FlowOps.take</a>, <a href="scaladsl/FlowOps.html#takeWithin(d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#takeWithin" id="org.apache.pekko.stream.scaladsl.FlowOps#takeWithin" class="extmbr">FlowOps.takeWithin</a>, <a href="scaladsl/FlowOps.html#takeWhile(p:Out=&gt;Boolean,inclusive:Boolean):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#takeWhile" id="org.apache.pekko.stream.scaladsl.FlowOps#takeWhile" class="extmbr">FlowOps.takeWhile</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#limitWeighted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="limitWeighted[T](max:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="limitWeighted[T](Long)((T)=&gt;Long):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#limitWeighted[T](max:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">limitWeighted</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="max">max: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="params">(<span name="costFn">costFn: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Ensure stream boundedness by evaluating the cost of incoming elements
using a cost function.</p><div class="fullcomment"><div class="comment cmt"><p>Ensure stream boundedness by evaluating the cost of incoming elements
using a cost function. Exactly how many elements will be allowed to travel downstream depends on the
evaluated cost of each element. If the accumulated cost exceeds max, it will signal
upstream failure <code>StreamLimitException</code> downstream.</p><p>Due to input buffering some elements may have been
requested from upstream publishers that will then not be processed downstream
of this step.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> upstream emits and the accumulated cost has not reached max</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes and the number of emitted elements has not reached max</p><p><b>Errors when</b> when the accumulated cost exceeds max</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#take(n:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#take" id="org.apache.pekko.stream.scaladsl.FlowOps#take" class="extmbr">FlowOps.take</a>, <a href="scaladsl/FlowOps.html#takeWithin(d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#takeWithin" id="org.apache.pekko.stream.scaladsl.FlowOps#takeWithin" class="extmbr">FlowOps.takeWithin</a>, <a href="scaladsl/FlowOps.html#takeWhile(p:Out=&gt;Boolean,inclusive:Boolean):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#takeWhile" id="org.apache.pekko.stream.scaladsl.FlowOps#takeWhile" class="extmbr">FlowOps.takeWhile</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#log" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="log(name:String,extract:Out=&gt;Any)(implicitlog:org.apache.pekko.event.LoggingAdapter):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="log(String,(T)=&gt;Any)(LoggingAdapter):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#log(name:String,extract:Out=&gt;Any)(implicitlog:org.apache.pekko.event.LoggingAdapter):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">log</span><span class="params">(<span name="name">name: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span>, <span name="extract">extract: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a> = <span class="symbol"><span class="name"><a href="../../../index.html">ConstantFun.scalaIdentityFunction</a></span></span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="log">log: <a href="../event/LoggingAdapter.html" name="org.apache.pekko.event.LoggingAdapter" id="org.apache.pekko.event.LoggingAdapter" class="extype">LoggingAdapter</a> = <span class="symbol">null</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Logs elements flowing through the stream as well as completion and erroring.</p><div class="fullcomment"><div class="comment cmt"><p>Logs elements flowing through the stream as well as completion and erroring.</p><p>By default element and completion signals are logged on debug level, and errors are logged on Error level.
This can be adjusted according to your needs by providing a custom <a href="Attributes$$LogLevels.html" name="org.apache.pekko.stream.Attributes.LogLevels" id="org.apache.pekko.stream.Attributes.LogLevels" class="extype">Attributes.LogLevels</a> attribute on the given Flow:</p><p>Uses implicit <span name="LoggingAdapter" class="extype">LoggingAdapter</span> if available, otherwise uses an internally created one,
which uses <code>org.apache.pekko.event.Logging(materializer.system, materializer)</code> as its source (use this class to configure slf4j loggers).</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the mapping function returns an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#logWithMarker" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="logWithMarker(name:String,marker:Out=&gt;org.apache.pekko.event.LogMarker,extract:Out=&gt;Any)(implicitlog:org.apache.pekko.event.MarkerLoggingAdapter):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="logWithMarker(String,(T)=&gt;LogMarker,(T)=&gt;Any)(MarkerLoggingAdapter):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#logWithMarker(name:String,marker:Out=&gt;org.apache.pekko.event.LogMarker,extract:Out=&gt;Any)(implicitlog:org.apache.pekko.event.MarkerLoggingAdapter):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">logWithMarker</span><span class="params">(<span name="name">name: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span>, <span name="marker">marker: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="../event/LogMarker.html" name="org.apache.pekko.event.LogMarker" id="org.apache.pekko.event.LogMarker" class="extype">LogMarker</a></span>, <span name="extract">extract: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a> = <span class="symbol"><span class="name"><a href="../../../index.html">ConstantFun.scalaIdentityFunction</a></span></span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="log">log: <a href="../event/MarkerLoggingAdapter.html" name="org.apache.pekko.event.MarkerLoggingAdapter" id="org.apache.pekko.event.MarkerLoggingAdapter" class="extype">MarkerLoggingAdapter</a> = <span class="symbol">null</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Logs elements flowing through the stream as well as completion and erroring.</p><div class="fullcomment"><div class="comment cmt"><p>Logs elements flowing through the stream as well as completion and erroring.</p><p>By default element and completion signals are logged on debug level, and errors are logged on Error level.
This can be adjusted according to your needs by providing a custom <a href="Attributes$$LogLevels.html" name="org.apache.pekko.stream.Attributes.LogLevels" id="org.apache.pekko.stream.Attributes.LogLevels" class="extype">Attributes.LogLevels</a> attribute on the given Flow:</p><p>Uses implicit <span name="MarkerLoggingAdapter" class="extype">MarkerLoggingAdapter</span> if available, otherwise uses an internally created one,
which uses <code>org.apache.pekko.event.Logging.withMarker(materializer.system, materializer)</code> as its source (use this class to configure slf4j loggers).</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the mapping function returns an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[T](f:Out=&gt;T):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="map[T]((T)=&gt;T):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#map[T](f:Out=&gt;T):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">map</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.map.T" class="extype">T</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.map.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform this stream by applying the given function to each of the elements
as they pass through this processing step.</p><div class="fullcomment"><div class="comment cmt"><p>Transform this stream by applying the given function to each of the elements
as they pass through this processing step.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the mapping function returns an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mapAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapAsync[T](parallelism:Int)(f:Out=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="mapAsync[T](Int)((T)=&gt;Future[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mapAsync[T](parallelism:Int)(f:Out=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mapAsync</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mapAsync.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mapAsync.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform this stream by applying the given function to each of the elements
as they pass through this processing step.</p><div class="fullcomment"><div class="comment cmt"><p>Transform this stream by applying the given function to each of the elements
as they pass through this processing step. The function returns a <code>Future</code> and the
value of that future will be emitted downstream. The number of Futures
that shall run in parallel is given as the first argument to <code><code>mapAsync</code></code>.
These Futures may complete in any order, but the elements that
are emitted downstream are in the same order as received from upstream.</p><p>If the function <code>f</code> throws an exception or if the <code>Future</code> is completed
with failure and the supervision decision is <a href="Supervision$$Stop$.html" name="org.apache.pekko.stream.Supervision.Stop" id="org.apache.pekko.stream.Supervision.Stop" class="extype">pekko.stream.Supervision.Stop</a>
the stream will be completed with failure.</p><p>If the function <code>f</code> throws an exception or if the <code>Future</code> is completed
with failure and the supervision decision is <a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a> or
<a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> the element is dropped and the stream continues.</p><p>The function <code>f</code> is always invoked on the elements in the order they arrive.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the Future returned by the provided function finishes for the next element in sequence</p><p><b>Backpressures when</b> the number of futures reaches the configured parallelism and the downstream
backpressures or the first future is not completed</p><p><b>Completes when</b> upstream completes and all futures have been completed and all elements have been emitted</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#mapAsyncUnordered[T](parallelism:Int)(f:Out=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.Source#mapAsyncUnordered" id="org.apache.pekko.stream.scaladsl.Source#mapAsyncUnordered" class="extmbr">#mapAsyncUnordered</a></p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mapAsyncUnordered" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapAsyncUnordered[T](parallelism:Int)(f:Out=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="mapAsyncUnordered[T](Int)((T)=&gt;Future[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mapAsyncUnordered[T](parallelism:Int)(f:Out=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mapAsyncUnordered</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mapAsyncUnordered.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mapAsyncUnordered.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform this stream by applying the given function to each of the elements
as they pass through this processing step.</p><div class="fullcomment"><div class="comment cmt"><p>Transform this stream by applying the given function to each of the elements
as they pass through this processing step. The function returns a <code>Future</code> and the
value of that future will be emitted downstream. The number of Futures
that shall run in parallel is given as the first argument to <code><code>mapAsyncUnordered</code></code>.
Each processed element will be emitted downstream as soon as it is ready, i.e. it is possible
that the elements are not emitted downstream in the same order as received from upstream.</p><p>If the function <code>f</code> throws an exception or if the <code>Future</code> is completed
with failure and the supervision decision is <a href="Supervision$$Stop$.html" name="org.apache.pekko.stream.Supervision.Stop" id="org.apache.pekko.stream.Supervision.Stop" class="extype">pekko.stream.Supervision.Stop</a>
the stream will be completed with failure.</p><p>If the function <code>f</code> throws an exception or if the <code>Future</code> is completed
with failure and the supervision decision is <a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a> or
<a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> the element is dropped and the stream continues.</p><p>The function <code>f</code> is always invoked on the elements in the order they arrive (even though the result of the futures
returned by <code>f</code> might be emitted in a different order).</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> any of the Futures returned by the provided function complete</p><p><b>Backpressures when</b> the number of futures reaches the configured parallelism and the downstream backpressures</p><p><b>Completes when</b> upstream completes and all futures have been completed and all elements have been emitted</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#mapAsync[T](parallelism:Int)(f:Out=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.Source#mapAsync" id="org.apache.pekko.stream.scaladsl.Source#mapAsync" class="extmbr">#mapAsync</a></p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mapConcat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapConcat[T](f:Out=&gt;IterableOnce[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="mapConcat[T]((T)=&gt;IterableOnce[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mapConcat[T](f:Out=&gt;IterableOnce[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mapConcat</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/IterableOnce.html#scala.collection.IterableOnce" name="scala.collection.IterableOnce" id="scala.collection.IterableOnce" class="extype">IterableOnce</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mapConcat.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mapConcat.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform each input element into an <code>Iterable</code> of output elements that is
then flattened into the output stream.</p><div class="fullcomment"><div class="comment cmt"><p>Transform each input element into an <code>Iterable</code> of output elements that is
then flattened into the output stream.</p><p>The returned <code>Iterable</code> MUST NOT contain <code>null</code> values,
as they are illegal as stream elements - according to the Reactive Streams specification.</p><p><b>Emits when</b> the mapping function returns an element or there are still remaining elements
from the previously calculated collection</p><p><b>Backpressures when</b> downstream backpressures or there are still remaining elements from the
previously calculated collection</p><p><b>Completes when</b> upstream completes and all remaining elements have been emitted</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mapError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapError(pf:PartialFunction[Throwable,Throwable]):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="mapError(PartialFunction[Throwable,Throwable]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mapError(pf:PartialFunction[Throwable,Throwable]):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mapError</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.8/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#java.lang.Throwable" name="java.lang.Throwable" id="java.lang.Throwable" class="extype">Throwable</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#java.lang.Throwable" name="java.lang.Throwable" id="java.lang.Throwable" class="extype">Throwable</a>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">While similar to <a href="scaladsl/Source.html#recover[T&gt;:Out](pf:PartialFunction[Throwable,T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.Source#recover" id="org.apache.pekko.stream.scaladsl.Source#recover" class="extmbr">recover</a> this operator can be used to transform an error signal to a different one *without* logging
it as an error in the process.</p><div class="fullcomment"><div class="comment cmt"><p>While similar to <a href="scaladsl/Source.html#recover[T&gt;:Out](pf:PartialFunction[Throwable,T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.Source#recover" id="org.apache.pekko.stream.scaladsl.Source#recover" class="extmbr">recover</a> this operator can be used to transform an error signal to a different one *without* logging
it as an error in the process. So in that sense it is NOT exactly equivalent to <code>recover(t =&gt; throw t2)</code> since recover
would log the <code>t2</code> error.</p><p>Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
This operator can recover the failure signal, but not the skipped elements, which will be dropped.</p><p>Similarly to <a href="scaladsl/Source.html#recover[T&gt;:Out](pf:PartialFunction[Throwable,T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.Source#recover" id="org.apache.pekko.stream.scaladsl.Source#recover" class="extmbr">recover</a> throwing an exception inside <code>mapError</code> _will_ be logged.</p><p><b>Emits when</b> element is available from the upstream or upstream is failed and pf returns an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or upstream failed with exception pf can handle</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mapMaterializedValue" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapMaterializedValue[Mat2](f:Mat=&gt;Mat2):Source.this.ReprMat[Out,Mat2]" class="anchorToMember"></a><a id="mapMaterializedValue[Mat2]((NotUsed)=&gt;Mat2):Source[T,Mat2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mapMaterializedValue[Mat2](f:Mat=&gt;Mat2):Source.this.ReprMat[Out,Mat2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mapMaterializedValue</span><span class="tparams">[<span name="Mat2">Mat2</span>]</span><span class="params">(<span name="f">f: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>) =&gt; <span name="org.apache.pekko.stream.scaladsl.Source.mapMaterializedValue.Mat2" class="extype">Mat2</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.Source.mapMaterializedValue.Mat2" class="extype">Mat2</span>]</span></span><p class="shortcomment cmt">Transform only the materialized value of this Source, leaving all other properties as they were.</p><div class="fullcomment"><div class="comment cmt"><p>Transform only the materialized value of this Source, leaving all other properties as they were.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#merge" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="merge[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],eagerComplete:Boolean):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="merge[U&gt;:Out,M](Graph[SourceShape[U],M],Boolean):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#merge[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],eagerComplete:Boolean):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">merge</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="M">M</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.merge.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.merge.M" class="extype">M</span>]</span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.merge.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking randomly when several elements ready.</p><div class="fullcomment"><div class="comment cmt"><p>Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking randomly when several elements ready.</p><p><b>Emits when</b> one of the inputs has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true), default value is <code>false</code></p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergeAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeAll[U&gt;:Out](those:Seq[org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]],eagerComplete:Boolean):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="mergeAll[U&gt;:Out](Seq[Graph[SourceShape[U],_]],Boolean):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergeAll[U&gt;:Out](those:Seq[org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]],eagerComplete:Boolean):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergeAll</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="those">those: <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeAll.U" class="extype">U</span>], _]]</span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeAll.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking randomly when several elements ready.</p><div class="fullcomment"><div class="comment cmt"><p>Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>s to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking randomly when several elements ready.</p><p><b>Emits when</b> one of the inputs has an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstreams complete (eagerComplete=false) or one upstream completes (eagerComplete=true), default value is <code>false</code></p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergeLatest" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeLatest[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],eagerComplete:Boolean):FlowOps.this.Repr[Seq[U]]" class="anchorToMember"></a><a id="mergeLatest[U&gt;:Out,M](Graph[SourceShape[U],M],Boolean):Source[Seq[U],NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergeLatest[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],eagerComplete:Boolean):FlowOps.this.Repr[Seq[U]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergeLatest</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="M">M</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeLatest.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeLatest.M" class="extype">M</span>]</span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeLatest.U" class="extype">U</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">MergeLatest joins elements from N input streams into stream of lists of size N.</p><div class="fullcomment"><div class="comment cmt"><p>MergeLatest joins elements from N input streams into stream of lists of size N.
i-th element in list is the latest emitted element from i-th input stream.
MergeLatest emits list for each element emitted from some input stream,
but only after each input stream emitted at least one element.</p><p><b>Emits when</b> an element is available from some input and each input emits at least one element from stream start</p><p><b>Completes when</b> all upstreams complete (eagerClose=false) or one upstream completes (eagerClose=true)
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergeLatestMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeLatestMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Seq[U],Mat3]" class="anchorToMember"></a><a id="mergeLatestMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2],Boolean)((NotUsed,Mat2)=&gt;Mat3):Source[Seq[U],Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergeLatestMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Seq[U],Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergeLatestMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeLatestMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeLatestMat.Mat2" class="extype">Mat2</span>]</span>, <span name="eagerClose">eagerClose: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeLatestMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeLatestMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeLatestMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeLatestMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">MergeLatest joins elements from N input streams into stream of lists of size N.</p><div class="fullcomment"><div class="comment cmt"><p>MergeLatest joins elements from N input streams into stream of lists of size N.
i-th element in list is the latest emitted element from i-th input stream.
MergeLatest emits list for each element emitted from some input stream,
but only after each input stream emitted at least one element.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#mergeLatest[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],eagerComplete:Boolean):FlowOps.this.Repr[Seq[U]]" name="org.apache.pekko.stream.scaladsl.Source#mergeLatest" id="org.apache.pekko.stream.scaladsl.Source#mergeLatest" class="extmbr">#mergeLatest</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergeMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],eagerComplete:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="mergeMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2],Boolean)((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergeMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],eagerComplete:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergeMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeMat.Mat2" class="extype">Mat2</span>]</span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking randomly when several elements ready.</p><div class="fullcomment"><div class="comment cmt"><p>Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking randomly when several elements ready.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#merge[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],eagerComplete:Boolean):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#merge" id="org.apache.pekko.stream.scaladsl.Source#merge" class="extmbr">#merge</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergePreferred" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergePreferred[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],preferred:Boolean,eagerComplete:Boolean):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="mergePreferred[U&gt;:Out,M](Graph[SourceShape[U],M],Boolean,Boolean):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergePreferred[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],preferred:Boolean,eagerComplete:Boolean):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergePreferred</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="M">M</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergePreferred.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.mergePreferred.M" class="extype">M</span>]</span>, <span name="preferred">preferred: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergePreferred.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Merge two sources.</p><div class="fullcomment"><div class="comment cmt"><p>Merge two sources. Prefer one source if both sources have elements ready.</p><p><b>emits</b> when one of the inputs has an element available. If multiple have elements available, prefer the 'right' one when 'preferred' is 'true', or the 'left' one when 'preferred' is 'false'.</p><p><b>backpressures</b> when downstream backpressures</p><p><b>completes</b> when all upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>Annotations</dt><dd><span class="name">@nowarn</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergePreferredMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergePreferredMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],preferred:Boolean,eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="mergePreferredMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2],Boolean,Boolean)((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergePreferredMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],preferred:Boolean,eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergePreferredMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePreferredMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePreferredMat.Mat2" class="extype">Mat2</span>]</span>, <span name="preferred">preferred: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="eagerClose">eagerClose: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePreferredMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePreferredMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePreferredMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePreferredMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Merge two sources.</p><div class="fullcomment"><div class="comment cmt"><p>Merge two sources. Prefer one source if both sources have elements ready.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#mergePreferred[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],preferred:Boolean,eagerComplete:Boolean):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#mergePreferred" id="org.apache.pekko.stream.scaladsl.Source#mergePreferred" class="extmbr">#mergePreferred</a>
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergePrioritized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergePrioritized[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],leftPriority:Int,rightPriority:Int,eagerComplete:Boolean):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="mergePrioritized[U&gt;:Out,M](Graph[SourceShape[U],M],Int,Int,Boolean):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergePrioritized[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M],leftPriority:Int,rightPriority:Int,eagerComplete:Boolean):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergePrioritized</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="M">M</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergePrioritized.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.mergePrioritized.M" class="extype">M</span>]</span>, <span name="leftPriority">leftPriority: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="rightPriority">rightPriority: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergePrioritized.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Merge two sources.</p><div class="fullcomment"><div class="comment cmt"><p>Merge two sources. Prefer the sources depending on the 'priority' parameters.</p><p><b>emits</b> when one of the inputs has an element available, preferring inputs based on the 'priority' parameters if both have elements available</p><p><b>backpressures</b> when downstream backpressures</p><p><b>completes</b> when both upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergePrioritizedMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergePrioritizedMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],leftPriority:Int,rightPriority:Int,eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="mergePrioritizedMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2],Int,Int,Boolean)((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergePrioritizedMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],leftPriority:Int,rightPriority:Int,eagerClose:Boolean)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergePrioritizedMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePrioritizedMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePrioritizedMat.Mat2" class="extype">Mat2</span>]</span>, <span name="leftPriority">leftPriority: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="rightPriority">rightPriority: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="eagerClose">eagerClose: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePrioritizedMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePrioritizedMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePrioritizedMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergePrioritizedMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Merge two sources.</p><div class="fullcomment"><div class="comment cmt"><p>Merge two sources. Prefer the sources depending on the 'priority' parameters.</p><p>It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergeSorted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeSorted[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M])(implicitord:Ordering[U]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="mergeSorted[U&gt;:Out,M](Graph[SourceShape[U],M])(Ordering[U]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergeSorted[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M])(implicitord:Ordering[U]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergeSorted</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="M">M</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeSorted.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeSorted.M" class="extype">M</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ord">ord: <a href="https://www.scala-lang.org/api/2.13.8/scala/math/Ordering.html#scala.math.Ordering" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">Ordering</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeSorted.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.mergeSorted.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking always the smallest of the available elements (waiting for one element from each side
to be available).</p><div class="fullcomment"><div class="comment cmt"><p>Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking always the smallest of the available elements (waiting for one element from each side
to be available). This means that possible contiguity of the input streams is not exploited to avoid
waiting for elements, this merge will block when one of the inputs does not have more elements (and
does not complete).</p><p><b>Emits when</b> all of the inputs have an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstreams complete</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#mergeSortedMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeSortedMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3)(implicitord:Ordering[U]):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="mergeSortedMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3)(Ordering[U]):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#mergeSortedMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3)(implicitord:Ordering[U]):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">mergeSortedMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeSortedMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeSortedMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeSortedMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeSortedMat.Mat3" class="extype">Mat3</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ord">ord: <a href="https://www.scala-lang.org/api/2.13.8/scala/math/Ordering.html#scala.math.Ordering" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">Ordering</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeSortedMat.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeSortedMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.mergeSortedMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking always the smallest of the available elements (waiting for one element from each side
to be available).</p><div class="fullcomment"><div class="comment cmt"><p>Merge the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, taking elements as they arrive from input streams,
picking always the smallest of the available elements (waiting for one element from each side
to be available). This means that possible contiguity of the input streams is not exploited to avoid
waiting for elements, this merge will block when one of the inputs does not have more elements (and
does not complete).
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#mergeSorted[U&gt;:Out,M](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],M])(implicitord:Ordering[U]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#mergeSorted" id="org.apache.pekko.stream.scaladsl.Source#mergeSorted" class="extmbr">#mergeSorted</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#monitor" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monitor:FlowOpsMat.this.ReprMat[Out,(Mat,org.apache.pekko.stream.FlowMonitor[Out])]" class="anchorToMember"></a><a id="monitor:Source[T,(NotUsed,FlowMonitor[T])]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#monitor:FlowOpsMat.this.ReprMat[Out,(Mat,org.apache.pekko.stream.FlowMonitor[Out])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">monitor</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <a href="FlowMonitor.html" name="org.apache.pekko.stream.FlowMonitor" id="org.apache.pekko.stream.FlowMonitor" class="extype">FlowMonitor</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>])]</span></span><p class="shortcomment cmt">Materializes to <code>(Mat, FlowMonitor[Out])</code>, which is unlike most other operators (!),
in which usually the default materialized value keeping semantics is to keep the left value
(by passing <code>Keep.left()</code> to a <code>*Mat</code> version of a method).</p><div class="fullcomment"><div class="comment cmt"><p>Materializes to <code>(Mat, FlowMonitor[Out])</code>, which is unlike most other operators (!),
in which usually the default materialized value keeping semantics is to keep the left value
(by passing <code>Keep.left()</code> to a <code>*Mat</code> version of a method). This operator is an exception from
that rule and keeps both values since dropping its sole purpose is to introduce that materialized value.</p><p>The <code>FlowMonitor[Out]</code> allows monitoring of the current flow. All events are propagated
by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
event, and may therefor affect performance.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#monitorMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monitorMat[Mat2](combine:(Mat,org.apache.pekko.stream.FlowMonitor[Out])=&gt;Mat2):FlowOpsMat.this.ReprMat[Out,Mat2]" class="anchorToMember"></a><a id="monitorMat[Mat2]((NotUsed,FlowMonitor[T])=&gt;Mat2):Source[T,Mat2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#monitorMat[Mat2](combine:(Mat,org.apache.pekko.stream.FlowMonitor[Out])=&gt;Mat2):FlowOpsMat.this.ReprMat[Out,Mat2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">monitorMat</span><span class="tparams">[<span name="Mat2">Mat2</span>]</span><span class="params">(<span name="combine">combine: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <a href="FlowMonitor.html" name="org.apache.pekko.stream.FlowMonitor" id="org.apache.pekko.stream.FlowMonitor" class="extype">FlowMonitor</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.monitorMat.Mat2" class="extype">Mat2</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.monitorMat.Mat2" class="extype">Mat2</span>]</span></span><p class="shortcomment cmt">Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow.</p><div class="fullcomment"><div class="comment cmt"><p>Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow. All events are propagated
by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
event, and may therefor affect performance.</p><p>The <code>combine</code> function is used to combine the <code>FlowMonitor</code> with this flow's materialized value.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#named" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="named(name:String):Source.this.Repr[Out]" class="anchorToMember"></a><a id="named(String):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#named(name:String):Source.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">named</span><span class="params">(<span name="name">name: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Add a <code><code>name</code></code> attribute to this Source.</p><div class="fullcomment"><div class="comment cmt"><p>Add a <code><code>name</code></code> attribute to this Source.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a> → <a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="ne(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#orElse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="orElse[U&gt;:Out,Mat2](secondary:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="orElse[U&gt;:Out,Mat2](Graph[SourceShape[U],Mat2]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#orElse[U&gt;:Out,Mat2](secondary:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">orElse</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>]</span><span class="params">(<span name="secondary">secondary: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.orElse.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.orElse.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.orElse.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Provides a secondary source that will be consumed if this stream completes without any
elements passing by.</p><div class="fullcomment"><div class="comment cmt"><p>Provides a secondary source that will be consumed if this stream completes without any
elements passing by. As soon as the first element comes through this stream, the alternative
will be cancelled.</p><p>Note that this Flow will be materialized together with the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> and just kept
from producing elements by asserting back-pressure until its time comes or it gets
cancelled.</p><p>On errors the operator is failed regardless of source of the error.</p><p><b>Emits when</b> element is available from first stream or first stream closed without emitting any elements and an element
                 is available from the second stream</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> the primary stream completes after emitting at least one element, when the primary stream completes
                     without emitting and the secondary stream already has completed or when the secondary stream completes</p><p><b>Cancels when</b> downstream cancels and additionally the alternative is cancelled as soon as an element passes
                   by from this stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#orElseMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="orElseMat[U&gt;:Out,Mat2,Mat3](secondary:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="orElseMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#orElseMat[U&gt;:Out,Mat2,Mat3](secondary:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">orElseMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="secondary">secondary: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.orElseMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.orElseMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.orElseMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.orElseMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.orElseMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.orElseMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Provides a secondary source that will be consumed if this stream completes without any
elements passing by.</p><div class="fullcomment"><div class="comment cmt"><p>Provides a secondary source that will be consumed if this stream completes without any
elements passing by. As soon as the first element comes through this stream, the alternative
will be cancelled.</p><p>Note that this Flow will be materialized together with the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> and just kept
from producing elements by asserting back-pressure until its time comes or it gets
cancelled.</p><p>On errors the operator is failed regardless of source of the error.</p><p><b>Emits when</b> element is available from first stream or first stream closed without emitting any elements and an element
                 is available from the second stream</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> the primary stream completes after emitting at least one element, when the primary stream completes
                     without emitting and the secondary stream already has completed or when the secondary stream completes</p><p><b>Cancels when</b> downstream cancels and additionally the alternative is cancelled as soon as an element passes
                   by from this stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#preMaterialize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="preMaterialize()(implicitmaterializer:org.apache.pekko.stream.Materializer):(Mat,Source.this.ReprMat[Out,org.apache.pekko.NotUsed])" class="anchorToMember"></a><a id="preMaterialize()(Materializer):(NotUsed,Source[T,NotUsed])" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#preMaterialize()(implicitmaterializer:org.apache.pekko.stream.Materializer):(Mat,Source.this.ReprMat[Out,org.apache.pekko.NotUsed])" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">preMaterialize</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="materializer">materializer: <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">Materializer</a></span>)</span><span class="result">: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>])</span></span><p class="shortcomment cmt">Materializes this Source, immediately returning (1) its materialized value, and (2) a new Source
that can be used to consume elements from the newly materialized Source.</p><div class="fullcomment"><div class="comment cmt"><p>Materializes this Source, immediately returning (1) its materialized value, and (2) a new Source
that can be used to consume elements from the newly materialized Source.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#prefixAndTail" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="prefixAndTail[U&gt;:Out](n:Int):FlowOps.this.Repr[(Seq[Out],org.apache.pekko.stream.scaladsl.Source[U,org.apache.pekko.NotUsed])]" class="anchorToMember"></a><a id="prefixAndTail[U&gt;:Out](Int):Source[(Seq[T],Source[U,NotUsed]),NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#prefixAndTail[U&gt;:Out](n:Int):FlowOps.this.Repr[(Seq[Out],org.apache.pekko.stream.scaladsl.Source[U,org.apache.pekko.NotUsed])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">prefixAndTail</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.prefixAndTail.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]), <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Takes up to <code>n</code> elements from the stream (less than <code>n</code> only if the upstream completes before emitting <code>n</code> elements)
and returns a pair containing a strict sequence of the taken element
and a stream representing the remaining elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes up to <code>n</code> elements from the stream (less than <code>n</code> only if the upstream completes before emitting <code>n</code> elements)
and returns a pair containing a strict sequence of the taken element
and a stream representing the remaining elements. If <i>n</i> is zero or negative, then this will return a pair
of an empty collection and a stream containing the whole upstream unchanged.</p><p>In case of an upstream error, depending on the current state</p><ul><li>the master stream signals the error if less than <code>n</code> elements has been seen, and therefore the substream
   has not yet been emitted</li><li>the tail substream signals the error after the prefix and tail has been emitted by the main stream
   (at that point the main stream has already completed)</li></ul><p><b>Emits when</b> the configured number of prefix elements are available. Emits this prefix, and the rest
as a substream</p><p><b>Backpressures when</b> downstream backpressures or substream backpressures</p><p><b>Completes when</b> prefix elements have been consumed and substream has been consumed</p><p><b>Cancels when</b> downstream cancels or substream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#prepend" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="prepend[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="prepend[U&gt;:Out,Mat2](Graph[SourceShape[U],Mat2]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#prepend[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">prepend</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.prepend.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.prepend.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.prepend.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><div class="fullcomment"><div class="comment cmt"><p>Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is materialized together with this Flow and is "detached" meaning
in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
(so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).</p><p>This flow will then be kept from producing elements by asserting back-pressure until its time comes.</p><p>When needing a prepend operator that is not detached use <a href="scaladsl/Source.html#prependLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#prependLazy" id="org.apache.pekko.stream.scaladsl.Source#prependLazy" class="extmbr">#prependLazy</a></p><p><b>Emits when</b> element is available from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> or from current stream when the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is completed</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#prependLazy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="prependLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" class="anchorToMember"></a><a id="prependLazy[U&gt;:Out,Mat2](Graph[SourceShape[U],Mat2]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#prependLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">prependLazy</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.prependLazy.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOps.prependLazy.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.prependLazy.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><div class="fullcomment"><div class="comment cmt"><p>Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is materialized together with this Flow and will then be kept from producing elements
by asserting back-pressure until its time comes.</p><p>When needing a prepend operator that is also detached use <a href="scaladsl/Source.html#prepend[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#prepend" id="org.apache.pekko.stream.scaladsl.Source#prepend" class="extmbr">#prepend</a></p><p>If the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> gets upstream error - no elements from this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> will be pulled.</p><p><b>Emits when</b> element is available from the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> or from current stream when the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is completed</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#prependLazyMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="prependLazyMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="prependLazyMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#prependLazyMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">prependLazyMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependLazyMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependLazyMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependLazyMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependLazyMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependLazyMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependLazyMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><div class="fullcomment"><div class="comment cmt"><p>Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><p>Note that the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> is materialized together with this Flow and is "detached" meaning
in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
(so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).</p><p>This flow will then be kept from producing elements by asserting back-pressure until its time comes.</p><p>When needing a prepend operator that is not detached use <a href="scaladsl/Source.html#prependLazyMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" name="org.apache.pekko.stream.scaladsl.Source#prependLazyMat" id="org.apache.pekko.stream.scaladsl.Source#prependLazyMat" class="extmbr">#prependLazyMat</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#prependLazy[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#prependLazy" id="org.apache.pekko.stream.scaladsl.Source#prependLazy" class="extmbr">#prependLazy</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#prependMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="prependMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" class="anchorToMember"></a><a id="prependMat[U&gt;:Out,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[U,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#prependMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">prependMat</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependMat.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.prependMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><div class="fullcomment"><div class="comment cmt"><p>Prepend the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>, meaning that before elements
are generated from this Flow, the Source's elements will be produced until it
is exhausted, at which point Flow elements will start being produced.</p><p>Note that this Flow will be materialized together with the <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> and just kept
from producing elements by asserting back-pressure until its time comes.</p><p>If the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> gets upstream error - no elements from this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> will be pulled.</p><p>When needing a concat operator that is not detached use <a href="scaladsl/Source.html#prependLazyMat[U&gt;:Out,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[U,Mat3]" name="org.apache.pekko.stream.scaladsl.Source#prependLazyMat" id="org.apache.pekko.stream.scaladsl.Source#prependLazyMat" class="extmbr">#prependLazyMat</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#prepend[U&gt;:Out,Mat2](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2]):FlowOps.this.Repr[U]" name="org.apache.pekko.stream.scaladsl.Source#prepend" id="org.apache.pekko.stream.scaladsl.Source#prepend" class="extmbr">#prepend</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#recover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="recover[T&gt;:Out](pf:PartialFunction[Throwable,T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="recover[T&gt;:Out](PartialFunction[Throwable,T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#recover[T&gt;:Out](pf:PartialFunction[Throwable,T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">recover</span><span class="tparams">[<span name="T">T &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.8/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#java.lang.Throwable" name="java.lang.Throwable" id="java.lang.Throwable" class="extype">Throwable</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.recover.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.recover.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Recover allows to send last element on failure and gracefully complete the stream
Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.</p><div class="fullcomment"><div class="comment cmt"><p>Recover allows to send last element on failure and gracefully complete the stream
Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
This operator can recover the failure signal, but not the skipped elements, which will be dropped.</p><p>Throwing an exception inside <code>recover</code> _will_ be logged on ERROR level automatically.</p><p><b>Emits when</b> element is available from the upstream or upstream is failed and pf returns an element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or upstream failed with exception pf can handle</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#recoverWithRetries" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="recoverWithRetries[T&gt;:Out](attempts:Int,pf:PartialFunction[Throwable,org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],org.apache.pekko.NotUsed]]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="recoverWithRetries[T&gt;:Out](Int,PartialFunction[Throwable,Graph[SourceShape[T],NotUsed]]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#recoverWithRetries[T&gt;:Out](attempts:Int,pf:PartialFunction[Throwable,org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],org.apache.pekko.NotUsed]]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">recoverWithRetries</span><span class="tparams">[<span name="T">T &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="attempts">attempts: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.8/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#java.lang.Throwable" name="java.lang.Throwable" id="java.lang.Throwable" class="extype">Throwable</a>, <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.recoverWithRetries.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.recoverWithRetries.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">RecoverWithRetries allows to switch to alternative Source on flow failure.</p><div class="fullcomment"><div class="comment cmt"><p>RecoverWithRetries allows to switch to alternative Source on flow failure. It will stay in effect after
a failure has been recovered up to <code>attempts</code> number of times so that each time there is a failure
it is fed into the <code>pf</code> and a new Source may be materialized. Note that if you pass in 0, this won't
attempt to recover at all.</p><p>A negative <code>attempts</code> number is interpreted as "infinite", which results in the exact same behavior as <code>recoverWith</code>.</p><p>Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
This operator can recover the failure signal, but not the skipped elements, which will be dropped.</p><p>Throwing an exception inside <code>recoverWithRetries</code> _will_ be logged on ERROR level automatically.</p><p><b>Emits when</b> element is available from the upstream or upstream is failed and element is available
from alternative Source</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or upstream failed with exception pf can handle</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="param">attempts</dt><dd class="cmt"><p>Maximum number of retries or -1 to retry indefinitely</p></dd><dt class="param">pf</dt><dd class="cmt"><p>Receives the failure cause and returns the new Source to be materialized if any</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#reduce" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="reduce[T&gt;:Out](f:(T,T)=&gt;T):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="reduce[T&gt;:Out]((T,T)=&gt;T):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#reduce[T&gt;:Out](f:(T,T)=&gt;T):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">reduce</span><span class="tparams">[<span name="T">T &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.reduce.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.reduce.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.reduce.T" class="extype">T</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.reduce.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Similar to <code>fold</code> but uses first element as zero element.</p><div class="fullcomment"><div class="comment cmt"><p>Similar to <code>fold</code> but uses first element as zero element.
Applies the given function towards its current and next value,
yielding the next current value.</p><p>If the stream is empty (i.e. completes before signalling any elements),
the reduce operator will fail its downstream with a <span name="NoSuchElementException" class="extype">NoSuchElementException</span>,
which is semantically in-line with that Scala's standard library collections
do in such situations.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> upstream completes</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#fold[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#fold" id="org.apache.pekko.stream.scaladsl.FlowOps#fold" class="extmbr">FlowOps.fold</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#run" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="run()(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[org.apache.pekko.Done]" class="anchorToMember"></a><a id="run()(Materializer):Future[Done]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#run()(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[org.apache.pekko.Done]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">run</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="materializer">materializer: <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">Materializer</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="../Done.html" name="org.apache.pekko.Done" id="org.apache.pekko.Done" class="extype">Done</a>]</span></span><p class="shortcomment cmt">Connect this <code>Source</code> to the <code>Sink.ignore</code> and run it.</p><div class="fullcomment"><div class="comment cmt"><p>Connect this <code>Source</code> to the <code>Sink.ignore</code> and run it. Elements from the stream will be consumed and discarded.</p><p>Note that the <code>ActorSystem</code> can be used as the implicit <code>materializer</code> parameter to use the
<a href="SystemMaterializer.html" name="org.apache.pekko.stream.SystemMaterializer" id="org.apache.pekko.stream.SystemMaterializer" class="extype">pekko.stream.SystemMaterializer</a> for running the stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#runFold" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runFold[U](zero:U)(f:(U,Out)=&gt;U)(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[U]" class="anchorToMember"></a><a id="runFold[U](U)((U,T)=&gt;U)(Materializer):Future[U]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#runFold[U](zero:U)(f:(U,Out)=&gt;U)(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">runFold</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="zero">zero: <span name="org.apache.pekko.stream.scaladsl.Source.runFold.U" class="extype">U</span></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.Source.runFold.U" class="extype">U</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.Source.runFold.U" class="extype">U</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="materializer">materializer: <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">Materializer</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.Source.runFold.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Shortcut for running this <code>Source</code> with a fold function.</p><div class="fullcomment"><div class="comment cmt"><p>Shortcut for running this <code>Source</code> with a fold function.
The given function is invoked for every received element, giving it its previous
output (or the given <code>zero</code> value) and the element as input.
The returned <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">scala.concurrent.Future</a> will be completed with value of the final
function evaluation when the input stream ends, or completed with <code>Failure</code>
if there is a failure signaled in the stream.</p><p>Note that the <code>ActorSystem</code> can be used as the implicit <code>materializer</code> parameter to use the
<a href="SystemMaterializer.html" name="org.apache.pekko.stream.SystemMaterializer" id="org.apache.pekko.stream.SystemMaterializer" class="extype">pekko.stream.SystemMaterializer</a> for running the stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#runFoldAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runFoldAsync[U](zero:U)(f:(U,Out)=&gt;scala.concurrent.Future[U])(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[U]" class="anchorToMember"></a><a id="runFoldAsync[U](U)((U,T)=&gt;Future[U])(Materializer):Future[U]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#runFoldAsync[U](zero:U)(f:(U,Out)=&gt;scala.concurrent.Future[U])(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">runFoldAsync</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="zero">zero: <span name="org.apache.pekko.stream.scaladsl.Source.runFoldAsync.U" class="extype">U</span></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.Source.runFoldAsync.U" class="extype">U</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.Source.runFoldAsync.U" class="extype">U</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="materializer">materializer: <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">Materializer</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.Source.runFoldAsync.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Shortcut for running this <code>Source</code> with a foldAsync function.</p><div class="fullcomment"><div class="comment cmt"><p>Shortcut for running this <code>Source</code> with a foldAsync function.
The given function is invoked for every received element, giving it its previous
output (or the given <code>zero</code> value) and the element as input.
The returned <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">scala.concurrent.Future</a> will be completed with value of the final
function evaluation when the input stream ends, or completed with <code>Failure</code>
if there is a failure signaled in the stream.</p><p>Note that the <code>ActorSystem</code> can be used as the implicit <code>materializer</code> parameter to use the
<a href="SystemMaterializer.html" name="org.apache.pekko.stream.SystemMaterializer" id="org.apache.pekko.stream.SystemMaterializer" class="extype">pekko.stream.SystemMaterializer</a> for running the stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#runForeach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runForeach(f:Out=&gt;Unit)(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[org.apache.pekko.Done]" class="anchorToMember"></a><a id="runForeach((T)=&gt;Unit)(Materializer):Future[Done]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#runForeach(f:Out=&gt;Unit)(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[org.apache.pekko.Done]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">runForeach</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="materializer">materializer: <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">Materializer</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="../Done.html" name="org.apache.pekko.Done" id="org.apache.pekko.Done" class="extype">Done</a>]</span></span><p class="shortcomment cmt">Shortcut for running this <code>Source</code> with a foreach procedure.</p><div class="fullcomment"><div class="comment cmt"><p>Shortcut for running this <code>Source</code> with a foreach procedure. The given procedure is invoked
for each received element.
The returned <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">scala.concurrent.Future</a> will be completed with <code>Success</code> when reaching the
normal end of the stream, or completed with <code>Failure</code> if there is a failure signaled in
the stream.</p><p>Note that the <code>ActorSystem</code> can be used as the implicit <code>materializer</code> parameter to use the
<a href="SystemMaterializer.html" name="org.apache.pekko.stream.SystemMaterializer" id="org.apache.pekko.stream.SystemMaterializer" class="extype">pekko.stream.SystemMaterializer</a> for running the stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#runReduce" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runReduce[U&gt;:Out](f:(U,U)=&gt;U)(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[U]" class="anchorToMember"></a><a id="runReduce[U&gt;:Out]((U,U)=&gt;U)(Materializer):Future[U]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#runReduce[U&gt;:Out](f:(U,U)=&gt;U)(implicitmaterializer:org.apache.pekko.stream.Materializer):scala.concurrent.Future[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">runReduce</span><span class="tparams">[<span name="U">U &gt;: <span name="org.apache.pekko.stream.scaladsl.Source.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.Source.runReduce.U" class="extype">U</span>, <span name="org.apache.pekko.stream.scaladsl.Source.runReduce.U" class="extype">U</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.Source.runReduce.U" class="extype">U</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="materializer">materializer: <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">Materializer</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.Source.runReduce.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Shortcut for running this <code>Source</code> with a reduce function.</p><div class="fullcomment"><div class="comment cmt"><p>Shortcut for running this <code>Source</code> with a reduce function.
The given function is invoked for every received element, giving it its previous
output (from the second element) and the element as input.
The returned <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">scala.concurrent.Future</a> will be completed with value of the final
function evaluation when the input stream ends, or completed with <code>Failure</code>
if there is a failure signaled in the stream.</p><p>If the stream is empty (i.e. completes before signalling any elements),
the reduce operator will fail its downstream with a <span name="NoSuchElementException" class="extype">NoSuchElementException</span>,
which is semantically in-line with that Scala's standard library collections
do in such situations.</p><p>Note that the <code>ActorSystem</code> can be used as the implicit <code>materializer</code> parameter to use the
<a href="SystemMaterializer.html" name="org.apache.pekko.stream.SystemMaterializer" id="org.apache.pekko.stream.SystemMaterializer" class="extype">pekko.stream.SystemMaterializer</a> for running the stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#runWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runWith[Mat2](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(implicitmaterializer:org.apache.pekko.stream.Materializer):Mat2" class="anchorToMember"></a><a id="runWith[Mat2](Graph[SinkShape[T],Mat2])(Materializer):Mat2" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#runWith[Mat2](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(implicitmaterializer:org.apache.pekko.stream.Materializer):Mat2" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">runWith</span><span class="tparams">[<span name="Mat2">Mat2</span>]</span><span class="params">(<span name="sink">sink: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.Source.runWith.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="materializer">materializer: <a href="Materializer.html" name="org.apache.pekko.stream.Materializer" id="org.apache.pekko.stream.Materializer" class="extype">Materializer</a></span>)</span><span class="result">: <span name="org.apache.pekko.stream.scaladsl.Source.runWith.Mat2" class="extype">Mat2</span></span></span><p class="shortcomment cmt">Connect this <code>Source</code> to a <code>Sink</code> and run it.</p><div class="fullcomment"><div class="comment cmt"><p>Connect this <code>Source</code> to a <code>Sink</code> and run it. The returned value is the materialized value
of the <code>Sink</code>, e.g. the <code>Publisher</code> of a <span name="pekko.stream.scaladsl.Sink#publisher" class="extype">pekko.stream.scaladsl.Sink#publisher</span>.</p><p>Note that the <code>ActorSystem</code> can be used as the implicit <code>materializer</code> parameter to use the
<a href="SystemMaterializer.html" name="org.apache.pekko.stream.SystemMaterializer" id="org.apache.pekko.stream.SystemMaterializer" class="extype">pekko.stream.SystemMaterializer</a> for running the stream.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#scan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scan[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="scan[T](T)((T,T)=&gt;T):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#scan[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">scan</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="zero">zero: <span name="org.apache.pekko.stream.scaladsl.FlowOps.scan.T" class="extype">T</span></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.scan.T" class="extype">T</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.scan.T" class="extype">T</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.scan.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Similar to <code>fold</code> but is not a terminal operation,
emits its current value which starts at <code>zero</code> and then
applies the current and next value to the given function <code>f</code>,
emitting the next current value.</p><div class="fullcomment"><div class="comment cmt"><p>Similar to <code>fold</code> but is not a terminal operation,
emits its current value which starts at <code>zero</code> and then
applies the current and next value to the given function <code>f</code>,
emitting the next current value.</p><p>If the function <code>f</code> throws an exception and the supervision decision is
<a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> current value starts at <code>zero</code> again
the stream will continue.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p>Note that the <code>zero</code> value must be immutable.</p><p><b>Emits when</b> the function scanning the element returns a new element</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#scanAsync[T](zero:T)(f:(T,Out)=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#scanAsync" id="org.apache.pekko.stream.scaladsl.FlowOps#scanAsync" class="extmbr">FlowOps.scanAsync</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#scanAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanAsync[T](zero:T)(f:(T,Out)=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="scanAsync[T](T)((T,T)=&gt;Future[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#scanAsync[T](zero:T)(f:(T,Out)=&gt;scala.concurrent.Future[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">scanAsync</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="zero">zero: <span name="org.apache.pekko.stream.scaladsl.FlowOps.scanAsync.T" class="extype">T</span></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.scanAsync.T" class="extype">T</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.scanAsync.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.scanAsync.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Similar to <code>scan</code> but with an asynchronous function,
emits its current value which starts at <code>zero</code> and then
applies the current and next value to the given function <code>f</code>,
emitting a <code>Future</code> that resolves to the next current value.</p><div class="fullcomment"><div class="comment cmt"><p>Similar to <code>scan</code> but with an asynchronous function,
emits its current value which starts at <code>zero</code> and then
applies the current and next value to the given function <code>f</code>,
emitting a <code>Future</code> that resolves to the next current value.</p><p>If the function <code>f</code> throws an exception and the supervision decision is
<a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a> current value starts at <code>zero</code> again
the stream will continue.</p><p>If the function <code>f</code> throws an exception and the supervision decision is
<a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a> current value starts at the previous
current value, or zero when it doesn't have one, and the stream will continue.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p>Note that the <code>zero</code> value must be immutable.</p><p><b>Emits when</b> the future returned by <code>f</code> completes</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes and the last future returned by <code>f</code> completes</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#scan[T](zero:T)(f:(T,Out)=&gt;T):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#scan" id="org.apache.pekko.stream.scaladsl.FlowOps#scan" class="extmbr">FlowOps.scan</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#shape" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="shape:org.apache.pekko.stream.SourceShape[Out]" class="anchorToMember"></a><a id="shape:SourceShape[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#shape:org.apache.pekko.stream.SourceShape[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="implicit">shape</span><span class="result">: <a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">The shape of a graph is all that is externally visible: its inlets and outlets.</p><div class="fullcomment"><div class="comment cmt"><p>The shape of a graph is all that is externally visible: its inlets and outlets.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#sliding" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sliding(n:Int,step:Int):FlowOps.this.Repr[Seq[Out]]" class="anchorToMember"></a><a id="sliding(Int,Int):Source[Seq[T],NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#sliding(n:Int,step:Int):FlowOps.this.Repr[Seq[Out]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">sliding</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="step">step: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">1</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<a href="https://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Seq.html#scala.collection.immutable.Seq" name="scala.collection.immutable.Seq" id="scala.collection.immutable.Seq" class="extype">Seq</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Apply a sliding window over the stream and return the windows as groups of elements, with the last group
possibly smaller than requested due to end-of-stream.</p><div class="fullcomment"><div class="comment cmt"><p>Apply a sliding window over the stream and return the windows as groups of elements, with the last group
possibly smaller than requested due to end-of-stream.</p><p><code>n</code> must be positive, otherwise IllegalArgumentException is thrown.
<code>step</code> must be positive, otherwise IllegalArgumentException is thrown.</p><p><b>Emits when</b> enough elements have been collected within the window or upstream completed</p><p><b>Backpressures when</b> a window has been assembled and downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#splitAfter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="splitAfter(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" class="anchorToMember"></a><a id="splitAfter((T)=&gt;Boolean):SubFlow[T,NotUsed,[+O]Source[O,NotUsed],RunnableGraph[NotUsed]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#splitAfter(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">splitAfter</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, [+O]<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.Repr.&lt;local Repr&gt;.O" class="extype">O</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>], <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span></span><p class="shortcomment cmt">This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams.</p><div class="fullcomment"><div class="comment cmt"><p>This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams. It *ends* the current substream when the
predicate is true.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#splitAfter(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" name="org.apache.pekko.stream.scaladsl.Source#splitAfter" id="org.apache.pekko.stream.scaladsl.Source#splitAfter" class="extmbr">#splitAfter</a></p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#splitAfter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="splitAfter(substreamCancelStrategy:org.apache.pekko.stream.SubstreamCancelStrategy)(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" class="anchorToMember"></a><a id="splitAfter(SubstreamCancelStrategy)((T)=&gt;Boolean):SubFlow[T,NotUsed,[+O]Source[O,NotUsed],RunnableGraph[NotUsed]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#splitAfter(substreamCancelStrategy:org.apache.pekko.stream.SubstreamCancelStrategy)(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">splitAfter</span><span class="params">(<span name="substreamCancelStrategy">substreamCancelStrategy: <a href="SubstreamCancelStrategy.html" name="org.apache.pekko.stream.SubstreamCancelStrategy" id="org.apache.pekko.stream.SubstreamCancelStrategy" class="extype">SubstreamCancelStrategy</a></span>)</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, [+O]<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.Repr.&lt;local Repr&gt;.O" class="extype">O</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>], <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span></span><p class="shortcomment cmt">This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams.</p><div class="fullcomment"><div class="comment cmt"><p>This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams. It *ends* the current substream when the
predicate is true. This means that for the following series of predicate values,
three substreams will be produced with lengths 2, 2, and 3:</p><pre><span class="kw">false</span>, <span class="kw">true</span>,        <span class="cmt">// elements go into first substream</span>
<span class="kw">false</span>, <span class="kw">true</span>,        <span class="cmt">// elements go into second substream</span>
<span class="kw">false</span>, <span class="kw">false</span>, <span class="kw">true</span>  <span class="cmt">// elements go into third substream</span></pre><p>The object returned from this method is not a normal <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> or <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>,
it is a <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>. This means that after this operator all transformations
are applied to all encountered substreams in the same fashion. Substream mode
is exited either by closing the substream (i.e. connecting it to a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>)
or by merging the substreams back together; see the <code>to</code> and <code>mergeBack</code> methods
on <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a> for more information.</p><p>It is important to note that the substreams also propagate back-pressure as
any other stream, which means that blocking one substream will block the <code>splitAfter</code>
operator itself—and thereby all substreams—once all internal or
explicit buffers are filled.</p><p>If the split predicate <code>p</code> throws an exception and the supervision decision
is <a href="Supervision$$Stop$.html" name="org.apache.pekko.stream.Supervision.Stop" id="org.apache.pekko.stream.Supervision.Stop" class="extype">pekko.stream.Supervision.Stop</a> the stream and substreams will be completed
with failure.</p><p>If the split predicate <code>p</code> throws an exception and the supervision decision
is <a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a> or <a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a>
the element is dropped and the stream and substreams continue.</p><p><b>Emits when</b> an element passes through. When the provided predicate is true it emits the element
and opens a new substream for subsequent element</p><p><b>Backpressures when</b> there is an element pending for the next substream, but the previous
is not fully consumed yet, or the substream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels and substreams cancel on <code>SubstreamCancelStrategy.drain</code>, downstream
cancels or any substream cancels on <code>SubstreamCancelStrategy.propagate</code></p><p>See also <a href="scaladsl/FlowOps.html#splitWhen(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" name="org.apache.pekko.stream.scaladsl.FlowOps#splitWhen" id="org.apache.pekko.stream.scaladsl.FlowOps#splitWhen" class="extmbr">FlowOps.splitWhen</a>.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#splitWhen" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="splitWhen(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" class="anchorToMember"></a><a id="splitWhen((T)=&gt;Boolean):SubFlow[T,NotUsed,[+O]Source[O,NotUsed],RunnableGraph[NotUsed]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#splitWhen(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">splitWhen</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, [+O]<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.Repr.&lt;local Repr&gt;.O" class="extype">O</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>], <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span></span><p class="shortcomment cmt">This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams, always beginning a new one with
the current element if the given predicate returns true for it.</p><div class="fullcomment"><div class="comment cmt"><p>This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams, always beginning a new one with
the current element if the given predicate returns true for it.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#splitWhen(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" name="org.apache.pekko.stream.scaladsl.Source#splitWhen" id="org.apache.pekko.stream.scaladsl.Source#splitWhen" class="extmbr">#splitWhen</a></p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#splitWhen" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="splitWhen(substreamCancelStrategy:org.apache.pekko.stream.SubstreamCancelStrategy)(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" class="anchorToMember"></a><a id="splitWhen(SubstreamCancelStrategy)((T)=&gt;Boolean):SubFlow[T,NotUsed,[+O]Source[O,NotUsed],RunnableGraph[NotUsed]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#splitWhen(substreamCancelStrategy:org.apache.pekko.stream.SubstreamCancelStrategy)(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">splitWhen</span><span class="params">(<span name="substreamCancelStrategy">substreamCancelStrategy: <a href="SubstreamCancelStrategy.html" name="org.apache.pekko.stream.SubstreamCancelStrategy" id="org.apache.pekko.stream.SubstreamCancelStrategy" class="extype">SubstreamCancelStrategy</a></span>)</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, [+O]<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.Repr.&lt;local Repr&gt;.O" class="extype">O</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>], <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span></span><p class="shortcomment cmt">This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams, always beginning a new one with
the current element if the given predicate returns true for it.</p><div class="fullcomment"><div class="comment cmt"><p>This operation applies the given predicate to all incoming elements and
emits them to a stream of output streams, always beginning a new one with
the current element if the given predicate returns true for it. This means
that for the following series of predicate values, three substreams will
be produced with lengths 1, 2, and 3:</p><pre><span class="kw">false</span>,             <span class="cmt">// element goes into first substream</span>
<span class="kw">true</span>, <span class="kw">false</span>,       <span class="cmt">// elements go into second substream</span>
<span class="kw">true</span>, <span class="kw">false</span>, <span class="kw">false</span> <span class="cmt">// elements go into third substream</span></pre><p>In case the *first* element of the stream matches the predicate, the first
substream emitted by splitWhen will start from that element. For example:</p><pre><span class="kw">true</span>, <span class="kw">false</span>, <span class="kw">false</span> <span class="cmt">// first substream starts from the split-by element</span>
<span class="kw">true</span>, <span class="kw">false</span>        <span class="cmt">// subsequent substreams operate the same way</span></pre><p>The object returned from this method is not a normal <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> or <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a>,
it is a <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a>. This means that after this operator all transformations
are applied to all encountered substreams in the same fashion. Substream mode
is exited either by closing the substream (i.e. connecting it to a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a>)
or by merging the substreams back together; see the <code>to</code> and <code>mergeBack</code> methods
on <a href="scaladsl/SubFlow.html" name="org.apache.pekko.stream.scaladsl.SubFlow" id="org.apache.pekko.stream.scaladsl.SubFlow" class="extype">SubFlow</a> for more information.</p><p>It is important to note that the substreams also propagate back-pressure as
any other stream, which means that blocking one substream will block the <code>splitWhen</code>
operator itself—and thereby all substreams—once all internal or
explicit buffers are filled.</p><p>If the split predicate <code>p</code> throws an exception and the supervision decision
is <a href="Supervision$$Stop$.html" name="org.apache.pekko.stream.Supervision.Stop" id="org.apache.pekko.stream.Supervision.Stop" class="extype">pekko.stream.Supervision.Stop</a> the stream and substreams will be completed
with failure.</p><p>If the split predicate <code>p</code> throws an exception and the supervision decision
is <a href="Supervision$$Resume$.html" name="org.apache.pekko.stream.Supervision.Resume" id="org.apache.pekko.stream.Supervision.Resume" class="extype">pekko.stream.Supervision.Resume</a> or <a href="Supervision$$Restart$.html" name="org.apache.pekko.stream.Supervision.Restart" id="org.apache.pekko.stream.Supervision.Restart" class="extype">pekko.stream.Supervision.Restart</a>
the element is dropped and the stream and substreams continue.</p><p><b>Emits when</b> an element for which the provided predicate is true, opening and emitting
a new substream for subsequent element</p><p><b>Backpressures when</b> there is an element pending for the next substream, but the previous
is not fully consumed yet, or the substream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels and substreams cancel on <code>SubstreamCancelStrategy.drain</code>, downstream
cancels or any substream cancels on <code>SubstreamCancelStrategy.propagate</code></p><p>See also <a href="scaladsl/FlowOps.html#splitAfter(p:Out=&gt;Boolean):org.apache.pekko.stream.scaladsl.SubFlow[Out,Mat,FlowOps.this.Repr,FlowOps.this.Closed]" name="org.apache.pekko.stream.scaladsl.FlowOps#splitAfter" id="org.apache.pekko.stream.scaladsl.FlowOps#splitAfter" class="extmbr">FlowOps.splitAfter</a>.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#statefulMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="statefulMap[S,T](create:()=&gt;S)(f:(S,Out)=&gt;(S,T),onComplete:S=&gt;Option[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="statefulMap[S,T](()=&gt;S)((S,T)=&gt;(S,T),(S)=&gt;Option[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#statefulMap[S,T](create:()=&gt;S)(f:(S,Out)=&gt;(S,T),onComplete:S=&gt;Option[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">statefulMap</span><span class="tparams">[<span name="S">S</span>, <span name="T">T</span>]</span><span class="params">(<span name="create">create: () =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMap.S" class="extype">S</span></span>)</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMap.S" class="extype">S</span>, <span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; (<span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMap.S" class="extype">S</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMap.T" class="extype">T</span>)</span>, <span name="onComplete">onComplete: (<span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMap.S" class="extype">S</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMap.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMap.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform each stream element with the help of a state.</p><div class="fullcomment"><div class="comment cmt"><p>Transform each stream element with the help of a state.</p><p>The state creation function is invoked once when the stream is materialized and the returned state is passed to
the mapping function for mapping the first element. The mapping function returns a mapped element to emit
downstream and a state to pass to the next mapping function. The state can be the same for each mapping return,
be a new immutable state but it is also safe to use a mutable state. The returned <code>T</code> MUST NOT be <code>null</code> as it is
illegal as stream element - according to the Reactive Streams specification.</p><p>For stateless variant see <a href="scaladsl/FlowOps.html#map[T](f:Out=&gt;T):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#map" id="org.apache.pekko.stream.scaladsl.FlowOps#map" class="extmbr">FlowOps.map</a>.</p><p>The <code>onComplete</code> function is called only once when the upstream or downstream finished, You can do some clean-up here,
and if the returned value is not empty, it will be emitted to the downstream if available, otherwise the value will be dropped.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the mapping function returns an element and downstream is ready to consume it</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>the type of the state</p></dd><dt class="tparam">T</dt><dd class="cmt"><p>the type of the output elements</p></dd><dt class="param">create</dt><dd class="cmt"><p>a function that creates the initial state</p></dd><dt class="param">f</dt><dd class="cmt"><p>a function that transforms the upstream element and the state into a pair of next state and output element</p></dd><dt class="param">onComplete</dt><dd class="cmt"><p>a function that transforms the ongoing state into an optional output element</p></dd></dl><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#statefulMapConcat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="statefulMapConcat[T](f:()=&gt;Out=&gt;IterableOnce[T]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="statefulMapConcat[T](()=&gt;(T)=&gt;IterableOnce[T]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#statefulMapConcat[T](f:()=&gt;Out=&gt;IterableOnce[T]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">statefulMapConcat</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: () =&gt; (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/collection/IterableOnce.html#scala.collection.IterableOnce" name="scala.collection.IterableOnce" id="scala.collection.IterableOnce" class="extype">IterableOnce</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMapConcat.T" class="extype">T</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.statefulMapConcat.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform each input element into an <code>Iterable</code> of output elements that is
then flattened into the output stream.</p><div class="fullcomment"><div class="comment cmt"><p>Transform each input element into an <code>Iterable</code> of output elements that is
then flattened into the output stream. The transformation is meant to be stateful,
which is enabled by creating the transformation function anew for every materialization —
the returned function will typically close over mutable objects to store state between
invocations. For the stateless variant see <a href="scaladsl/FlowOps.html#mapConcat[T](f:Out=&gt;IterableOnce[T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#mapConcat" id="org.apache.pekko.stream.scaladsl.FlowOps#mapConcat" class="extmbr">FlowOps.mapConcat</a>.</p><p>The returned <code>Iterable</code> MUST NOT contain <code>null</code> values,
as they are illegal as stream elements - according to the Reactive Streams specification.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the mapping function returns an element or there are still remaining elements
from the previously calculated collection</p><p><b>Backpressures when</b> downstream backpressures or there are still remaining elements from the
previously calculated collection</p><p><b>Completes when</b> upstream completes and all remaining elements has been emitted</p><p><b>Cancels when</b> downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#mapConcat[T](f:Out=&gt;IterableOnce[T]):FlowOps.this.Repr[T]" name="org.apache.pekko.stream.scaladsl.FlowOps#mapConcat" id="org.apache.pekko.stream.scaladsl.FlowOps#mapConcat" class="extmbr">FlowOps.mapConcat</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0" class="anchorToMember"></a><a id="synchronized[T0](=&gt;T0):T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#take" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="take(n:Long):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="take(Long):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#take(n:Long):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">take</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Terminate processing (and cancel the upstream publisher) after the given
number of elements.</p><div class="fullcomment"><div class="comment cmt"><p>Terminate processing (and cancel the upstream publisher) after the given
number of elements. Due to input buffering some elements may have been
requested from upstream publishers that will then not be processed downstream
of this step.</p><p>The stream will be completed without producing any elements if <code>n</code> is zero
or negative.</p><p><b>Emits when</b> the specified number of elements to take has not yet been reached</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> the defined number of elements has been taken or upstream completes</p><p><b>Cancels when</b> the defined number of elements has been taken or downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#limit(max:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limit" id="org.apache.pekko.stream.scaladsl.FlowOps#limit" class="extmbr">FlowOps.limit</a>, <a href="scaladsl/FlowOps.html#limitWeighted[T](max:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" class="extmbr">FlowOps.limitWeighted</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#takeWhile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeWhile(p:Out=&gt;Boolean,inclusive:Boolean):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="takeWhile((T)=&gt;Boolean,Boolean):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#takeWhile(p:Out=&gt;Boolean,inclusive:Boolean):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">takeWhile</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>, <span name="inclusive">inclusive: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Terminate processing (and cancel the upstream publisher) after predicate
returns false for the first time, including the first failed element iff inclusive is true
Due to input buffering some elements may have been requested from upstream publishers
that will then not be processed downstream of this step.</p><div class="fullcomment"><div class="comment cmt"><p>Terminate processing (and cancel the upstream publisher) after predicate
returns false for the first time, including the first failed element iff inclusive is true
Due to input buffering some elements may have been requested from upstream publishers
that will then not be processed downstream of this step.</p><p>The stream will be completed without producing any elements if predicate is false for
the first stream element.</p><p>Adheres to the <a href="ActorAttributes$$SupervisionStrategy.html" name="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" id="org.apache.pekko.stream.ActorAttributes.SupervisionStrategy" class="extype">ActorAttributes.SupervisionStrategy</a> attribute.</p><p><b>Emits when</b> the predicate is true</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> predicate returned false (or 1 after predicate returns false if <code>inclusive</code> or upstream completes</p><p><b>Cancels when</b> predicate returned false or downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#limit(max:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limit" id="org.apache.pekko.stream.scaladsl.FlowOps#limit" class="extmbr">FlowOps.limit</a>, <a href="scaladsl/FlowOps.html#limitWeighted[T](max:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" class="extmbr">FlowOps.limitWeighted</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#takeWhile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeWhile(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="takeWhile((T)=&gt;Boolean):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#takeWhile(p:Out=&gt;Boolean):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">takeWhile</span><span class="params">(<span name="p">p: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Terminate processing (and cancel the upstream publisher) after predicate
returns false for the first time,
Due to input buffering some elements may have been requested from upstream publishers
that will then not be processed downstream of this step.</p><div class="fullcomment"><div class="comment cmt"><p>Terminate processing (and cancel the upstream publisher) after predicate
returns false for the first time,
Due to input buffering some elements may have been requested from upstream publishers
that will then not be processed downstream of this step.</p><p>The stream will be completed without producing any elements if predicate is false for
the first stream element.</p><p><b>Emits when</b> the predicate is true</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> predicate returned false (or 1 after predicate returns false if <code>inclusive</code> or upstream completes</p><p><b>Cancels when</b> predicate returned false or downstream cancels</p><p>See also <a href="scaladsl/FlowOps.html#limit(max:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limit" id="org.apache.pekko.stream.scaladsl.FlowOps#limit" class="extmbr">FlowOps.limit</a>, <a href="scaladsl/FlowOps.html#limitWeighted[T](max:Long)(costFn:Out=&gt;Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" id="org.apache.pekko.stream.scaladsl.FlowOps#limitWeighted" class="extmbr">FlowOps.limitWeighted</a>
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#takeWithin" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeWithin(d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="takeWithin(FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#takeWithin(d:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">takeWithin</span><span class="params">(<span name="d">d: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Terminate processing (and cancel the upstream publisher) after the given
duration.</p><div class="fullcomment"><div class="comment cmt"><p>Terminate processing (and cancel the upstream publisher) after the given
duration. Due to input buffering some elements may have been
requested from upstream publishers that will then not be processed downstream
of this step.</p><p>Note that this can be combined with <a href="scaladsl/Source.html#take(n:Long):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#take" id="org.apache.pekko.stream.scaladsl.Source#take" class="extmbr">#take</a> to limit the number of elements
within the duration.</p><p><b>Emits when</b> an upstream element arrives</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or timer fires</p><p><b>Cancels when</b> downstream cancels or timer fires
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#throttle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="throttle(Int,FiniteDuration,Int,(T)=&gt;Int,ThrottleMode):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">throttle</span><span class="params">(<span name="cost">cost: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="per">per: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="maximumBurst">maximumBurst: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="costCalculation">costCalculation: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="mode">mode: <a href="ThrottleMode.html" name="org.apache.pekko.stream.ThrottleMode" id="org.apache.pekko.stream.ThrottleMode" class="extype">ThrottleMode</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Sends elements downstream with speed limited to <code>cost/per</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Sends elements downstream with speed limited to <code>cost/per</code>. Cost is
calculating for each element individually by calling <code>calculateCost</code> function.
This operator works for streams when elements have different cost(length).
Streams of <code>ByteString</code> for example.</p><p>Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
to allow some burstiness. Whenever stream wants to send an element, it takes as many
tokens from the bucket as element costs. If there isn't any, throttle waits until the
bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and started.</p><p>Parameter <code>mode</code> manages behavior when upstream is faster than throttle rate:</p><ul><li><a href="ThrottleMode$$Shaping$.html" name="org.apache.pekko.stream.ThrottleMode.Shaping" id="org.apache.pekko.stream.ThrottleMode.Shaping" class="extype">pekko.stream.ThrottleMode.Shaping</a> makes pauses before emitting messages to meet throttle rate</li><li><a href="ThrottleMode$$Enforcing$.html" name="org.apache.pekko.stream.ThrottleMode.Enforcing" id="org.apache.pekko.stream.ThrottleMode.Enforcing" class="extype">pekko.stream.ThrottleMode.Enforcing</a> fails with exception when upstream is faster than throttle rate. Enforcing
 cannot emit elements that cost more than the maximumBurst</li></ul><p>It is recommended to use non-zero burst sizes as they improve both performance and throttling precision by allowing
the implementation to avoid using the scheduler when input rates fall below the enforced limit and to reduce
most of the inaccuracy caused by the scheduler resolution (which is in the range of milliseconds).</p><p> WARNING: Be aware that throttle is using scheduler to slow down the stream. This scheduler has minimal time of triggering
 next push. Consequently it will slow down the stream as it has minimal pause for emitting. This can happen in
 case burst is 0 and speed is higher than 30 events per second. You need to increase the <code>maximumBurst</code>  if
 elements arrive with small interval (30 milliseconds or less). Use the overloaded <code>throttle</code> method without
 <code>maximumBurst</code> parameter to automatically calculate the <code>maximumBurst</code> based on the given rate (<code>cost/per</code>).
 In other words the throttler always enforces the rate limit when <code>maximumBurst</code> parameter is given, but in
 certain cases (mostly due to limited scheduler resolution) it enforces a tighter bound than what was prescribed.</p><p><b>Emits when</b> upstream emits an element and configured time per each element elapsed</p><p><b>Backpressures when</b> downstream backpressures or the incoming rate is higher than the speed limit</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#throttle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,costCalculation:Out=&gt;Int):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="throttle(Int,FiniteDuration,(T)=&gt;Int):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,costCalculation:Out=&gt;Int):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">throttle</span><span class="params">(<span name="cost">cost: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="per">per: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="costCalculation">costCalculation: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Sends elements downstream with speed limited to <code>cost/per</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Sends elements downstream with speed limited to <code>cost/per</code>. Cost is
calculating for each element individually by calling <code>calculateCost</code> function.
This operator works for streams when elements have different cost(length).
Streams of <code>ByteString</code> for example.</p><p>Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size).
Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
to allow some burstiness. Whenever stream wants to send an element, it takes as many
tokens from the bucket as element costs. If there isn't any, throttle waits until the
bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and
started.</p><p>The burst size is calculated based on the given rate (<code>cost/per</code>) as 0.1 * rate, for example:
- rate &lt; 20/second =&gt; burst size 1
- rate 20/second =&gt; burst size 2
- rate 100/second =&gt; burst size 10
- rate 200/second =&gt; burst size 20</p><p>The throttle <code>mode</code> is <a href="ThrottleMode$$Shaping$.html" name="org.apache.pekko.stream.ThrottleMode.Shaping" id="org.apache.pekko.stream.ThrottleMode.Shaping" class="extype">pekko.stream.ThrottleMode.Shaping</a>, which makes pauses before emitting messages to
meet throttle rate.</p><p><b>Emits when</b> upstream emits an element and configured time per each element elapsed</p><p><b>Backpressures when</b> downstream backpressures or the incoming rate is higher than the speed limit</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#throttle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttle(elements:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="throttle(Int,FiniteDuration,Int,ThrottleMode):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#throttle(elements:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">throttle</span><span class="params">(<span name="elements">elements: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="per">per: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="maximumBurst">maximumBurst: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="mode">mode: <a href="ThrottleMode.html" name="org.apache.pekko.stream.ThrottleMode" id="org.apache.pekko.stream.ThrottleMode" class="extype">ThrottleMode</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Sends elements downstream with speed limited to <code>elements/per</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Sends elements downstream with speed limited to <code>elements/per</code>. In other words, this operator set the maximum rate
for emitting messages. This operator works for streams where all elements have the same cost or length.</p><p>Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size or maximumBurst).
Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
to allow some burstiness. Whenever stream wants to send an element, it takes as many
tokens from the bucket as element costs. If there isn't any, throttle waits until the
bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and started.</p><p>Parameter <code>mode</code> manages behavior when upstream is faster than throttle rate:</p><ul><li><a href="ThrottleMode$$Shaping$.html" name="org.apache.pekko.stream.ThrottleMode.Shaping" id="org.apache.pekko.stream.ThrottleMode.Shaping" class="extype">pekko.stream.ThrottleMode.Shaping</a> makes pauses before emitting messages to meet throttle rate</li><li><a href="ThrottleMode$$Enforcing$.html" name="org.apache.pekko.stream.ThrottleMode.Enforcing" id="org.apache.pekko.stream.ThrottleMode.Enforcing" class="extype">pekko.stream.ThrottleMode.Enforcing</a> fails with exception when upstream is faster than throttle rate. Enforcing
 cannot emit elements that cost more than the maximumBurst</li></ul><p>It is recommended to use non-zero burst sizes as they improve both performance and throttling precision by allowing
the implementation to avoid using the scheduler when input rates fall below the enforced limit and to reduce
most of the inaccuracy caused by the scheduler resolution (which is in the range of milliseconds).</p><p> WARNING: Be aware that throttle is using scheduler to slow down the stream. This scheduler has minimal time of triggering
 next push. Consequently it will slow down the stream as it has minimal pause for emitting. This can happen in
 case burst is 0 and speed is higher than 30 events per second. You need to increase the <code>maximumBurst</code>  if
 elements arrive with small interval (30 milliseconds or less). Use the overloaded <code>throttle</code> method without
 <code>maximumBurst</code> parameter to automatically calculate the <code>maximumBurst</code> based on the given rate (<code>cost/per</code>).
 In other words the throttler always enforces the rate limit when <code>maximumBurst</code> parameter is given, but in
 certain cases (mostly due to limited scheduler resolution) it enforces a tighter bound than what was prescribed.</p><p><b>Emits when</b> upstream emits an element and configured time per each element elapsed</p><p><b>Backpressures when</b> downstream backpressures or the incoming rate is higher than the speed limit</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#throttle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttle(elements:Int,per:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="throttle(Int,FiniteDuration):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#throttle(elements:Int,per:scala.concurrent.duration.FiniteDuration):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">throttle</span><span class="params">(<span name="elements">elements: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="per">per: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Sends elements downstream with speed limited to <code>elements/per</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Sends elements downstream with speed limited to <code>elements/per</code>. In other words, this operator set the maximum rate
for emitting messages. This operator works for streams where all elements have the same cost or length.</p><p>Throttle implements the token bucket model. There is a bucket with a given token capacity (burst size).
Tokens drops into the bucket at a given rate and can be <code>spared</code> for later use up to bucket capacity
to allow some burstiness. Whenever stream wants to send an element, it takes as many
tokens from the bucket as element costs. If there isn't any, throttle waits until the
bucket accumulates enough tokens. Elements that costs more than the allowed burst will be delayed proportionally
to their cost minus available tokens, meeting the target rate. Bucket is full when stream just materialized and
started.</p><p>The burst size is calculated based on the given rate (<code>cost/per</code>) as 0.1 * rate, for example:
- rate &lt; 20/second =&gt; burst size 1
- rate 20/second =&gt; burst size 2
- rate 100/second =&gt; burst size 10
- rate 200/second =&gt; burst size 20</p><p>The throttle <code>mode</code> is <a href="ThrottleMode$$Shaping$.html" name="org.apache.pekko.stream.ThrottleMode.Shaping" id="org.apache.pekko.stream.ThrottleMode.Shaping" class="extype">pekko.stream.ThrottleMode.Shaping</a>, which makes pauses before emitting messages to
meet throttle rate.</p><p><b>Emits when</b> upstream emits an element and configured time per each element elapsed</p><p><b>Backpressures when</b> downstream backpressures or the incoming rate is higher than the speed limit</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#to" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="to[Mat2](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2]):org.apache.pekko.stream.scaladsl.RunnableGraph[Mat]" class="anchorToMember"></a><a id="to[Mat2](Graph[SinkShape[T],Mat2]):RunnableGraph[NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#to[Mat2](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2]):org.apache.pekko.stream.scaladsl.RunnableGraph[Mat]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">to</span><span class="tparams">[<span name="Mat2">Mat2</span>]</span><span class="params">(<span name="sink">sink: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.Source.to.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Connect this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">pekko.stream.scaladsl.Source</a> to a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">pekko.stream.scaladsl.Sink</a>,
concatenating the processing steps of both.</p><div class="fullcomment"><div class="comment cmt"><p>Connect this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">pekko.stream.scaladsl.Source</a> to a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">pekko.stream.scaladsl.Sink</a>,
concatenating the processing steps of both.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#toMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toMat[Mat2,Mat3](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(combine:(Mat,Mat2)=&gt;Mat3):org.apache.pekko.stream.scaladsl.RunnableGraph[Mat3]" class="anchorToMember"></a><a id="toMat[Mat2,Mat3](Graph[SinkShape[T],Mat2])((NotUsed,Mat2)=&gt;Mat3):RunnableGraph[Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#toMat[Mat2,Mat3](sink:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(combine:(Mat,Mat2)=&gt;Mat3):org.apache.pekko.stream.scaladsl.RunnableGraph[Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">toMat</span><span class="tparams">[<span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="sink">sink: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.Source.toMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="combine">combine: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.Source.toMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.Source.toMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/RunnableGraph.html" name="org.apache.pekko.stream.scaladsl.RunnableGraph" id="org.apache.pekko.stream.scaladsl.RunnableGraph" class="extype">RunnableGraph</a>[<span name="org.apache.pekko.stream.scaladsl.Source.toMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Connect this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">pekko.stream.scaladsl.Source</a> to a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">pekko.stream.scaladsl.Sink</a>,
concatenating the processing steps of both.</p><div class="fullcomment"><div class="comment cmt"><p>Connect this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">pekko.stream.scaladsl.Source</a> to a <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">pekko.stream.scaladsl.Sink</a>,
concatenating the processing steps of both.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#traversalBuilder" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="traversalBuilder:org.apache.pekko.stream.impl.LinearTraversalBuilder" class="anchorToMember"></a><a id="traversalBuilder:LinearTraversalBuilder" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#traversalBuilder:org.apache.pekko.stream.impl.LinearTraversalBuilder" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="implicit">traversalBuilder</span><span class="result">: <span name="org.apache.pekko.stream.impl.LinearTraversalBuilder" class="extype">LinearTraversalBuilder</span></span></span><p class="shortcomment cmt">INTERNAL API.</p><div class="fullcomment"><div class="comment cmt"><p>INTERNAL API.</p><p>Every materializable element must be backed by a stream layout module
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#via" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="via[T,Mat2](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2]):Source.this.Repr[T]" class="anchorToMember"></a><a id="via[T,Mat2](Graph[FlowShape[T,T],Mat2]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#via[T,Mat2](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2]):Source.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">via</span><span class="tparams">[<span name="T">T</span>, <span name="Mat2">Mat2</span>]</span><span class="params">(<span name="flow">flow: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="FlowShape.html" name="org.apache.pekko.stream.FlowShape" id="org.apache.pekko.stream.FlowShape" class="extype">FlowShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.Source.via.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.Source.via.Mat2" class="extype">Mat2</span>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.via.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Transform this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> by appending the given processing steps.</p><div class="fullcomment"><div class="comment cmt"><p>Transform this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> by appending the given processing steps.</p><pre>    +---------------------------------+
    | Resulting Flow[In, T, Mat]  |
    |                                 |
    |  +------+             +------+  |
    |  |      |             |      |  |
In ~~&gt; | <span class="kw">this</span> |  ~~Out~~&gt;   | flow | ~~&gt; T
    |  |   Mat|             |     M|  |
    |  +------+             +------+  |
    +---------------------------------+</pre><p>The materialized value of the combined <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> will be the materialized
value of the current flow (ignoring the other Flow’s value), use
<a href="scaladsl/Flow.html#viaMat[T,Mat2,Mat3](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2])(combine:(Mat,Mat2)=&gt;Mat3):org.apache.pekko.stream.scaladsl.Flow[In,T,Mat3]" name="org.apache.pekko.stream.scaladsl.Flow#viaMat" id="org.apache.pekko.stream.scaladsl.Flow#viaMat" class="extmbr">viaMat</a> if a different strategy is needed.</p><p>See also <a href="scaladsl/FlowOpsMat.html#viaMat[T,Mat2,Mat3](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2])(combine:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[T,Mat3]" name="org.apache.pekko.stream.scaladsl.FlowOpsMat#viaMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat#viaMat" class="extmbr">FlowOpsMat.viaMat</a> when access to materialized values of the parameter is needed.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#viaMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="viaMat[T,Mat2,Mat3](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2])(combine:(Mat,Mat2)=&gt;Mat3):org.apache.pekko.stream.scaladsl.Source[T,Mat3]" class="anchorToMember"></a><a id="viaMat[T,Mat2,Mat3](Graph[FlowShape[T,T],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[T,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#viaMat[T,Mat2,Mat3](flow:org.apache.pekko.stream.Graph[org.apache.pekko.stream.FlowShape[Out,T],Mat2])(combine:(Mat,Mat2)=&gt;Mat3):org.apache.pekko.stream.scaladsl.Source[T,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">viaMat</span><span class="tparams">[<span name="T">T</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="flow">flow: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="FlowShape.html" name="org.apache.pekko.stream.FlowShape" id="org.apache.pekko.stream.FlowShape" class="extype">FlowShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.Source.viaMat.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.Source.viaMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="combine">combine: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.Source.viaMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.Source.viaMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.viaMat.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.Source.viaMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Transform this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> by appending the given processing steps.</p><div class="fullcomment"><div class="comment cmt"><p>Transform this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> by appending the given processing steps.</p><pre>    +---------------------------------+
    | Resulting Flow[In, T, M2]       |
    |                                 |
    |  +------+            +------+   |
    |  |      |            |      |   |
In ~~&gt; | <span class="kw">this</span> |  ~~Out~~&gt;  | flow |  ~~&gt; T
    |  |   Mat|            |     M|   |
    |  +------+            +------+   |
    +---------------------------------+</pre><p>The <code>combine</code> function is used to compose the materialized values of this flow and that
flow into the materialized value of the resulting Flow.</p><p>It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit" class="anchorToMember"></a><a id="wait(Long,Int):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit" class="anchorToMember"></a><a id="wait(Long):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#watch" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="watch(ref:org.apache.pekko.actor.ActorRef):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="watch(ActorRef):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#watch(ref:org.apache.pekko.actor.ActorRef):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">watch</span><span class="params">(<span name="ref">ref: <a href="../actor/ActorRef.html" name="org.apache.pekko.actor.ActorRef" id="org.apache.pekko.actor.ActorRef" class="extype">ActorRef</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">The operator fails with an <a href="WatchedActorTerminatedException.html" name="org.apache.pekko.stream.WatchedActorTerminatedException" id="org.apache.pekko.stream.WatchedActorTerminatedException" class="extype">pekko.stream.WatchedActorTerminatedException</a> if the target actor is terminated.</p><div class="fullcomment"><div class="comment cmt"><p>The operator fails with an <a href="WatchedActorTerminatedException.html" name="org.apache.pekko.stream.WatchedActorTerminatedException" id="org.apache.pekko.stream.WatchedActorTerminatedException" class="extype">pekko.stream.WatchedActorTerminatedException</a> if the target actor is terminated.</p><p><b>Emits when</b> upstream emits</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Fails when</b> the watched actor terminates</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#watchTermination" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="watchTermination[Mat2]()(matF:(Mat,scala.concurrent.Future[org.apache.pekko.Done])=&gt;Mat2):FlowOpsMat.this.ReprMat[Out,Mat2]" class="anchorToMember"></a><a id="watchTermination[Mat2]()((NotUsed,Future[Done])=&gt;Mat2):Source[T,Mat2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#watchTermination[Mat2]()(matF:(Mat,scala.concurrent.Future[org.apache.pekko.Done])=&gt;Mat2):FlowOpsMat.this.ReprMat[Out,Mat2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">watchTermination</span><span class="tparams">[<span name="Mat2">Mat2</span>]</span><span class="params">()</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="../Done.html" name="org.apache.pekko.Done" id="org.apache.pekko.Done" class="extype">Done</a>]) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.watchTermination.Mat2" class="extype">Mat2</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.watchTermination.Mat2" class="extype">Mat2</span>]</span></span><p class="shortcomment cmt">Materializes to <code>Future[Done]</code> that completes on getting termination message.</p><div class="fullcomment"><div class="comment cmt"><p>Materializes to <code>Future[Done]</code> that completes on getting termination message.
The Future completes with success when received complete message from upstream or cancel
from downstream. It fails with the propagated error when received error message from
upstream or downstream.</p><p>It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#wireTap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wireTap(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="wireTap(Graph[SinkShape[T],_]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#wireTap(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">wireTap</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], _]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> as a wire tap, meaning that elements that pass
through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> as a wire tap, meaning that elements that pass
through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.
If the wire-tap Sink backpressures, elements that would've been sent to it will be dropped instead.</p><p>It is similar to <a href="scaladsl/Source.html#alsoTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#alsoTo" id="org.apache.pekko.stream.scaladsl.Source#alsoTo" class="extmbr">#alsoTo</a> which does backpressure instead of dropping elements.</p><p><b>Emits when</b> element is available and demand exists from the downstream; the element will
also be sent to the wire-tap Sink if there is demand.</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#wireTap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wireTap(f:Out=&gt;Unit):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="wireTap((T)=&gt;Unit):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#wireTap(f:Out=&gt;Unit):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">wireTap</span><span class="params">(<span name="f">f: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">This is a simplified version of <code>wireTap(Sink)</code> that takes only a simple function.</p><div class="fullcomment"><div class="comment cmt"><p>This is a simplified version of <code>wireTap(Sink)</code> that takes only a simple function.
Elements will be passed into this "side channel" function, and any of its results will be ignored.</p><p>If the wire-tap operation is slow (it backpressures), elements that would've been sent to it will be dropped instead.
It is similar to <a href="scaladsl/Source.html#alsoTo(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#alsoTo" id="org.apache.pekko.stream.scaladsl.Source#alsoTo" class="extmbr">#alsoTo</a> which does backpressure instead of dropping elements.</p><p>This operation is useful for inspecting the passed through element, usually by means of side-effecting
operations (such as <code>println</code>, or emitting metrics), for each element without having to modify it.</p><p>For logging signals (elements, completion, error) consider using the <a href="scaladsl/Source.html#log(name:String,extract:Out=&gt;Any)(implicitlog:org.apache.pekko.event.LoggingAdapter):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#log" id="org.apache.pekko.stream.scaladsl.Source#log" class="extmbr">log</a> operator instead,
along with appropriate <code>ActorAttributes.logLevels</code>.</p><p><b>Emits when</b> upstream emits an element; the same element will be passed to the attached function,
                 as well as to the downstream operator</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#wireTapMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wireTapMat[Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out,Mat3]" class="anchorToMember"></a><a id="wireTapMat[Mat2,Mat3](Graph[SinkShape[T],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[T,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#wireTapMat[Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">wireTapMat</span><span class="tparams">[<span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SinkShape.html" name="org.apache.pekko.stream.SinkShape" id="org.apache.pekko.stream.SinkShape" class="extype">SinkShape</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.wireTapMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.wireTapMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.wireTapMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.wireTapMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> as a wire tap, meaning that elements that pass
through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches the given <a href="scaladsl/Sink.html" name="org.apache.pekko.stream.scaladsl.Sink" id="org.apache.pekko.stream.scaladsl.Sink" class="extype">Sink</a> to this <a href="scaladsl/Flow.html" name="org.apache.pekko.stream.scaladsl.Flow" id="org.apache.pekko.stream.scaladsl.Flow" class="extype">Flow</a> as a wire tap, meaning that elements that pass
through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.
If the wire-tap Sink backpressures, elements that would've been sent to it will be dropped instead.</p><p>It is similar to <a href="scaladsl/Source.html#alsoToMat[Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out,Mat3]" name="org.apache.pekko.stream.scaladsl.Source#alsoToMat" id="org.apache.pekko.stream.scaladsl.Source#alsoToMat" class="extmbr">#alsoToMat</a> which does backpressure instead of dropping elements.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#wireTap(that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SinkShape[Out],_]):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#wireTap" id="org.apache.pekko.stream.scaladsl.Source#wireTap" class="extmbr">#wireTap</a>
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#withAttributes" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withAttributes(attr:org.apache.pekko.stream.Attributes):Source.this.Repr[Out]" class="anchorToMember"></a><a id="withAttributes(Attributes):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#withAttributes(attr:org.apache.pekko.stream.Attributes):Source.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">withAttributes</span><span class="params">(<span name="attr">attr: <a href="Attributes.html" name="org.apache.pekko.stream.Attributes" id="org.apache.pekko.stream.Attributes" class="extype">Attributes</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Replace the attributes of this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with the given ones.</p><div class="fullcomment"><div class="comment cmt"><p>Replace the attributes of this <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> with the given ones. If this Source is a composite
of multiple graphs, new attributes on the composite will be less specific than attributes
set directly on the individual graphs of the composite.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a> → <a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zip" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zip[U](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]):FlowOps.this.Repr[(Out,U)]" class="anchorToMember"></a><a id="zip[U](Graph[SourceShape[U],_]):Source[(T,U),NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zip[U](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]):FlowOps.this.Repr[(Out,U)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zip</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zip.U" class="extype">U</span>], _]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.zip.U" class="extype">U</span>), <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.</p><p><b>Emits when</b> all of the inputs have an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipAll[U,A&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],thisElem:A,thatElem:U):FlowOps.this.Repr[(A,U)]" class="anchorToMember"></a><a id="zipAll[U,A&gt;:Out](Graph[SourceShape[U],_],A,U):Source[(A,U),NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipAll[U,A&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],thisElem:A,thatElem:U):FlowOps.this.Repr[(A,U)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipAll</span><span class="tparams">[<span name="U">U</span>, <span name="A">A &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipAll.U" class="extype">U</span>], _]</span>, <span name="thisElem">thisElem: <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipAll.A" class="extype">A</span></span>, <span name="thatElem">thatElem: <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipAll.U" class="extype">U</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipAll.A" class="extype">A</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipAll.U" class="extype">U</span>), <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.</p><p><b>Emits when</b> at first emits when both inputs emit, and then as long as any input emits (coupled to the default value of the completed input).</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> all upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipAllMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipAllMat[U,Mat2,Mat3,A&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],thisElem:A,thatElem:U)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[(A,U),Mat3]" class="anchorToMember"></a><a id="zipAllMat[U,Mat2,Mat3,A&gt;:Out](Graph[SourceShape[U],Mat2],A,U)((NotUsed,Mat2)=&gt;Mat3):Source[(A,U),Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipAllMat[U,Mat2,Mat3,A&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2],thisElem:A,thatElem:U)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[(A,U),Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipAllMat</span><span class="tparams">[<span name="U">U</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>, <span name="A">A &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.Mat2" class="extype">Mat2</span>]</span>, <span name="thisElem">thisElem: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.A" class="extype">A</span></span>, <span name="thatElem">thatElem: <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.U" class="extype">U</span></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.A" class="extype">A</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.U" class="extype">U</span>), <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipAllMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#zipAll[U,A&gt;:Out](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_],thisElem:A,thatElem:U):FlowOps.this.Repr[(A,U)]" name="org.apache.pekko.stream.scaladsl.Source#zipAll" id="org.apache.pekko.stream.scaladsl.Source#zipAll" class="extmbr">#zipAll</a>
<b>Emits when</b> at first emits when both inputs emit, and then as long as any input emits (coupled to the default value of the completed input).
<b>Backpressures when</b> downstream backpressures
<b>Completes when</b> all upstream completes
<b>Cancels when</b> downstream cancels</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipLatest" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipLatest[U](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]):FlowOps.this.Repr[(Out,U)]" class="anchorToMember"></a><a id="zipLatest[U](Graph[SourceShape[U],_]):Source[(T,U),NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipLatest[U](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]):FlowOps.this.Repr[(Out,U)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipLatest</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatest.U" class="extype">U</span>], _]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatest.U" class="extype">U</span>), <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of 2 streams into a stream of tuples, picking always the latest element of each.</p><p>A <code>ZipLatest</code> has a <code>left</code> and a <code>right</code> input port and one <code>out</code> port.</p><p>No element is emitted until at least one element from each Source becomes available.</p><p><b>Emits when</b> all of the inputs have at least an element available, and then each time an element becomes
 available on either of the inputs</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipLatestMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipLatestMat[U,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[(Out,U),Mat3]" class="anchorToMember"></a><a id="zipLatestMat[U,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[(T,U),Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipLatestMat[U,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[(Out,U),Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipLatestMat</span><span class="tparams">[<span name="U">U</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestMat.U" class="extype">U</span>), <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples,
picking always the latest of the elements of each source.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples,
picking always the latest of the elements of each source.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#zipLatest[U](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]):FlowOps.this.Repr[(Out,U)]" name="org.apache.pekko.stream.scaladsl.Source#zipLatest" id="org.apache.pekko.stream.scaladsl.Source#zipLatest" class="extmbr">#zipLatest</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipLatestWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipLatestWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_],eagerComplete:Boolean)(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" class="anchorToMember"></a><a id="zipLatestWith[Out2,Out3](Graph[SourceShape[Out2],_],Boolean)((T,Out2)=&gt;Out3):Source[Out3,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipLatestWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_],eagerComplete:Boolean)(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipLatestWith</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Out3">Out3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out2" class="extype">Out2</span>], _]</span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="combine">combine: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out2" class="extype">Out2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out3" class="extype">Out3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out3" class="extype">Out3</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Combine the elements of multiple streams into a stream of combined elements using a combiner function,
picking always the latest of the elements of each source.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of multiple streams into a stream of combined elements using a combiner function,
picking always the latest of the elements of each source.</p><p>No element is emitted until at least one element from each Source becomes available. Whenever a new
element appears, the zipping function is invoked with a tuple containing the new element
and the other last seen elements.</p><p>  <b>Emits when</b> all of the inputs have at least an element available, and then each time an element becomes
  available on either of the inputs</p><p>  <b>Backpressures when</b> downstream backpressures</p><p>  <b>Completes when</b> any upstream completes if <code>eagerComplete</code> is enabled or wait for all upstreams to complete</p><p>  <b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipLatestWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipLatestWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_])(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" class="anchorToMember"></a><a id="zipLatestWith[Out2,Out3](Graph[SourceShape[Out2],_])((T,Out2)=&gt;Out3):Source[Out3,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipLatestWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_])(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipLatestWith</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Out3">Out3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out2" class="extype">Out2</span>], _]</span>)</span><span class="params">(<span name="combine">combine: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out2" class="extype">Out2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out3" class="extype">Out3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipLatestWith.Out3" class="extype">Out3</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Combine the elements of multiple streams into a stream of combined elements using a combiner function,
picking always the latest of the elements of each source.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of multiple streams into a stream of combined elements using a combiner function,
picking always the latest of the elements of each source.</p><p>No element is emitted until at least one element from each Source becomes available. Whenever a new
element appears, the zipping function is invoked with a tuple containing the new element
and the other last seen elements.</p><p>  <b>Emits when</b> all of the inputs have at least an element available, and then each time an element becomes
  available on either of the inputs</p><p>  <b>Backpressures when</b> downstream backpressures</p><p>  <b>Completes when</b> any of the upstreams completes</p><p>  <b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipLatestWithMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipLatestWithMat[Out2,Out3,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],Mat2],eagerComplete:Boolean)(combine:(Out,Out2)=&gt;Out3)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out3,Mat3]" class="anchorToMember"></a><a id="zipLatestWithMat[Out2,Out3,Mat2,Mat3](Graph[SourceShape[Out2],Mat2],Boolean)((T,Out2)=&gt;Out3)((NotUsed,Mat2)=&gt;Mat3):Source[Out3,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipLatestWithMat[Out2,Out3,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],Mat2],eagerComplete:Boolean)(combine:(Out,Out2)=&gt;Out3)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out3,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipLatestWithMat</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Out3">Out3</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out2" class="extype">Out2</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat2" class="extype">Mat2</span>]</span>, <span name="eagerComplete">eagerComplete: <a href="https://www.scala-lang.org/api/2.13.8/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span name="combine">combine: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out2" class="extype">Out2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out3" class="extype">Out3</span></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out3" class="extype">Out3</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.</p><div class="fullcomment"><div class="comment cmt"><p>Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#zipLatestWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_],eagerComplete:Boolean)(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" name="org.apache.pekko.stream.scaladsl.Source#zipLatestWith" id="org.apache.pekko.stream.scaladsl.Source#zipLatestWith" class="extmbr">#zipLatestWith</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipLatestWithMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipLatestWithMat[Out2,Out3,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],Mat2])(combine:(Out,Out2)=&gt;Out3)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out3,Mat3]" class="anchorToMember"></a><a id="zipLatestWithMat[Out2,Out3,Mat2,Mat3](Graph[SourceShape[Out2],Mat2])((T,Out2)=&gt;Out3)((NotUsed,Mat2)=&gt;Mat3):Source[Out3,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipLatestWithMat[Out2,Out3,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],Mat2])(combine:(Out,Out2)=&gt;Out3)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out3,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipLatestWithMat</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Out3">Out3</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out2" class="extype">Out2</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="combine">combine: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out2" class="extype">Out2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out3" class="extype">Out3</span></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Out3" class="extype">Out3</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipLatestWithMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.</p><div class="fullcomment"><div class="comment cmt"><p>Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#zipLatestWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_],eagerComplete:Boolean)(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" name="org.apache.pekko.stream.scaladsl.Source#zipLatestWith" id="org.apache.pekko.stream.scaladsl.Source#zipLatestWith" class="extmbr">#zipLatestWith</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipMat[U,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[(Out,U),Mat3]" class="anchorToMember"></a><a id="zipMat[U,Mat2,Mat3](Graph[SourceShape[U],Mat2])((NotUsed,Mat2)=&gt;Mat3):Source[(T,U),Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipMat[U,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],Mat2])(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[(Out,U),Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipMat</span><span class="tparams">[<span name="U">U</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipMat.U" class="extype">U</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipMat.U" class="extype">U</span>), <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> into a stream of tuples.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#zip[U](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[U],_]):FlowOps.this.Repr[(Out,U)]" name="org.apache.pekko.stream.scaladsl.Source#zip" id="org.apache.pekko.stream.scaladsl.Source#zip" class="extmbr">#zip</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_])(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" class="anchorToMember"></a><a id="zipWith[Out2,Out3](Graph[SourceShape[Out2],_])((T,Out2)=&gt;Out3):Source[Out3,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_])(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipWith</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Out3">Out3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipWith.Out2" class="extype">Out2</span>], _]</span>)</span><span class="params">(<span name="combine">combine: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipWith.Out2" class="extype">Out2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOps.zipWith.Out3" class="extype">Out3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.zipWith.Out3" class="extype">Out3</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function.</p><div class="fullcomment"><div class="comment cmt"><p>Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function.</p><p><b>Emits when</b> all of the inputs have an element available</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> any upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipWithIndex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipWithIndex:FlowOps.this.Repr[(Out,Long)]" class="anchorToMember"></a><a id="zipWithIndex:Source[(T,Long),NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipWithIndex:FlowOps.this.Repr[(Out,Long)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipWithIndex</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[(<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="https://www.scala-lang.org/api/2.13.8/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>), <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Combine the elements of current flow into a stream of tuples consisting
of all elements paired with their index.</p><div class="fullcomment"><div class="comment cmt"><p>Combine the elements of current flow into a stream of tuples consisting
of all elements paired with their index. Indices start at 0.</p><p><b>Emits when</b> upstream emits an element and is paired with their index</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#zipWithMat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipWithMat[Out2,Out3,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],Mat2])(combine:(Out,Out2)=&gt;Out3)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out3,Mat3]" class="anchorToMember"></a><a id="zipWithMat[Out2,Out3,Mat2,Mat3](Graph[SourceShape[Out2],Mat2])((T,Out2)=&gt;Out3)((NotUsed,Mat2)=&gt;Mat3):Source[Out3,Mat3]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#zipWithMat[Out2,Out3,Mat2,Mat3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],Mat2])(combine:(Out,Out2)=&gt;Out3)(matF:(Mat,Mat2)=&gt;Mat3):FlowOpsMat.this.ReprMat[Out3,Mat3]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit">zipWithMat</span><span class="tparams">[<span name="Out2">Out2</span>, <span name="Out3">Out3</span>, <span name="Mat2">Mat2</span>, <span name="Mat3">Mat3</span>]</span><span class="params">(<span name="that">that: <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Out2" class="extype">Out2</span>], <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Mat2" class="extype">Mat2</span>]</span>)</span><span class="params">(<span name="combine">combine: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Out2" class="extype">Out2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Out3" class="extype">Out3</span></span>)</span><span class="params">(<span name="matF">matF: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Mat2" class="extype">Mat2</span>) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Mat3" class="extype">Mat3</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Out3" class="extype">Out3</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.zipWithMat.Mat3" class="extype">Mat3</span>]</span></span><p class="shortcomment cmt">Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function.</p><div class="fullcomment"><div class="comment cmt"><p>Put together the elements of current flow and the given <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>
into a stream of combined elements using a combiner function.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#zipWith[Out2,Out3](that:org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[Out2],_])(combine:(Out,Out2)=&gt;Out3):FlowOps.this.Repr[Out3]" name="org.apache.pekko.stream.scaladsl.Source#zipWith" id="org.apache.pekko.stream.scaladsl.Source#zipWith" class="extmbr">#zipWith</a>.
It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
where appropriate instead of manually writing functions that pass through one of the values.</p></span></dd></dl></div></li></ol></div><div class="values members"><h3>Shadowed Implicit Value Members</h3><ol><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit shadowed">toString</span><span class="params">()</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt class="implicit">Shadowing</dt><dd>This implicitly inherited member is shadowed by one or more members in this class.<br/>To access this member you can use a <a href="https://stackoverflow.com/questions/2087250/what-is-the-purpose-of-type-ascription-in-scala" target="_blank">type ascription</a>:<br/><div class="cmt"><pre>(sourceRef: Source[T, NotUsed]).toString()</pre></div></dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a> → AnyRef → Any</dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#combine" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="combine[T,U](first:org.apache.pekko.stream.scaladsl.Source[T,_],second:org.apache.pekko.stream.scaladsl.Source[T,_],rest:org.apache.pekko.stream.scaladsl.Source[T,_]*)(strategy:Int=&gt;org.apache.pekko.stream.Graph[org.apache.pekko.stream.UniformFanInShape[T,U],org.apache.pekko.NotUsed]):org.apache.pekko.stream.scaladsl.Source[U,org.apache.pekko.NotUsed]" class="anchorToMember"></a><a id="combine[T,U](Source[T,_],Source[T,_],Source[T,_]*)((Int)=&gt;Graph[UniformFanInShape[T,U],NotUsed]):Source[U,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#combine[T,U](first:org.apache.pekko.stream.scaladsl.Source[T,_],second:org.apache.pekko.stream.scaladsl.Source[T,_],rest:org.apache.pekko.stream.scaladsl.Source[T,_]*)(strategy:Int=&gt;org.apache.pekko.stream.Graph[org.apache.pekko.stream.UniformFanInShape[T,U],org.apache.pekko.NotUsed]):org.apache.pekko.stream.scaladsl.Source[U,org.apache.pekko.NotUsed]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version Akka 2.5.5) Use Source.combine on companion object instead">combine</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="first">first: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.combine.T" class="extype">T</span>, _]</span>, <span name="second">second: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.combine.T" class="extype">T</span>, _]</span>, <span name="rest">rest: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.combine.T" class="extype">T</span>, _]*</span>)</span><span class="params">(<span name="strategy">strategy: (<a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>) =&gt; <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="UniformFanInShape.html" name="org.apache.pekko.stream.UniformFanInShape" id="org.apache.pekko.stream.UniformFanInShape" class="extype">UniformFanInShape</a>[<span name="org.apache.pekko.stream.scaladsl.Source.combine.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.Source.combine.U" class="extype">U</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.Source.combine.U" class="extype">U</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">Combines several sources with fan-in strategy like <code>Merge</code> or <code>Concat</code> and returns <code>Source</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Combines several sources with fan-in strategy like <code>Merge</code> or <code>Concat</code> and returns <code>Source</code>.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a></dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version Akka 2.5.5)</i> Use <code>Source.combine</code> on companion object instead</p></dd></dl></div></li><li class="indented0 " name="scala.Predef.StringFormat#formatted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="formatted(fmtstr:String):String" class="anchorToMember"></a><a id="formatted(String):String" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#formatted(fmtstr:String):String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version 2.12.16) Use formatString.format(value) instead of value.formatted(formatString),
or use the f&quot;&quot; string interpolator. In Java 15 and later, formatted resolves to the new method in String which has reversed parameters.">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method StringFormat in scala.Predef.</dd><dt>Definition Classes</dt><dd>StringFormat</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> <span class="name">@inline</span><span class="args">()</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.12.16)</i> Use <code>formatString.format(value)</code> instead of <code>value.formatted(formatString)</code>,
or use the <code>f""</code> string interpolator. In Java 15 and later, <code>formatted</code> resolves to the new method in String which has reversed parameters.</p></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#monitor" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monitor[Mat2]()(combine:(Mat,org.apache.pekko.stream.FlowMonitor[Out])=&gt;Mat2):FlowOpsMat.this.ReprMat[Out,Mat2]" class="anchorToMember"></a><a id="monitor[Mat2]()((NotUsed,FlowMonitor[T])=&gt;Mat2):Source[T,Mat2]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#monitor[Mat2]()(combine:(Mat,org.apache.pekko.stream.FlowMonitor[Out])=&gt;Mat2):FlowOpsMat.this.ReprMat[Out,Mat2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version Akka 2.5.17) Use monitor() or monitorMat(combine) instead">monitor</span><span class="tparams">[<span name="Mat2">Mat2</span>]</span><span class="params">()</span><span class="params">(<span name="combine">combine: (<a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>, <a href="FlowMonitor.html" name="org.apache.pekko.stream.FlowMonitor" id="org.apache.pekko.stream.FlowMonitor" class="extype">FlowMonitor</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]) =&gt; <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.monitor.Mat2" class="extype">Mat2</span></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <span name="org.apache.pekko.stream.scaladsl.FlowOpsMat.monitor.Mat2" class="extype">Mat2</span>]</span></span><p class="shortcomment cmt">Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow.</p><div class="fullcomment"><div class="comment cmt"><p>Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow. All events are propagated
by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
event, and may therefor affect performance.</p><p>The <code>combine</code> function is used to combine the <code>FlowMonitor</code> with this flow's materialized value.
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOpsMat.html" name="org.apache.pekko.stream.scaladsl.FlowOpsMat" id="org.apache.pekko.stream.scaladsl.FlowOpsMat" class="extype">FlowOpsMat</a></dd><dt>Annotations</dt><dd><span class="name">@Deprecated</span> <span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version Akka 2.5.17)</i> Use monitor() or monitorMat(combine) instead</p></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#recoverWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="recoverWith[T&gt;:Out](pf:PartialFunction[Throwable,org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],org.apache.pekko.NotUsed]]):FlowOps.this.Repr[T]" class="anchorToMember"></a><a id="recoverWith[T&gt;:Out](PartialFunction[Throwable,Graph[SourceShape[T],NotUsed]]):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#recoverWith[T&gt;:Out](pf:PartialFunction[Throwable,org.apache.pekko.stream.Graph[org.apache.pekko.stream.SourceShape[T],org.apache.pekko.NotUsed]]):FlowOps.this.Repr[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version 2.4.4) Use recoverWithRetries instead.">recoverWith</span><span class="tparams">[<span name="T">T &gt;: <span name="org.apache.pekko.stream.scaladsl.FlowOps.Out" class="extype">Out</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.8/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#java.lang.Throwable" name="java.lang.Throwable" id="java.lang.Throwable" class="extype">Throwable</a>, <a href="Graph.html" name="org.apache.pekko.stream.Graph" id="org.apache.pekko.stream.Graph" class="extype">Graph</a>[<a href="SourceShape.html" name="org.apache.pekko.stream.SourceShape" id="org.apache.pekko.stream.SourceShape" class="extype">SourceShape</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.recoverWith.T" class="extype">T</span>], <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]]</span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.scaladsl.FlowOps.recoverWith.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">RecoverWith allows to switch to alternative Source on flow failure.</p><div class="fullcomment"><div class="comment cmt"><p>RecoverWith allows to switch to alternative Source on flow failure. It will stay in effect after
a failure has been recovered so that each time there is a failure it is fed into the <code>pf</code> and a new
Source may be materialized.</p><p>Since the underlying failure signal onError arrives out-of-band, it might jump over existing elements.
This operator can recover the failure signal, but not the skipped elements, which will be dropped.</p><p>Throwing an exception inside <code>recoverWith</code> _will_ be logged on ERROR level automatically.</p><p><b>Emits when</b> element is available from the upstream or upstream is failed and element is available
from alternative Source</p><p><b>Backpressures when</b> downstream backpressures</p><p><b>Completes when</b> upstream completes or upstream failed with exception pf can handle</p><p><b>Cancels when</b> downstream cancels
</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.4.4)</i> Use recoverWithRetries instead.</p></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#throttleEven" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttleEven(cost:Int,per:scala.concurrent.duration.FiniteDuration,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="throttleEven(Int,FiniteDuration,(T)=&gt;Int,ThrottleMode):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#throttleEven(cost:Int,per:scala.concurrent.duration.FiniteDuration,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version Akka 2.5.12) Use throttle without maximumBurst parameter instead.">throttleEven</span><span class="params">(<span name="cost">cost: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="per">per: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="costCalculation">costCalculation: (<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="mode">mode: <a href="ThrottleMode.html" name="org.apache.pekko.stream.ThrottleMode" id="org.apache.pekko.stream.ThrottleMode" class="extype">ThrottleMode</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">This is a simplified version of throttle that spreads events evenly across the given time interval.</p><div class="fullcomment"><div class="comment cmt"><p>This is a simplified version of throttle that spreads events evenly across the given time interval.</p><p>Use this operator when you need just slow down a stream without worrying about exact amount
of time between events.</p><p>If you want to be sure that no time interval has no more than specified number of events you need to use
<a href="scaladsl/Source.html#throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#throttle" id="org.apache.pekko.stream.scaladsl.Source#throttle" class="extmbr">throttle</a> with maximumBurst attribute.</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>Annotations</dt><dd><span class="name">@Deprecated</span> <span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version Akka 2.5.12)</i> Use throttle without <code>maximumBurst</code> parameter instead.</p></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#throttle" id="org.apache.pekko.stream.scaladsl.Source#throttle" class="extmbr">throttle</a></p></span></dd></dl></div></li><li class="indented0 " name="org.apache.pekko.stream.SourceRef.convertRefToSource#throttleEven" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttleEven(elements:Int,per:scala.concurrent.duration.FiniteDuration,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" class="anchorToMember"></a><a id="throttleEven(Int,FiniteDuration,ThrottleMode):Source[T,NotUsed]" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#throttleEven(elements:Int,per:scala.concurrent.duration.FiniteDuration,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="Deprecated: (Since version Akka 2.5.12) Use throttle without maximumBurst parameter instead.">throttleEven</span><span class="params">(<span name="elements">elements: <a href="https://www.scala-lang.org/api/2.13.8/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="per">per: <a href="https://www.scala-lang.org/api/2.13.8/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="mode">mode: <a href="ThrottleMode.html" name="org.apache.pekko.stream.ThrottleMode" id="org.apache.pekko.stream.ThrottleMode" class="extype">ThrottleMode</a></span>)</span><span class="result">: <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</span></span><p class="shortcomment cmt">This is a simplified version of throttle that spreads events evenly across the given time interval.</p><div class="fullcomment"><div class="comment cmt"><p>This is a simplified version of throttle that spreads events evenly across the given time interval. throttleEven using
best effort approach to meet throttle rate.</p><p>Use this operator when you need just slow down a stream without worrying about exact amount
of time between events.</p><p>If you want to be sure that no time interval has no more than specified number of events you need to use
<a href="scaladsl/Source.html#throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#throttle" id="org.apache.pekko.stream.scaladsl.Source#throttle" class="extmbr">throttle</a> with maximumBurst attribute.</p></div><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>] performed by method convertRefToSource in <a href="SourceRef$.html" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">org.apache.pekko.stream.SourceRef</a>.</dd><dt>Definition Classes</dt><dd><a href="scaladsl/FlowOps.html" name="org.apache.pekko.stream.scaladsl.FlowOps" id="org.apache.pekko.stream.scaladsl.FlowOps" class="extype">FlowOps</a></dd><dt>Annotations</dt><dd><span class="name">@Deprecated</span> <span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version Akka 2.5.12)</i> Use throttle without <code>maximumBurst</code> parameter instead.</p></dd><dt>See also</dt><dd><span class="cmt"><p><a href="scaladsl/Source.html#throttle(cost:Int,per:scala.concurrent.duration.FiniteDuration,maximumBurst:Int,costCalculation:Out=&gt;Int,mode:org.apache.pekko.stream.ThrottleMode):FlowOps.this.Repr[Out]" name="org.apache.pekko.stream.scaladsl.Source#throttle" id="org.apache.pekko.stream.scaladsl.Source#throttle" class="extmbr">throttle</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.Predef.ArrowAssoc#→" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="→[B](y:B):(A,B)" class="anchorToMember"></a><a id="→[B](B):(SourceRef[T],B)" class="anchorToMember"></a> <span class="permalink"><a href="../../../../org/apache/pekko/stream/SourceRef.html#→[B](y:B):(A,B)" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="implicit deprecated" title="gt4s: $u2192. Deprecated: (Since version 2.13.0) Use -&gt; instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span></span>)</span><span class="result">: (<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>], <span name="scala.Predef.ArrowAssoc.→.B" class="extype">B</span>)</span></span><div class="fullcomment"><dl class="attributes block"><dt class="implicit">Implicit</dt><dd>This member is added by an implicit conversion from <a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to<span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]] performed by method ArrowAssoc in scala.Predef.</dd><dt>Definition Classes</dt><dd>ArrowAssoc</dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.13.0)</i> Use <code>-&gt;</code> instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.8/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.8/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div><div name="org.apache.pekko.stream.SourceRef.convertRefToSource" class="conversion"><h3>Inherited by implicit conversion convertRefToSource from<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to <a href="scaladsl/Source.html" name="org.apache.pekko.stream.scaladsl.Source" id="org.apache.pekko.stream.scaladsl.Source" class="extype">Source</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>, <a href="../NotUsed.html" name="org.apache.pekko.NotUsed" id="org.apache.pekko.NotUsed" class="extype">NotUsed</a>]</h3></div><div name="scala.Predef.any2stringadd" class="conversion"><h3>Inherited by implicit conversion any2stringadd from<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to <span name="scala.Predef.any2stringadd" class="extype">any2stringadd</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]]</h3></div><div name="scala.Predef.StringFormat" class="conversion"><h3>Inherited by implicit conversion StringFormat from<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to <span name="scala.Predef.StringFormat" class="extype">StringFormat</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]]</h3></div><div name="scala.Predef.Ensuring" class="conversion"><h3>Inherited by implicit conversion Ensuring from<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to <span name="scala.Predef.Ensuring" class="extype">Ensuring</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]]</h3></div><div name="scala.Predef.ArrowAssoc" class="conversion"><h3>Inherited by implicit conversion ArrowAssoc from<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>] to <span name="scala.Predef.ArrowAssoc" class="extype">ArrowAssoc</span>[<a href="" name="org.apache.pekko.stream.SourceRef" id="org.apache.pekko.stream.SourceRef" class="extype">SourceRef</a>[<span name="org.apache.pekko.stream.SourceRef.T" class="extype">T</span>]]</h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
