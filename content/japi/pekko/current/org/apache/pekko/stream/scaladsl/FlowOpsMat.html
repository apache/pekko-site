<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.17) on Wed Mar 01 23:28:13 CET 2023 -->
<title>FlowOpsMat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-03-01">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="FlowOpsMat";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":38,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6,"i23":6,"i24":6,"i25":6,"i26":6,"i27":6,"i28":6,"i29":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.stream.scaladsl</a></div>
<h2 title="Interface FlowOpsMat" class="title">Interface FlowOpsMat&lt;Out,&#8203;Mat&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd><code><a href="FlowOps.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOps</a>&lt;Out,&#8203;Mat&gt;</code></dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a></code>, <code><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">FlowOpsMat&lt;Out,&#8203;Mat&gt;</span>
extends <a href="FlowOps.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOps</a>&lt;Out,&#8203;Mat&gt;</pre>
<div class="block">INTERNAL API: this trait will be changed in binary-incompatible ways for classes that are derived from it!
 Do not implement this interface outside the Akka code base!
 <p>
 Binary compatibility is only maintained for callers of this trait&amp;rsquo;s interface.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#alsoToMat(org.apache.pekko.stream.Graph,scala.Function2)">alsoToMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
         scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that elements that pass
 through will also be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatLazyMat(org.apache.pekko.stream.Graph,scala.Function2)">concatLazyMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
             scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatMat(org.apache.pekko.stream.Graph,scala.Function2)">concatMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
         scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#divertToMat(org.apache.pekko.stream.Graph,scala.Function1,scala.Function2)">divertToMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
           scala.Function1&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;java.lang.Object&gt;&nbsp;when,
           scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that elements will be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a>
 instead of being passed through if the predicate <code>when</code> returns <code>true</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapPrefixMat(int,scala.Function1,scala.Function2)">flatMapPrefixMat</a></span>&#8203;(int&nbsp;n,
                scala.Function1&lt;scala.collection.immutable.Seq&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Mat2&gt;&gt;&nbsp;f,
                scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;scala.concurrent.Future&lt;Mat2&gt;,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">mat version of <a href="FlowOps.html#flatMapPrefix(int,scala.Function1)"><code>FlowOps.flatMapPrefix(int, scala.Function1&lt;scala.collection.immutable.Seq&lt;Out&gt;, org.apache.pekko.stream.scaladsl.Flow&lt;Out, Out2, Mat2&gt;&gt;)</code></a>, this method gives access to a future materialized value of the downstream flow.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#interleaveMat(org.apache.pekko.stream.Graph,int,boolean,scala.Function2)">interleaveMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
             int&nbsp;segmentSize,
             boolean&nbsp;eagerClose,
             scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#interleaveMat(org.apache.pekko.stream.Graph,int,scala.Function2)">interleaveMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
             int&nbsp;segmentSize,
             scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapMaterializedValue(scala.Function1)">mapMaterializedValue</a></span>&#8203;(scala.Function1&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Transform the materialized value of this graph, leaving all other properties as they were.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeLatestMat(org.apache.pekko.stream.Graph,boolean,scala.Function2)">mergeLatestMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
              boolean&nbsp;eagerClose,
              scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">MergeLatest joins elements from N input streams into stream of lists of size N.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeMat(org.apache.pekko.stream.Graph,boolean,scala.Function2)">mergeMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
        boolean&nbsp;eagerComplete,
        scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, taking elements as they arrive from input streams,
 picking randomly when several elements ready.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeMat$default$2()">mergeMat$default$2</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePreferredMat(org.apache.pekko.stream.Graph,boolean,boolean,scala.Function2)">mergePreferredMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                 boolean&nbsp;preferred,
                 boolean&nbsp;eagerClose,
                 scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Merge two sources.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePrioritizedMat(org.apache.pekko.stream.Graph,int,int,boolean,scala.Function2)">mergePrioritizedMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                   int&nbsp;leftPriority,
                   int&nbsp;rightPriority,
                   boolean&nbsp;eagerClose,
                   scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Merge two sources.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeSortedMat(org.apache.pekko.stream.Graph,scala.Function2,scala.math.Ordering)">mergeSortedMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
              scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF,
              scala.math.Ordering&lt;U&gt;&nbsp;ord)</code></th>
<td class="colLast">
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, taking elements as they arrive from input streams,
 picking always the smallest of the available elements (waiting for one element from each side
 to be available).</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#monitor()">monitor</a></span>()</code></th>
<td class="colLast">
<div class="block">Materializes to <code>(Mat, FlowMonitor[Out])</code>, which is unlike most other operators (!),
 in which usually the default materialized value keeping semantics is to keep the left value
 (by passing <code>Keep.left()</code> to a <code>*Mat</code> version of a method).</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#monitor(scala.Function2)">monitor</a></span>&#8203;(scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use monitor() or monitorMat(combine) instead.</div>
</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#monitorMat(scala.Function2)">monitorMat</a></span>&#8203;(scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orElseMat(org.apache.pekko.stream.Graph,scala.Function2)">orElseMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;secondary,
         scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Provides a secondary source that will be consumed if this stream completes without any
 elements passing by.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prependLazyMat(org.apache.pekko.stream.Graph,scala.Function2)">prependLazyMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
              scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prependMat(org.apache.pekko.stream.Graph,scala.Function2)">prependMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
          scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toMat(org.apache.pekko.stream.Graph,scala.Function2)">toMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;sink,
     scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Connect this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a> to a <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a>, concatenating the processing steps of both.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#viaMat(org.apache.pekko.stream.Graph,scala.Function2)">viaMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../FlowShape.html" title="class in org.apache.pekko.stream">FlowShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;T&gt;,&#8203;Mat2&gt;&nbsp;flow,
      scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;combine)</code></th>
<td class="colLast">
<div class="block">Transform this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a> by appending the given processing steps.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#watchTermination(scala.Function2)">watchTermination</a></span>&#8203;(scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;,&#8203;Mat2&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Materializes to <code>Future[Done]</code> that completes on getting termination message.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>&lt;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#wireTapMat(org.apache.pekko.stream.Graph,scala.Function2)">wireTapMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
          scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a> as a wire tap, meaning that elements that pass
 through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3,&#8203;A&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipAllMat(org.apache.pekko.stream.Graph,A,U,scala.Function2)">zipAllMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
         A&nbsp;thisElem,
         U&nbsp;thatElem,
         scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> into a stream of tuples.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestMat(org.apache.pekko.stream.Graph,scala.Function2)">zipLatestMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
            scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> into a stream of tuples,
 picking always the latest of the elements of each source.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestWithMat(org.apache.pekko.stream.Graph,boolean,scala.Function2,scala.Function2)">zipLatestWithMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;Mat2&gt;&nbsp;that,
                boolean&nbsp;eagerComplete,
                scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Put together the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>
 into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipLatestWithMat(org.apache.pekko.stream.Graph,scala.Function2,scala.Function2)">zipLatestWithMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;Mat2&gt;&nbsp;that,
                scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Put together the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>
 into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipMat(org.apache.pekko.stream.Graph,scala.Function2)">zipMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
      scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> into a stream of tuples.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>&lt;Out2,&#8203;Out3,&#8203;Mat2,&#8203;Mat3&gt;<br><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWithMat(org.apache.pekko.stream.Graph,scala.Function2,scala.Function2)">zipWithMat</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;Mat2&gt;&nbsp;that,
          scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
          scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Put together the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>
 into a stream of combined elements using a combiner function.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.stream.scaladsl.FlowOps">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.stream.scaladsl.<a href="FlowOps.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOps</a></h3>
<code><a href="FlowOps.html#$plus$plus(org.apache.pekko.stream.Graph)">$plus$plus</a>, <a href="FlowOps.html#addAttributes(org.apache.pekko.stream.Attributes)">addAttributes</a>, <a href="FlowOps.html#aggregateWithBoundary(scala.Function0,scala.Function2,scala.Function1,scala.Option)">aggregateWithBoundary</a>, <a href="FlowOps.html#alsoTo(org.apache.pekko.stream.Graph)">alsoTo</a>, <a href="FlowOps.html#alsoToAll(scala.collection.immutable.Seq)">alsoToAll</a>, <a href="FlowOps.html#alsoToGraph(org.apache.pekko.stream.Graph)">alsoToGraph</a>, <a href="FlowOps.html#ask(int,org.apache.pekko.actor.ActorRef,org.apache.pekko.util.Timeout,scala.reflect.ClassTag)">ask</a>, <a href="FlowOps.html#ask(org.apache.pekko.actor.ActorRef,org.apache.pekko.util.Timeout,scala.reflect.ClassTag)">ask</a>, <a href="FlowOps.html#async()">async</a>, <a href="FlowOps.html#backpressureTimeout(scala.concurrent.duration.FiniteDuration)">backpressureTimeout</a>, <a href="FlowOps.html#batch(long,scala.Function1,scala.Function2)">batch</a>, <a href="FlowOps.html#batchWeighted(long,scala.Function1,scala.Function1,scala.Function2)">batchWeighted</a>, <a href="FlowOps.html#buffer(int,org.apache.pekko.stream.OverflowStrategy)">buffer</a>, <a href="FlowOps.html#collect(scala.PartialFunction)">collect</a>, <a href="FlowOps.html#collectType(scala.reflect.ClassTag)">collectType</a>, <a href="FlowOps.html#completionTimeout(scala.concurrent.duration.FiniteDuration)">completionTimeout</a>, <a href="FlowOps.html#concat(org.apache.pekko.stream.Graph)">concat</a>, <a href="FlowOps.html#concatAllLazy(scala.collection.immutable.Seq)">concatAllLazy</a>, <a href="FlowOps.html#concatGraph(org.apache.pekko.stream.Graph,boolean)">concatGraph</a>, <a href="FlowOps.html#concatLazy(org.apache.pekko.stream.Graph)">concatLazy</a>, <a href="FlowOps.html#conflate(scala.Function2)">conflate</a>, <a href="FlowOps.html#conflateWithSeed(scala.Function1,scala.Function2)">conflateWithSeed</a>, <a href="FlowOps.html#delay(scala.concurrent.duration.FiniteDuration,org.apache.pekko.stream.DelayOverflowStrategy)">delay</a>, <a href="FlowOps.html#delay$default$2()">delay$default$2</a>, <a href="FlowOps.html#delayWith(scala.Function0,org.apache.pekko.stream.DelayOverflowStrategy)">delayWith</a>, <a href="FlowOps.html#detach()">detach</a>, <a href="FlowOps.html#divertTo(org.apache.pekko.stream.Graph,scala.Function1)">divertTo</a>, <a href="FlowOps.html#divertToGraph(org.apache.pekko.stream.Graph,scala.Function1)">divertToGraph</a>, <a href="FlowOps.html#drop(long)">drop</a>, <a href="FlowOps.html#dropWhile(scala.Function1)">dropWhile</a>, <a href="FlowOps.html#dropWithin(scala.concurrent.duration.FiniteDuration)">dropWithin</a>, <a href="FlowOps.html#expand(scala.Function1)">expand</a>, <a href="FlowOps.html#extrapolate(scala.Function1,scala.Option)">extrapolate</a>, <a href="FlowOps.html#extrapolate$default$2()">extrapolate$default$2</a>, <a href="FlowOps.html#filter(scala.Function1)">filter</a>, <a href="FlowOps.html#filterNot(scala.Function1)">filterNot</a>, <a href="FlowOps.html#flatMapConcat(scala.Function1)">flatMapConcat</a>, <a href="FlowOps.html#flatMapMerge(int,scala.Function1)">flatMapMerge</a>, <a href="FlowOps.html#flatMapPrefix(int,scala.Function1)">flatMapPrefix</a>, <a href="FlowOps.html#fold(T,scala.Function2)">fold</a>, <a href="FlowOps.html#foldAsync(T,scala.Function2)">foldAsync</a>, <a href="FlowOps.html#groupBy(int,scala.Function1)">groupBy</a>, <a href="FlowOps.html#groupBy(int,scala.Function1,boolean)">groupBy</a>, <a href="FlowOps.html#grouped(int)">grouped</a>, <a href="FlowOps.html#groupedWeighted(long,scala.Function1)">groupedWeighted</a>, <a href="FlowOps.html#groupedWeightedWithin(long,int,scala.concurrent.duration.FiniteDuration,scala.Function1)">groupedWeightedWithin</a>, <a href="FlowOps.html#groupedWeightedWithin(long,scala.concurrent.duration.FiniteDuration,scala.Function1)">groupedWeightedWithin</a>, <a href="FlowOps.html#groupedWithin(int,scala.concurrent.duration.FiniteDuration)">groupedWithin</a>, <a href="FlowOps.html#idleTimeout(scala.concurrent.duration.FiniteDuration)">idleTimeout</a>, <a href="FlowOps.html#initialDelay(scala.concurrent.duration.FiniteDuration)">initialDelay</a>, <a href="FlowOps.html#initialTimeout(scala.concurrent.duration.FiniteDuration)">initialTimeout</a>, <a href="FlowOps.html#interleave(org.apache.pekko.stream.Graph,int)">interleave</a>, <a href="FlowOps.html#interleave(org.apache.pekko.stream.Graph,int,boolean)">interleave</a>, <a href="FlowOps.html#interleaveAll(scala.collection.immutable.Seq,int,boolean)">interleaveAll</a>, <a href="FlowOps.html#interleaveGraph(org.apache.pekko.stream.Graph,int,boolean)">interleaveGraph</a>, <a href="FlowOps.html#interleaveGraph$default$3()">interleaveGraph$default$3</a>, <a href="FlowOps.html#internalConcat(org.apache.pekko.stream.Graph,boolean)">internalConcat</a>, <a href="FlowOps.html#internalConcatAll(org.apache.pekko.stream.Graph%5B%5D,boolean)">internalConcatAll</a>, <a href="FlowOps.html#intersperse(T)">intersperse</a>, <a href="FlowOps.html#intersperse(T,T,T)">intersperse</a>, <a href="FlowOps.html#keepAlive(scala.concurrent.duration.FiniteDuration,scala.Function0)">keepAlive</a>, <a href="FlowOps.html#limit(long)">limit</a>, <a href="FlowOps.html#limitWeighted(long,scala.Function1)">limitWeighted</a>, <a href="FlowOps.html#log(java.lang.String,scala.Function1,org.apache.pekko.event.LoggingAdapter)">log</a>, <a href="FlowOps.html#log$default$2()">log$default$2</a>, <a href="FlowOps.html#log$default$3(java.lang.String,scala.Function1)">log$default$3</a>, <a href="FlowOps.html#logWithMarker(java.lang.String,scala.Function1,scala.Function1,org.apache.pekko.event.MarkerLoggingAdapter)">logWithMarker</a>, <a href="FlowOps.html#logWithMarker$default$3()">logWithMarker$default$3</a>, <a href="FlowOps.html#logWithMarker$default$4(java.lang.String,scala.Function1,scala.Function1)">logWithMarker$default$4</a>, <a href="FlowOps.html#map(scala.Function1)">map</a>, <a href="FlowOps.html#mapAsync(int,scala.Function1)">mapAsync</a>, <a href="FlowOps.html#mapAsyncUnordered(int,scala.Function1)">mapAsyncUnordered</a>, <a href="FlowOps.html#mapConcat(scala.Function1)">mapConcat</a>, <a href="FlowOps.html#mapError(scala.PartialFunction)">mapError</a>, <a href="FlowOps.html#merge(org.apache.pekko.stream.Graph,boolean)">merge</a>, <a href="FlowOps.html#merge$default$2()">merge$default$2</a>, <a href="FlowOps.html#mergeAll(scala.collection.immutable.Seq,boolean)">mergeAll</a>, <a href="FlowOps.html#mergeGraph(org.apache.pekko.stream.Graph,boolean)">mergeGraph</a>, <a href="FlowOps.html#mergeLatest(org.apache.pekko.stream.Graph,boolean)">mergeLatest</a>, <a href="FlowOps.html#mergeLatest$default$2()">mergeLatest$default$2</a>, <a href="FlowOps.html#mergeLatestGraph(org.apache.pekko.stream.Graph,boolean)">mergeLatestGraph</a>, <a href="FlowOps.html#mergePreferred(org.apache.pekko.stream.Graph,boolean,boolean)">mergePreferred</a>, <a href="FlowOps.html#mergePreferred$default$3()">mergePreferred$default$3</a>, <a href="FlowOps.html#mergePreferredGraph(org.apache.pekko.stream.Graph,boolean,boolean)">mergePreferredGraph</a>, <a href="FlowOps.html#mergePrioritized(org.apache.pekko.stream.Graph,int,int,boolean)">mergePrioritized</a>, <a href="FlowOps.html#mergePrioritized$default$4()">mergePrioritized$default$4</a>, <a href="FlowOps.html#mergePrioritizedGraph(org.apache.pekko.stream.Graph,int,int,boolean)">mergePrioritizedGraph</a>, <a href="FlowOps.html#mergeSorted(org.apache.pekko.stream.Graph,scala.math.Ordering)">mergeSorted</a>, <a href="FlowOps.html#mergeSortedGraph(org.apache.pekko.stream.Graph,scala.math.Ordering)">mergeSortedGraph</a>, <a href="FlowOps.html#named(java.lang.String)">named</a>, <a href="FlowOps.html#orElse(org.apache.pekko.stream.Graph)">orElse</a>, <a href="FlowOps.html#orElseGraph(org.apache.pekko.stream.Graph)">orElseGraph</a>, <a href="FlowOps.html#prefixAndTail(int)">prefixAndTail</a>, <a href="FlowOps.html#prepend(org.apache.pekko.stream.Graph)">prepend</a>, <a href="FlowOps.html#prependGraph(org.apache.pekko.stream.Graph,boolean)">prependGraph</a>, <a href="FlowOps.html#prependLazy(org.apache.pekko.stream.Graph)">prependLazy</a>, <a href="FlowOps.html#recover(scala.PartialFunction)">recover</a>, <a href="FlowOps.html#recoverWith(scala.PartialFunction)">recoverWith</a>, <a href="FlowOps.html#recoverWithRetries(int,scala.PartialFunction)">recoverWithRetries</a>, <a href="FlowOps.html#reduce(scala.Function2)">reduce</a>, <a href="FlowOps.html#scan(T,scala.Function2)">scan</a>, <a href="FlowOps.html#scanAsync(T,scala.Function2)">scanAsync</a>, <a href="FlowOps.html#sliding(int,int)">sliding</a>, <a href="FlowOps.html#sliding$default$2()">sliding$default$2</a>, <a href="FlowOps.html#splitAfter(org.apache.pekko.stream.SubstreamCancelStrategy,scala.Function1)">splitAfter</a>, <a href="FlowOps.html#splitAfter(scala.Function1)">splitAfter</a>, <a href="FlowOps.html#splitWhen(org.apache.pekko.stream.SubstreamCancelStrategy,scala.Function1)">splitWhen</a>, <a href="FlowOps.html#splitWhen(scala.Function1)">splitWhen</a>, <a href="FlowOps.html#statefulMap(scala.Function0,scala.Function2,scala.Function1)">statefulMap</a>, <a href="FlowOps.html#statefulMapConcat(scala.Function0)">statefulMapConcat</a>, <a href="FlowOps.html#take(long)">take</a>, <a href="FlowOps.html#takeWhile(scala.Function1)">takeWhile</a>, <a href="FlowOps.html#takeWhile(scala.Function1,boolean)">takeWhile</a>, <a href="FlowOps.html#takeWithin(scala.concurrent.duration.FiniteDuration)">takeWithin</a>, <a href="FlowOps.html#throttle(int,scala.concurrent.duration.FiniteDuration)">throttle</a>, <a href="FlowOps.html#throttle(int,scala.concurrent.duration.FiniteDuration,int,org.apache.pekko.stream.ThrottleMode)">throttle</a>, <a href="FlowOps.html#throttle(int,scala.concurrent.duration.FiniteDuration,int,scala.Function1,org.apache.pekko.stream.ThrottleMode)">throttle</a>, <a href="FlowOps.html#throttle(int,scala.concurrent.duration.FiniteDuration,scala.Function1)">throttle</a>, <a href="FlowOps.html#throttleEven(int,scala.concurrent.duration.FiniteDuration,org.apache.pekko.stream.ThrottleMode)">throttleEven</a>, <a href="FlowOps.html#throttleEven(int,scala.concurrent.duration.FiniteDuration,scala.Function1,org.apache.pekko.stream.ThrottleMode)">throttleEven</a>, <a href="FlowOps.html#to(org.apache.pekko.stream.Graph)">to</a>, <a href="FlowOps.html#via(org.apache.pekko.stream.Graph)">via</a>, <a href="FlowOps.html#watch(org.apache.pekko.actor.ActorRef)">watch</a>, <a href="FlowOps.html#wireTap(org.apache.pekko.stream.Graph)">wireTap</a>, <a href="FlowOps.html#wireTap(scala.Function1)">wireTap</a>, <a href="FlowOps.html#wireTapGraph(org.apache.pekko.stream.Graph)">wireTapGraph</a>, <a href="FlowOps.html#withAttributes(org.apache.pekko.stream.Attributes)">withAttributes</a>, <a href="FlowOps.html#zip(org.apache.pekko.stream.Graph)">zip</a>, <a href="FlowOps.html#zipAll(org.apache.pekko.stream.Graph,A,U)">zipAll</a>, <a href="FlowOps.html#zipAllFlow(org.apache.pekko.stream.Graph,A,U)">zipAllFlow</a>, <a href="FlowOps.html#zipGraph(org.apache.pekko.stream.Graph)">zipGraph</a>, <a href="FlowOps.html#zipLatest(org.apache.pekko.stream.Graph)">zipLatest</a>, <a href="FlowOps.html#zipLatestGraph(org.apache.pekko.stream.Graph)">zipLatestGraph</a>, <a href="FlowOps.html#zipLatestWith(org.apache.pekko.stream.Graph,boolean,scala.Function2)">zipLatestWith</a>, <a href="FlowOps.html#zipLatestWith(org.apache.pekko.stream.Graph,scala.Function2)">zipLatestWith</a>, <a href="FlowOps.html#zipLatestWithGraph(org.apache.pekko.stream.Graph,boolean,scala.Function2)">zipLatestWithGraph</a>, <a href="FlowOps.html#zipLatestWithGraph(org.apache.pekko.stream.Graph,scala.Function2)">zipLatestWithGraph</a>, <a href="FlowOps.html#zipWith(org.apache.pekko.stream.Graph,scala.Function2)">zipWith</a>, <a href="FlowOps.html#zipWithGraph(org.apache.pekko.stream.Graph,scala.Function2)">zipWithGraph</a>, <a href="FlowOps.html#zipWithIndex()">zipWithIndex</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="alsoToMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>alsoToMat</h4>
<pre class="methodSignature">&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;alsoToMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                                       scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that elements that pass
 through will also be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a>.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="FlowOps.html#alsoTo(org.apache.pekko.stream.Graph)"><code>
 It is recommended to use the internally optimized Keep.left and Keep.right combiners
 where appropriate instead of manually writing functions that pass through one of the values.</code></a></dd>
</dl>
</li>
</ul>
<a id="concatLazyMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatLazyMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;concatLazyMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                   scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> is materialized together with this Flow, if <code>lazy</code> materialization is what is needed
 the operator can be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>.
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 For a concat operator that is detached, use <a href="#concatMat(org.apache.pekko.stream.Graph,scala.Function2)"><code>concatMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;U&gt;, Mat2&gt;, scala.Function2&lt;Mat, Mat2, Mat3&gt;)</code></a>
 <p></div>
</li>
</ul>
<a id="concatMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;concatMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                               scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Concatenate the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that once this
 Flow&amp;rsquo;s input is exhausted and all result elements have been generated,
 the Source&amp;rsquo;s elements will be produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> is materialized together with this Flow and is "detached" meaning it will
 in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
 (so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).
 <p>
 The second source is then kept from producing elements by asserting back-pressure until its time comes.
 <p>
 When needing a concat operator that is not detached use <a href="#concatLazyMat(org.apache.pekko.stream.Graph,scala.Function2)"><code>concatLazyMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;U&gt;, Mat2&gt;, scala.Function2&lt;Mat, Mat2, Mat3&gt;)</code></a>
 <p></div>
</li>
</ul>
<a id="divertToMat(org.apache.pekko.stream.Graph,scala.Function1,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divertToMat</h4>
<pre class="methodSignature">&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;divertToMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                                         scala.Function1&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;java.lang.Object&gt;&nbsp;when,
                                         scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that elements will be sent to the <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a>
 instead of being passed through if the predicate <code>when</code> returns <code>true</code>.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="FlowOps.html#divertTo(org.apache.pekko.stream.Graph,scala.Function1)"><code>
 It is recommended to use the internally optimized Keep.left and Keep.right combiners
 where appropriate instead of manually writing functions that pass through one of the values.</code></a></dd>
</dl>
</li>
</ul>
<a id="flatMapPrefixMat(int,scala.Function1,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapPrefixMat</h4>
<pre class="methodSignature">&lt;Out2,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;flatMapPrefixMat&#8203;(int&nbsp;n,
                                                         scala.Function1&lt;scala.collection.immutable.Seq&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;<a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl">Flow</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Mat2&gt;&gt;&nbsp;f,
                                                         scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;scala.concurrent.Future&lt;Mat2&gt;,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">mat version of <a href="FlowOps.html#flatMapPrefix(int,scala.Function1)"><code>FlowOps.flatMapPrefix(int, scala.Function1&lt;scala.collection.immutable.Seq&lt;Out&gt;, org.apache.pekko.stream.scaladsl.Flow&lt;Out, Out2, Mat2&gt;&gt;)</code></a>, this method gives access to a future materialized value of the downstream flow.
 see <a href="FlowOps.html#flatMapPrefix(int,scala.Function1)"><code>FlowOps.flatMapPrefix(int, scala.Function1&lt;scala.collection.immutable.Seq&lt;Out&gt;, org.apache.pekko.stream.scaladsl.Flow&lt;Out, Out2, Mat2&gt;&gt;)</code></a> for details.</div>
</li>
</ul>
<a id="interleaveMat(org.apache.pekko.stream.Graph,int,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interleaveMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;interleaveMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                   int&nbsp;segmentSize,
                                                   scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>.
 It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
 then repeat process.
 <p>
 After one of upstreams is complete then all the rest elements will be emitted from the second one
 <p>
 If it gets error from one of upstreams - stream completes with failure.
 <p></div>
</li>
</ul>
<a id="interleaveMat(org.apache.pekko.stream.Graph,int,boolean,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interleaveMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;interleaveMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                   int&nbsp;segmentSize,
                                                   boolean&nbsp;eagerClose,
                                                   scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Interleave is a deterministic merge of the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> with elements of this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>.
 It first emits <code>segmentSize</code> number of elements from this flow to downstream, then - same amount for <code>that</code> source,
 then repeat process.
 <p>
 If eagerClose is false and one of the upstreams complete the elements from the other upstream will continue passing
 through the interleave operator. If eagerClose is true and one of the upstream complete interleave will cancel the
 other upstream and complete itself.
 <p>
 If it gets error from one of upstreams - stream completes with failure.
 <p></div>
</li>
</ul>
<a id="mapMaterializedValue(scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapMaterializedValue</h4>
<pre class="methodSignature">&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;mapMaterializedValue&#8203;(scala.Function1&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2&gt;&nbsp;f)</pre>
<div class="block">Transform the materialized value of this graph, leaving all other properties as they were.</div>
</li>
</ul>
<a id="mergeLatestMat(org.apache.pekko.stream.Graph,boolean,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeLatestMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;mergeLatestMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                    boolean&nbsp;eagerClose,
                                                    scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">MergeLatest joins elements from N input streams into stream of lists of size N.
 i-th element in list is the latest emitted element from i-th input stream.
 MergeLatest emits list for each element emitted from some input stream,
 but only after each input stream emitted at least one element.
 <p></div>
</li>
</ul>
<a id="mergeMat(org.apache.pekko.stream.Graph,boolean,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;mergeMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                              boolean&nbsp;eagerComplete,
                                              scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, taking elements as they arrive from input streams,
 picking randomly when several elements ready.
 <p></div>
</li>
</ul>
<a id="mergeMat$default$2()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeMat$default$2</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;boolean&nbsp;mergeMat$default$2()</pre>
</li>
</ul>
<a id="mergePreferredMat(org.apache.pekko.stream.Graph,boolean,boolean,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePreferredMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;mergePreferredMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                       boolean&nbsp;preferred,
                                                       boolean&nbsp;eagerClose,
                                                       scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Merge two sources. Prefer one source if both sources have elements ready.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="FlowOps.html#mergePreferred(org.apache.pekko.stream.Graph,boolean,boolean)"><code>
 It is recommended to use the internally optimized Keep.left and Keep.right combiners
 where appropriate instead of manually writing functions that pass through one of the values.</code></a></dd>
</dl>
</li>
</ul>
<a id="mergePrioritizedMat(org.apache.pekko.stream.Graph,int,int,boolean,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePrioritizedMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;mergePrioritizedMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                         int&nbsp;leftPriority,
                                                         int&nbsp;rightPriority,
                                                         boolean&nbsp;eagerClose,
                                                         scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Merge two sources. Prefer the sources depending on the 'priority' parameters.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.</div>
</li>
</ul>
<a id="mergeSortedMat(org.apache.pekko.stream.Graph,scala.Function2,scala.math.Ordering)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSortedMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;mergeSortedMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                    scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF,
                                                    scala.math.Ordering&lt;U&gt;&nbsp;ord)</pre>
<div class="block">Merge the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, taking elements as they arrive from input streams,
 picking always the smallest of the available elements (waiting for one element from each side
 to be available). This means that possible contiguity of the input streams is not exploited to avoid
 waiting for elements, this merge will block when one of the inputs does not have more elements (and
 does not complete).
 <p></div>
</li>
</ul>
<a id="monitor(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monitor</h4>
<pre class="methodSignature">&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;monitor&#8203;(scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;combine)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use monitor() or monitorMat(combine) instead. Since Akka 2.5.17.</div>
</div>
<div class="block">Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.
 <p>
 The <code>combine</code> function is used to combine the <code>FlowMonitor</code> with this flow's materialized value.</div>
</li>
</ul>
<a id="monitor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monitor</h4>
<pre class="methodSignature"><a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;monitor()</pre>
<div class="block">Materializes to <code>(Mat, FlowMonitor[Out])</code>, which is unlike most other operators (!),
 in which usually the default materialized value keeping semantics is to keep the left value
 (by passing <code>Keep.left()</code> to a <code>*Mat</code> version of a method). This operator is an exception from
 that rule and keeps both values since dropping its sole purpose is to introduce that materialized value.
 <p>
 The <code>FlowMonitor[Out]</code> allows monitoring of the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.</div>
</li>
</ul>
<a id="monitorMat(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>monitorMat</h4>
<pre class="methodSignature">&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;monitorMat&#8203;(scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;<a href="../FlowMonitor.html" title="interface in org.apache.pekko.stream">FlowMonitor</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;combine)</pre>
<div class="block">Materializes to <code>FlowMonitor[Out]</code> that allows monitoring of the current flow. All events are propagated
 by the monitor unchanged. Note that the monitor inserts a memory barrier every time it processes an
 event, and may therefor affect performance.
 <p>
 The <code>combine</code> function is used to combine the <code>FlowMonitor</code> with this flow's materialized value.</div>
</li>
</ul>
<a id="orElseMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orElseMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;orElseMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;secondary,
                                               scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Provides a secondary source that will be consumed if this stream completes without any
 elements passing by. As soon as the first element comes through this stream, the alternative
 will be cancelled.
 <p>
 Note that this Flow will be materialized together with the <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> and just kept
 from producing elements by asserting back-pressure until its time comes or it gets
 cancelled.
 <p>
 On errors the operator is failed regardless of source of the error.
 <p>
 '''Emits when''' element is available from first stream or first stream closed without emitting any elements and an element
                  is available from the second stream
 <p>
 '''Backpressures when''' downstream backpressures
 <p>
 '''Completes when''' the primary stream completes after emitting at least one element, when the primary stream completes
                      without emitting and the secondary stream already has completed or when the secondary stream completes
 <p>
 '''Cancels when''' downstream cancels and additionally the alternative is cancelled as soon as an element passes
                    by from this stream.</div>
</li>
</ul>
<a id="prependLazyMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prependLazyMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;prependLazyMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                    scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.
 <p>
 Note that the <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> is materialized together with this Flow and is "detached" meaning
 in effect behave as a one element buffer in front of both the sources, that eagerly demands an element on start
 (so it can not be combined with <code>Source.lazy</code> to defer materialization of <code>that</code>).
 <p>
 This flow will then be kept from producing elements by asserting back-pressure until its time comes.
 <p>
 When needing a prepend operator that is not detached use <a href="#prependLazyMat(org.apache.pekko.stream.Graph,scala.Function2)"><code>prependLazyMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;U&gt;, Mat2&gt;, scala.Function2&lt;Mat, Mat2, Mat3&gt;)</code></a>
 <p></div>
</li>
</ul>
<a id="prependMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prependMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;prependMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Prepend the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a>, meaning that before elements
 are generated from this Flow, the Source's elements will be produced until it
 is exhausted, at which point Flow elements will start being produced.
 <p>
 Note that this Flow will be materialized together with the <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> and just kept
 from producing elements by asserting back-pressure until its time comes.
 <p>
 If the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> gets upstream error - no elements from this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a> will be pulled.
 <p>
 When needing a concat operator that is not detached use <a href="#prependLazyMat(org.apache.pekko.stream.Graph,scala.Function2)"><code>prependLazyMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SourceShape&lt;U&gt;, Mat2&gt;, scala.Function2&lt;Mat, Mat2, Mat3&gt;)</code></a>
 <p></div>
</li>
</ul>
<a id="toMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toMat</h4>
<pre class="methodSignature">&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&nbsp;toMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;sink,
                              scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;combine)</pre>
<div class="block">Connect this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a> to a <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a>, concatenating the processing steps of both.
 <pre><code>
     +----------------------------+
     | Resulting Sink             |
     |                            |
     |  +------+        +------+  |
     |  |      |        |      |  |
 In ~~&gt; | flow | ~Out~&gt; | sink |  |
     |  |      |        |      |  |
     |  +------+        +------+  |
     +----------------------------+
 </code></pre>
 The <code>combine</code> function is used to compose the materialized values of this flow and that
 Sink into the materialized value of the resulting Sink.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.</div>
</li>
</ul>
<a id="viaMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viaMat</h4>
<pre class="methodSignature">&lt;T,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;viaMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../FlowShape.html" title="class in org.apache.pekko.stream">FlowShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;T&gt;,&#8203;Mat2&gt;&nbsp;flow,
                                            scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;combine)</pre>
<div class="block">Transform this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a> by appending the given processing steps.
 <pre><code>
     +---------------------------------+
     | Resulting Flow[In, T, M2]       |
     |                                 |
     |  +------+            +------+   |
     |  |      |            |      |   |
 In ~~&gt; | this |  ~~Out~~&gt;  | flow |  ~~&gt; T
     |  |   Mat|            |     M|   |
     |  +------+            +------+   |
     +---------------------------------+
 </code></pre>
 The <code>combine</code> function is used to compose the materialized values of this flow and that
 flow into the materialized value of the resulting Flow.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.</div>
</li>
</ul>
<a id="watchTermination(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>watchTermination</h4>
<pre class="methodSignature">&lt;Mat2&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;watchTermination&#8203;(scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;,&#8203;Mat2&gt;&nbsp;matF)</pre>
<div class="block">Materializes to <code>Future[Done]</code> that completes on getting termination message.
 The Future completes with success when received complete message from upstream or cancel
 from downstream. It fails with the propagated error when received error message from
 upstream or downstream.
 <p>
 It is recommended to use the internally optimized <code>Keep.left</code> and <code>Keep.right</code> combiners
 where appropriate instead of manually writing functions that pass through one of the values.</div>
</li>
</ul>
<a id="wireTapMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wireTapMat</h4>
<pre class="methodSignature">&lt;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;wireTapMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>&gt;,&#8203;Mat2&gt;&nbsp;that,
                                        scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Attaches the given <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> to this <a href="Flow.html" title="class in org.apache.pekko.stream.scaladsl"><code>Flow</code></a> as a wire tap, meaning that elements that pass
 through will also be sent to the wire-tap Sink, without the latter affecting the mainline flow.
 If the wire-tap Sink backpressures, elements that would've been sent to it will be dropped instead.
 <p>
 It is similar to <a href="#alsoToMat(org.apache.pekko.stream.Graph,scala.Function2)"><code>alsoToMat(org.apache.pekko.stream.Graph&lt;org.apache.pekko.stream.SinkShape&lt;Out&gt;, Mat2&gt;, scala.Function2&lt;Mat, Mat2, Mat3&gt;)</code></a> which does backpressure instead of dropping elements.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="FlowOps.html#wireTap(scala.Function1)"><code>
 It is recommended to use the internally optimized Keep.left and Keep.right combiners
 where appropriate instead of manually writing functions that pass through one of the values.</code></a></dd>
</dl>
</li>
</ul>
<a id="zipAllMat(org.apache.pekko.stream.Graph,java.lang.Object,java.lang.Object,scala.Function2)">
<!--   -->
</a><a id="zipAllMat(org.apache.pekko.stream.Graph,A,U,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipAllMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3,&#8203;A&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;zipAllMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                       A&nbsp;thisElem,
                                                       U&nbsp;thatElem,
                                                       scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> into a stream of tuples.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="FlowOps.html#zipAll(org.apache.pekko.stream.Graph,A,U)"><code>
 '''Emits when''' at first emits when both inputs emit, and then as long as any input emits (coupled to the default value of the completed input).
 
 '''Backpressures when''' downstream backpressures
 
 '''Completes when''' all upstream completes
 
 '''Cancels when''' downstream cancels</code></a></dd>
</dl>
</li>
</ul>
<a id="zipLatestMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;zipLatestMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                  scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> into a stream of tuples,
 picking always the latest of the elements of each source.
 <p></div>
</li>
</ul>
<a id="zipLatestWithMat(org.apache.pekko.stream.Graph,scala.Function2,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestWithMat</h4>
<pre class="methodSignature">&lt;Out2,&#8203;Out3,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;zipLatestWithMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                                    scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                                                                    scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Put together the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>
 into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.
 <p></div>
</li>
</ul>
<a id="zipLatestWithMat(org.apache.pekko.stream.Graph,boolean,scala.Function2,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatestWithMat</h4>
<pre class="methodSignature">&lt;Out2,&#8203;Out3,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;zipLatestWithMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                                    boolean&nbsp;eagerComplete,
                                                                    scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                                                                    scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Put together the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>
 into a stream of combined elements using a combiner function, picking always the latest of the elements of each source.
 <p></div>
</li>
</ul>
<a id="zipMat(org.apache.pekko.stream.Graph,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipMat</h4>
<pre class="methodSignature">&lt;U,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;zipMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;U&gt;,&#8203;Mat2&gt;&nbsp;that,
                                            scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Combine the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> into a stream of tuples.
 <p></div>
</li>
</ul>
<a id="zipWithMat(org.apache.pekko.stream.Graph,scala.Function2,scala.Function2)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>zipWithMat</h4>
<pre class="methodSignature">&lt;Out2,&#8203;Out3,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;<a href="FlowOpsMat.html" title="interface in org.apache.pekko.stream.scaladsl">FlowOpsMat</a>&nbsp;zipWithMat&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;Out2&gt;,&#8203;Mat2&gt;&nbsp;that,
                                                              scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Out</a>,&#8203;Out2,&#8203;Out3&gt;&nbsp;combine,
                                                              scala.Function2&lt;<a href="FlowOpsMat.html" title="type parameter in FlowOpsMat">Mat</a>,&#8203;Mat2,&#8203;Mat3&gt;&nbsp;matF)</pre>
<div class="block">Put together the elements of current flow and the given <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>
 into a stream of combined elements using a combiner function.
 <p></div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
