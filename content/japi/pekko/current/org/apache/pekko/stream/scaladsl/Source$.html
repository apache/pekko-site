<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.17) on Wed Mar 01 23:28:13 CET 2023 -->
<title>Source$</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-03-01">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Source$";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":42,"i1":10,"i2":42,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":42,"i13":42,"i14":42,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":42,"i21":10,"i22":10,"i23":42,"i24":42,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":42,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.stream.scaladsl</a></div>
<h2 title="Class Source$" class="title">Class Source$</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.apache.pekko.stream.scaladsl.Source$</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">Source$</span>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="Source$.html" title="class in org.apache.pekko.stream.scaladsl">Source$</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#MODULE$">MODULE$</a></span></code></th>
<td class="colLast">
<div class="block">Static reference to the singleton instance of this Scala object.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Source$</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRef(int,org.apache.pekko.stream.OverflowStrategy)">actorRef</a></span>&#8203;(int&nbsp;bufferSize,
        <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use variant accepting completion and failure matchers instead.</div>
</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRef(scala.PartialFunction,scala.PartialFunction,int,org.apache.pekko.stream.OverflowStrategy)">actorRef</a></span>&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&nbsp;completionMatcher,
        scala.PartialFunction&lt;java.lang.Object,&#8203;java.lang.Throwable&gt;&nbsp;failureMatcher,
        int&nbsp;bufferSize,
        <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithAck(java.lang.Object)">actorRefWithAck</a></span>&#8203;(java.lang.Object&nbsp;ackMessage)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure accepting completion and failure matchers instead.</div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithBackpressure(java.lang.Object,scala.PartialFunction,scala.PartialFunction)">actorRefWithBackpressure</a></span>&#8203;(java.lang.Object&nbsp;ackMessage,
                        scala.PartialFunction&lt;java.lang.Object,&#8203;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&nbsp;completionMatcher,
                        scala.PartialFunction&lt;java.lang.Object,&#8203;java.lang.Throwable&gt;&nbsp;failureMatcher)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#apply(scala.collection.immutable.Iterable)">apply</a></span>&#8203;(scala.collection.immutable.Iterable&lt;T&gt;&nbsp;iterable)</code></th>
<td class="colLast">
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> from <code>Iterable</code>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;org.reactivestreams.Subscriber&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asSubscriber()">asSubscriber</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as a <code>Subscriber</code></div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;U&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;U,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combine(org.apache.pekko.stream.scaladsl.Source,org.apache.pekko.stream.scaladsl.Source,scala.collection.immutable.Seq,scala.Function1)">combine</a></span>&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;first,
       <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;second,
       scala.collection.immutable.Seq&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;rest,
       scala.Function1&lt;java.lang.Object,&#8203;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy)</code></th>
<td class="colLast">
<div class="block">Combines several sources with fan-in strategy like <a href="Merge.html" title="class in org.apache.pekko.stream.scaladsl"><code>Merge</code></a> or <a href="Concat.html" title="class in org.apache.pekko.stream.scaladsl"><code>Concat</code></a> into a single <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;U,&#8203;M1,&#8203;M2,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;U,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combineMat(org.apache.pekko.stream.scaladsl.Source,org.apache.pekko.stream.scaladsl.Source,scala.Function1,scala.Function2)">combineMat</a></span>&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M1&gt;&nbsp;first,
          <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M2&gt;&nbsp;second,
          scala.Function1&lt;java.lang.Object,&#8203;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy,
          scala.Function2&lt;M1,&#8203;M2,&#8203;M&gt;&nbsp;matF)</code></th>
<td class="colLast">
<div class="block">Combines several sources with fan-in strategy like <a href="Merge.html" title="class in org.apache.pekko.stream.scaladsl"><code>Merge</code></a> or <a href="Concat.html" title="class in org.apache.pekko.stream.scaladsl"><code>Concat</code></a> into a single <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> with a materialized value.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completionStage(java.util.concurrent.CompletionStage)">completionStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;completionStage)</code></th>
<td class="colLast">
<div class="block">Emits a single value when the given <code>CompletionStage</code> is successfully completed and then completes the stream.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cycle(scala.Function0)">cycle</a></span>&#8203;(scala.Function0&lt;scala.collection.Iterator&lt;T&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Creates <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> that will continually produce given elements in specified order.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#empty()">empty</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Source</code> with no elements, i.e.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#failed(java.lang.Throwable)">failed</a></span>&#8203;(java.lang.Throwable&nbsp;cause)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> that immediately ends the stream with the <code>cause</code> error to every connected <code>Sink</code>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromCompletionStage(java.util.concurrent.CompletionStage)">fromCompletionStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.completionStage' instead.</div>
</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromFuture(scala.concurrent.Future)">fromFuture</a></span>&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.future' instead.</div>
</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromFutureSource(scala.concurrent.Future)">fromFutureSource</a></span>&#8203;(scala.concurrent.Future&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.futureSource' (potentially together with `Source.fromGraph`) instead.</div>
</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromGraph(org.apache.pekko.stream.Graph)">fromGraph</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;g)</code></th>
<td class="colLast">
<div class="block">A graph with the shape of a source logically is a source, this method makes
 it so also in type.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromIterator(scala.Function0)">fromIterator</a></span>&#8203;(scala.Function0&lt;scala.collection.Iterator&lt;T&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> from <code>Iterator</code>.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;S extends java.util.stream.BaseStream&lt;T,&#8203;S&gt;&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromJavaStream(scala.Function0)">fromJavaStream</a></span>&#8203;(scala.Function0&lt;java.util.stream.BaseStream&lt;T,&#8203;S&gt;&gt;&nbsp;stream)</code></th>
<td class="colLast">
<div class="block">Creates a source that wraps a Java 8 <code></code>Stream<code></code>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromMaterializer(scala.Function2)">fromMaterializer</a></span>&#8203;(scala.Function2&lt;<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</code></th>
<td class="colLast">
<div class="block">Defers the creation of a <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> until materialization.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromPublisher(org.reactivestreams.Publisher)">fromPublisher</a></span>&#8203;(org.reactivestreams.Publisher&lt;T&gt;&nbsp;publisher)</code></th>
<td class="colLast">
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> from <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromSourceCompletionStage(java.util.concurrent.CompletionStage)">fromSourceCompletionStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;completion)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scala-compat CompletionStage to future converter and 'Source.futureSource' instead.</div>
</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#future(scala.concurrent.Future)">future</a></span>&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;futureElement)</code></th>
<td class="colLast">
<div class="block">Emits a single value when the given <code>Future</code> is successfully completed and then completes the stream.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#futureSource(scala.concurrent.Future)">futureSource</a></span>&#8203;(scala.concurrent.Future&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;futureSource)</code></th>
<td class="colLast">
<div class="block">Turn a <code>Future[Source]</code> into a source that will emit the values of the source when the future completes successfully.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazily(scala.Function0)">lazily</a></span>&#8203;(scala.Function0&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazySource' instead.</div>
</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazilyAsync(scala.Function0)">lazilyAsync</a></span>&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazyFuture' instead.</div>
</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazyFuture(scala.Function0)">lazyFuture</a></span>&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a future element until there is downstream demand.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazyFutureSource(scala.Function0)">lazyFutureSource</a></span>&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazySingle(scala.Function0)">lazySingle</a></span>&#8203;(scala.Function0&lt;T&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a single element until there is downstream demand.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazySource(scala.Function0)">lazySource</a></span>&#8203;(scala.Function0&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Promise&lt;scala.Option&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maybe()">maybe</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> which materializes a <code>Promise</code> which controls what element
 will be emitted by the Source.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergePrioritizedN(scala.collection.immutable.Seq,boolean)">mergePrioritizedN</a></span>&#8203;(scala.collection.immutable.Seq&lt;scala.Tuple2&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;,&#8203;java.lang.Object&gt;&gt;&nbsp;sourcesAndPriorities,
                 boolean&nbsp;eagerComplete)</code></th>
<td class="colLast">
<div class="block">Merge multiple <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>s.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#never()">never</a></span>()</code></th>
<td class="colLast">
<div class="block">Never emits any elements, never completes and never fails.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../BoundedSourceQueue.html" title="interface in org.apache.pekko.stream">BoundedSourceQueue</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue(int)">queue</a></span>&#8203;(int&nbsp;bufferSize)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.BoundedSourceQueue</code>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.scaladsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue(int,org.apache.pekko.stream.OverflowStrategy)">queue</a></span>&#8203;(int&nbsp;bufferSize,
     <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.scaladsl.SourceQueueWithComplete</code>.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.scaladsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue(int,org.apache.pekko.stream.OverflowStrategy,int)">queue</a></span>&#8203;(int&nbsp;bufferSize,
     <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy,
     int&nbsp;maxConcurrentOffers)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.scaladsl.SourceQueueWithComplete</code>.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeat(T)">repeat</a></span>&#8203;(T&nbsp;element)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> that will continually emit the given element.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setup(scala.Function2)">setup</a></span>&#8203;(scala.Function2&lt;<a href="../ActorMaterializer.html" title="class in org.apache.pekko.stream">ActorMaterializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'fromMaterializer' instead.</div>
</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shape(java.lang.String)">shape</a></span>&#8203;(java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">INTERNAL API</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#single(T)">single</a></span>&#8203;(T&nbsp;element)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> with one element.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tick(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,T)">tick</a></span>&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
    scala.concurrent.duration.FiniteDuration&nbsp;interval,
    T&nbsp;tick)</code></th>
<td class="colLast">
<div class="block">Elements are emitted periodically with the specified interval.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>&lt;S,&#8203;E&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfold(S,scala.Function1)">unfold</a></span>&#8203;(S&nbsp;s,
      scala.Function1&lt;S,&#8203;scala.Option&lt;scala.Tuple2&lt;S,&#8203;E&gt;&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Create a <code>Source</code> that will unfold a value of type <code>S</code> into
 a pair of the next state <code>S</code> and output elements of type <code>E</code>.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>&lt;S,&#8203;E&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfoldAsync(S,scala.Function1)">unfoldAsync</a></span>&#8203;(S&nbsp;s,
           scala.Function1&lt;S,&#8203;scala.concurrent.Future&lt;scala.Option&lt;scala.Tuple2&lt;S,&#8203;E&gt;&gt;&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">Same as <a href="#unfold(S,scala.Function1)"><code>&lt;S,E&gt;unfold(S,scala.Function1&lt;S,scala.Option&lt;scala.Tuple2&lt;S,E&gt;&gt;&gt;)</code></a>, but uses an async function to generate the next state-element tuple.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;S&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfoldResource(scala.Function0,scala.Function1,scala.Function1)">unfoldResource</a></span>&#8203;(scala.Function0&lt;S&gt;&nbsp;create,
              scala.Function1&lt;S,&#8203;scala.Option&lt;T&gt;&gt;&nbsp;read,
              scala.Function1&lt;S,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;close)</code></th>
<td class="colLast">
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;S&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unfoldResourceAsync(scala.Function0,scala.Function1,scala.Function1)">unfoldResourceAsync</a></span>&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;S&gt;&gt;&nbsp;create,
                   scala.Function1&lt;S,&#8203;scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;&nbsp;read,
                   scala.Function1&lt;S,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;close)</code></th>
<td class="colLast">
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;scala.collection.immutable.Seq&lt;T&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipN(scala.collection.immutable.Seq)">zipN</a></span>&#8203;(scala.collection.immutable.Seq&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</code></th>
<td class="colLast">
<div class="block">Combine the elements of multiple streams into a stream of sequences.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;O&gt;<br><a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWithN(scala.Function1,scala.collection.immutable.Seq)">zipWithN</a></span>&#8203;(scala.Function1&lt;scala.collection.immutable.Seq&lt;T&gt;,&#8203;O&gt;&nbsp;zipper,
        scala.collection.immutable.Seq&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="MODULE$">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>MODULE$</h4>
<pre>public static final&nbsp;<a href="Source$.html" title="class in org.apache.pekko.stream.scaladsl">Source$</a> MODULE$</pre>
<div class="block">Static reference to the singleton instance of this Scala object.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Source$</h4>
<pre>public&nbsp;Source$()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="shape(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shape</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;&nbsp;shape&#8203;(java.lang.String&nbsp;name)</pre>
<div class="block">INTERNAL API</div>
</li>
</ul>
<a id="fromPublisher(org.reactivestreams.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromPublisher</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromPublisher&#8203;(org.reactivestreams.Publisher&lt;T&gt;&nbsp;publisher)</pre>
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> from <code>Publisher</code>.
 <p>
 Construct a transformation starting with given publisher. The transformation steps
 are executed by a series of <code>Processor</code> instances
 that mediate the flow of elements downstream and the propagation of
 back-pressure upstream.</div>
</li>
</ul>
<a id="fromIterator(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromIterator</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromIterator&#8203;(scala.Function0&lt;scala.collection.Iterator&lt;T&gt;&gt;&nbsp;f)</pre>
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> from <code>Iterator</code>.
 Example usage: <code>Source.fromIterator(() =&gt; Iterator.from(0))</code>
 <p>
 Start a new <code>Source</code> from the given function that produces anIterator.
 The produced stream of elements will continue until the iterator runs empty
 or fails during evaluation of the <code>next()</code> method.
 Elements are pulled out of the iterator in accordance with the demand coming
 from the downstream transformation steps.</div>
</li>
</ul>
<a id="fromJavaStream(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromJavaStream</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;S extends java.util.stream.BaseStream&lt;T,&#8203;S&gt;&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromJavaStream&#8203;(scala.Function0&lt;java.util.stream.BaseStream&lt;T,&#8203;S&gt;&gt;&nbsp;stream)</pre>
<div class="block">Creates a source that wraps a Java 8 <code></code>Stream<code></code>. <code></code>Source<code></code> uses a stream iterator to get all its
 elements and send them downstream on demand.
 <p>
 You can use <code>Source.async</code> to create asynchronous boundaries between synchronous Java <code></code>Stream<code></code>
 and the rest of flow.</div>
</li>
</ul>
<a id="cycle(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cycle</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;cycle&#8203;(scala.Function0&lt;scala.collection.Iterator&lt;T&gt;&gt;&nbsp;f)</pre>
<div class="block">Creates <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> that will continually produce given elements in specified order.
 <p>
 Starts a new 'cycled' <code>Source</code> from the given elements. The producer stream of elements
 will continue infinitely by repeating the sequence of elements provided by function parameter.</div>
</li>
</ul>
<a id="fromGraph(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromGraph</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&nbsp;fromGraph&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;g)</pre>
<div class="block">A graph with the shape of a source logically is a source, this method makes
 it so also in type.</div>
</li>
</ul>
<a id="fromMaterializer(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromMaterializer</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;fromMaterializer&#8203;(scala.Function2&lt;<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</pre>
<div class="block">Defers the creation of a <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> until materialization. The <code>factory</code> function
 exposes <code>Materializer</code> which is going to be used during materialization and
 <code>Attributes</code> of the <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> returned by this method.</div>
</li>
</ul>
<a id="setup(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setup</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;setup&#8203;(scala.Function2&lt;<a href="../ActorMaterializer.html" title="class in org.apache.pekko.stream">ActorMaterializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'fromMaterializer' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Defers the creation of a <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> until materialization. The <code>factory</code> function
 exposes <code>ActorMaterializer</code> which is going to be used during materialization and
 <code>Attributes</code> of the <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> returned by this method.</div>
</li>
</ul>
<a id="apply(scala.collection.immutable.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;apply&#8203;(scala.collection.immutable.Iterable&lt;T&gt;&nbsp;iterable)</pre>
<div class="block">Helper to create <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> from <code>Iterable</code>.
 Example usage: <code>Source(Seq(1,2,3))</code>
 <p>
 Starts a new <code>Source</code> from the given <code>Iterable</code>. This is like starting from an
 Iterator, but every Subscriber directly attached to the Publisher of this
 stream will see an individual flow of elements (always starting from the
 beginning) regardless of when they subscribed.</div>
</li>
</ul>
<a id="fromFuture(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromFuture</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromFuture&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;future)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.future' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Starts a new <code>Source</code> from the given <code>Future</code>. The stream will consist of
 one element when the <code>Future</code> is completed with a successful value, which
 may happen before or after materializing the <code>Flow</code>.
 The stream terminates with a failure if the <code>Future</code> is completed with a failure.</div>
</li>
</ul>
<a id="fromCompletionStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromCompletionStage</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromCompletionStage&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;future)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.completionStage' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Starts a new <code>Source</code> from the given <code>Future</code>. The stream will consist of
 one element when the <code>Future</code> is completed with a successful value, which
 may happen before or after materializing the <code>Flow</code>.
 The stream terminates with a failure if the <code>Future</code> is completed with a failure.</div>
</li>
</ul>
<a id="fromFutureSource(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromFutureSource</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;fromFutureSource&#8203;(scala.concurrent.Future&lt;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;future)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.futureSource' (potentially together with `Source.fromGraph`) instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Streams the elements of the given future source once it successfully completes.
 If the <code>Future</code> fails the stream is failed with the exception from the future. If downstream cancels before the
 stream completes the materialized <code>Future</code> will be failed with a <code>StreamDetachedException</code></div>
</li>
</ul>
<a id="fromSourceCompletionStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromSourceCompletionStage</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;java.util.concurrent.CompletionStage&lt;M&gt;&gt;&nbsp;fromSourceCompletionStage&#8203;(java.util.concurrent.CompletionStage&lt;? extends <a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SourceShape.html" title="class in org.apache.pekko.stream">SourceShape</a>&lt;T&gt;,&#8203;M&gt;&gt;&nbsp;completion)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use scala-compat CompletionStage to future converter and 'Source.futureSource' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Streams the elements of an asynchronous source once its given <code>completion</code> operator completes.
 If the <code>CompletionStage</code> fails the stream is failed with the exception from the future.
 If downstream cancels before the stream completes the materialized <code>Future</code> will be failed
 with a <code>StreamDetachedException</code></div>
</li>
</ul>
<a id="tick(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,java.lang.Object)">
<!--   -->
</a><a id="tick(scala.concurrent.duration.FiniteDuration,scala.concurrent.duration.FiniteDuration,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tick</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/Cancellable.html" title="interface in org.apache.pekko.actor">Cancellable</a>&gt;&nbsp;tick&#8203;(scala.concurrent.duration.FiniteDuration&nbsp;initialDelay,
                                            scala.concurrent.duration.FiniteDuration&nbsp;interval,
                                            T&nbsp;tick)</pre>
<div class="block">Elements are emitted periodically with the specified interval.
 The tick element will be delivered to downstream consumers that has requested any elements.
 If a consumer has not requested any elements at the point in time when the tick
 element is produced it will not receive that tick element later. It will
 receive new tick elements as soon as it has requested more elements.</div>
</li>
</ul>
<a id="single(java.lang.Object)">
<!--   -->
</a><a id="single(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>single</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;single&#8203;(T&nbsp;element)</pre>
<div class="block">Create a <code>Source</code> with one element.
 Every connected <code>Sink</code> of this stream will see an individual stream consisting of one element.</div>
</li>
</ul>
<a id="repeat(java.lang.Object)">
<!--   -->
</a><a id="repeat(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;repeat&#8203;(T&nbsp;element)</pre>
<div class="block">Create a <code>Source</code> that will continually emit the given element.</div>
</li>
</ul>
<a id="unfold(java.lang.Object,scala.Function1)">
<!--   -->
</a><a id="unfold(S,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfold</h4>
<pre class="methodSignature">public&nbsp;&lt;S,&#8203;E&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfold&#8203;(S&nbsp;s,
                                                  scala.Function1&lt;S,&#8203;scala.Option&lt;scala.Tuple2&lt;S,&#8203;E&gt;&gt;&gt;&nbsp;f)</pre>
<div class="block">Create a <code>Source</code> that will unfold a value of type <code>S</code> into
 a pair of the next state <code>S</code> and output elements of type <code>E</code>.
 <p>
 For example, all the Fibonacci numbers under 10M:
 <p>
 <pre><code>
   Source.unfold(0 -&gt; 1) {
    case (a, _) if a &gt; 10000000 =&gt; None
    case (a, b) =&gt; Some((b -&gt; (a + b)) -&gt; a)
   }
 </code></pre></div>
</li>
</ul>
<a id="unfoldAsync(java.lang.Object,scala.Function1)">
<!--   -->
</a><a id="unfoldAsync(S,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfoldAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;S,&#8203;E&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;E,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfoldAsync&#8203;(S&nbsp;s,
                                                       scala.Function1&lt;S,&#8203;scala.concurrent.Future&lt;scala.Option&lt;scala.Tuple2&lt;S,&#8203;E&gt;&gt;&gt;&gt;&nbsp;f)</pre>
<div class="block">Same as <a href="#unfold(S,scala.Function1)"><code>&lt;S,E&gt;unfold(S,scala.Function1&lt;S,scala.Option&lt;scala.Tuple2&lt;S,E&gt;&gt;&gt;)</code></a>, but uses an async function to generate the next state-element tuple.
 <p>
 async fibonacci example:
 <p>
 <pre><code>
   Source.unfoldAsync(0 -&gt; 1) {
    case (a, _) if a &gt; 10000000 =&gt; Future.successful(None)
    case (a, b) =&gt; Future{
      Thread.sleep(1000)
      Some((b -&gt; (a + b)) -&gt; a)
    }
   }
 </code></pre></div>
</li>
</ul>
<a id="empty()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>empty</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;empty()</pre>
<div class="block">A <code>Source</code> with no elements, i.e. an empty stream that is completed immediately for every connected <code>Sink</code>.</div>
</li>
</ul>
<a id="maybe()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maybe</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Promise&lt;scala.Option&lt;T&gt;&gt;&gt;&nbsp;maybe()</pre>
<div class="block">Create a <code>Source</code> which materializes a <code>Promise</code> which controls what element
 will be emitted by the Source.
 If the materialized promise is completed with a Some, that value will be produced downstream,
 followed by completion.
 If the materialized promise is completed with a None, no value will be produced downstream and completion will
 be signalled immediately.
 If the materialized promise is completed with a failure, then the source will fail with that error.
 If the downstream of this source cancels or fails before the promise has been completed, then the promise will be completed
 with None.</div>
</li>
</ul>
<a id="failed(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>failed</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;failed&#8203;(java.lang.Throwable&nbsp;cause)</pre>
<div class="block">Create a <code>Source</code> that immediately ends the stream with the <code>cause</code> error to every connected <code>Sink</code>.</div>
</li>
</ul>
<a id="lazily(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazily</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;lazily&#8203;(scala.Function0&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazySource' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> that is not materialized until there is downstream demand, when the source gets materialized
 the materialized future is completed with its value, if downstream cancels or fails without any demand the
 create factory is never called and the materialized <code>Future</code> is failed.</div>
</li>
</ul>
<a id="lazilyAsync(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazilyAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;lazilyAsync&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;create)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Source.lazyFuture' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> from supplied future factory that is not called until downstream demand. When source gets
 materialized the materialized future is completed with the value from the factory. If downstream cancels or fails
 without any demand the create factory is never called and the materialized <code>Future</code> is failed.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Source.lazily</code></dd>
</dl>
</li>
</ul>
<a id="future(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>future</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;future&#8203;(scala.concurrent.Future&lt;T&gt;&nbsp;futureElement)</pre>
<div class="block">Emits a single value when the given <code>Future</code> is successfully completed and then completes the stream.
 The stream fails if the <code>Future</code> is completed with a failure.</div>
</li>
</ul>
<a id="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;never()</pre>
<div class="block">Never emits any elements, never completes and never fails.
 This stream could be useful in tests.</div>
</li>
</ul>
<a id="completionStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completionStage</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;completionStage&#8203;(java.util.concurrent.CompletionStage&lt;T&gt;&nbsp;completionStage)</pre>
<div class="block">Emits a single value when the given <code>CompletionStage</code> is successfully completed and then completes the stream.
 If the <code>CompletionStage</code> is completed with a failure the stream is failed.
 <p>
 Here for Java interoperability, the normal use from Scala should be <code>Source.future</code></div>
</li>
</ul>
<a id="futureSource(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>futureSource</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;futureSource&#8203;(scala.concurrent.Future&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;futureSource)</pre>
<div class="block">Turn a <code>Future[Source]</code> into a source that will emit the values of the source when the future completes successfully.
 If the <code>Future</code> is completed with a failure the stream is failed.</div>
</li>
</ul>
<a id="lazySingle(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazySingle</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;lazySingle&#8203;(scala.Function0&lt;T&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a single element until there is downstream demand.
 <p>
 If the <code>create</code> function fails when invoked the stream is failed.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and will trigger the factory immediately.</div>
</li>
</ul>
<a id="lazyFuture(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazyFuture</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;lazyFuture&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a future element until there is downstream demand.
 <p>
 The returned future element will be emitted downstream when it completes, or fail the stream if the future
 is failed or the <code>create</code> function itself fails.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and will trigger the factory immediately.</div>
</li>
</ul>
<a id="lazySource(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazySource</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;lazySource&#8203;(scala.Function0&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.
 <p>
 The returned source will emit downstream and behave just like it was the outer source. Downstream completes
 when the created source completes and fails when the created source fails.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and will trigger the factory immediately.
 <p>
 The materialized future value is completed with the materialized value of the created source when
 it has been materialized. If the function throws or the source materialization fails the future materialized value
 is failed with the thrown exception.
 <p>
 If downstream cancels or fails before the function is invoked the materialized value
 is failed with a <code>pekko.stream.NeverMaterializedException</code></div>
</li>
</ul>
<a id="lazyFutureSource(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazyFutureSource</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;lazyFutureSource&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a future source until there is downstream demand.
 <p>
 The returned future source will emit downstream and behave just like it was the outer source when the future completes
 successfully. Downstream completes when the created source completes and fails when the created source fails.
 If the future or the <code>create</code> function fails the stream is failed.
 <p>
 Note that asynchronous boundaries (and other operators) in the stream may do pre-fetching which counter acts
 the laziness and triggers the factory immediately.
 <p>
 The materialized future value is completed with the materialized value of the created source when
 it has been materialized. If the function throws or the source materialization fails the future materialized value
 is failed with the thrown exception.
 <p>
 If downstream cancels or fails before the function is invoked the materialized value
 is failed with a <code>pekko.stream.NeverMaterializedException</code></div>
</li>
</ul>
<a id="asSubscriber()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asSubscriber</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;org.reactivestreams.Subscriber&lt;T&gt;&gt;&nbsp;asSubscriber()</pre>
<div class="block">Creates a <code>Source</code> that is materialized as a <code>Subscriber</code></div>
</li>
</ul>
<a id="actorRef(scala.PartialFunction,scala.PartialFunction,int,org.apache.pekko.stream.OverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRef</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRef&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&nbsp;completionMatcher,
                                             scala.PartialFunction&lt;java.lang.Object,&#8203;java.lang.Throwable&gt;&nbsp;failureMatcher,
                                             int&nbsp;bufferSize,
                                             <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> is not supported, and an
 IllegalArgument("Backpressure overflowStrategy not supported") will be thrown if it is passed as argument.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received messages are dropped if there is no demand
 from downstream. When <code>bufferSize</code> is 0 the <code>overflowStrategy</code> does not matter.
 <p>
 The stream can be completed successfully by sending the actor reference a message that is matched by
 <code>completionMatcher</code> in which case already buffered elements will be signaled before signaling
 completion.
 <p>
 The stream can be completed with failure by sending a message that is matched by <code>failureMatcher</code>. The extracted
 <code>Throwable</code> will be used to fail the stream. In case the Actor is still draining its internal buffer (after having received
 a message matched by <code>completionMatcher</code>) before signaling completion and it receives a message matched by <code>failureMatcher</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 Note that terminating the actor without first completing it, either with a success or a
 failure, will prevent the actor triggering downstream completion and the stream will continue
 to run even though the source actor is dead. Therefore you should **not** attempt to
 manually terminate the actor such as with a <code>pekko.actor.PoisonPill</code>.
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.
 <p>
 See also <code>pekko.stream.scaladsl.Source.queue</code>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completionMatcher</code> - catches the completion message to end the stream</dd>
<dd><code>failureMatcher</code> - catches the failure message to fail the stream</dd>
<dd><code>bufferSize</code> - The size of the buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="actorRef(int,org.apache.pekko.stream.OverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRef</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRef&#8203;(int&nbsp;bufferSize,
                                             <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use variant accepting completion and failure matchers instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> is not supported, and an
 IllegalArgument("Backpressure overflowStrategy not supported") will be thrown if it is passed as argument.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received messages are dropped if there is no demand
 from downstream. When <code>bufferSize</code> is 0 the <code>overflowStrategy</code> does not matter.
 <p>
 The stream can be completed successfully by sending the actor reference a <code>pekko.actor.Status.Success</code>.
 If the content is <code>pekko.stream.CompletionStrategy.immediately</code> the completion will be signaled immediately.
 Otherwise, if the content is <code>pekko.stream.CompletionStrategy.draining</code> (or anything else)
 already buffered elements will be sent out before signaling completion.
 Using <code>pekko.actor.PoisonPill</code> or <code>pekko.actor.ActorSystem.stop</code> to stop the actor and complete the stream is *not supported*.
 <p>
 The stream can be completed with failure by sending a <code>pekko.actor.Status.Failure</code> to the
 actor reference. In case the Actor is still draining its internal buffer (after having received
 a <code>pekko.actor.Status.Success</code>) before signaling completion and it receives a <code>pekko.actor.Status.Failure</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 The actor will be stopped when the stream is canceled from downstream,
 i.e. you can watch it to get notified when that happens.
 <p>
 See also <code>pekko.stream.scaladsl.Source.queue</code>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - The size of the buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="actorRefWithBackpressure(java.lang.Object,scala.PartialFunction,scala.PartialFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithBackpressure</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRefWithBackpressure&#8203;(java.lang.Object&nbsp;ackMessage,
                                                             scala.PartialFunction&lt;java.lang.Object,&#8203;<a href="../CompletionStrategy.html" title="interface in org.apache.pekko.stream">CompletionStrategy</a>&gt;&nbsp;completionMatcher,
                                                             scala.PartialFunction&lt;java.lang.Object,&#8203;java.lang.Throwable&gt;&nbsp;failureMatcher)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 and a new message will only be accepted after the previous messages has been consumed and acknowledged back.
 The stream will complete with failure if a message is sent before the acknowledgement has been replied back.
 <p>
 The stream can be completed with failure by sending a message that is matched by <code>failureMatcher</code>. The extracted
 <code>Throwable</code> will be used to fail the stream. In case the Actor is still draining its internal buffer (after having received
 a message matched by <code>completionMatcher</code>) before signaling completion and it receives a message matched by <code>failureMatcher</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.</div>
</li>
</ul>
<a id="actorRefWithAck(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithAck</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;actorRefWithAck&#8203;(java.lang.Object&nbsp;ackMessage)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure accepting completion and failure matchers instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.actor.ActorRef</code>.
 Messages sent to this actor will be emitted to the stream if there is demand from downstream,
 and a new message will only be accepted after the previous messages has been consumed and acknowledged back.
 The stream will complete with failure if a message is sent before the acknowledgement has been replied back.
 <p>
 The stream can be completed successfully by sending the actor reference a <code>pekko.actor.Status.Success</code>.
 If the content is <code>pekko.stream.CompletionStrategy.immediately</code> the completion will be signaled immediately,
 otherwise if the content is <code>pekko.stream.CompletionStrategy.draining</code> (or anything else)
 already buffered element will be signaled before signaling completion.
 <p>
 The stream can be completed with failure by sending a <code>pekko.actor.Status.Failure</code> to the
 actor reference. In case the Actor is still draining its internal buffer (after having received
 a <code>pekko.actor.Status.Success</code>) before signaling completion and it receives a <code>pekko.actor.Status.Failure</code>,
 the failure will be signaled downstream immediately (instead of the completion signal).
 <p>
 The actor will be stopped when the stream is completed, failed or canceled from downstream,
 i.e. you can watch it to get notified when that happens.</div>
</li>
</ul>
<a id="combine(org.apache.pekko.stream.scaladsl.Source,org.apache.pekko.stream.scaladsl.Source,scala.collection.immutable.Seq,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combine</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;U&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;U,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;combine&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;first,
                                                   <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&nbsp;second,
                                                   scala.collection.immutable.Seq&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;rest,
                                                   scala.Function1&lt;java.lang.Object,&#8203;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy)</pre>
<div class="block">Combines several sources with fan-in strategy like <a href="Merge.html" title="class in org.apache.pekko.stream.scaladsl"><code>Merge</code></a> or <a href="Concat.html" title="class in org.apache.pekko.stream.scaladsl"><code>Concat</code></a> into a single <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>.</div>
</li>
</ul>
<a id="combineMat(org.apache.pekko.stream.scaladsl.Source,org.apache.pekko.stream.scaladsl.Source,scala.Function1,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineMat</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;U,&#8203;M1,&#8203;M2,&#8203;M&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;U,&#8203;M&gt;&nbsp;combineMat&#8203;(<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M1&gt;&nbsp;first,
                                                                          <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;M2&gt;&nbsp;second,
                                                                          scala.Function1&lt;java.lang.Object,&#8203;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanInShape.html" title="class in org.apache.pekko.stream">UniformFanInShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy,
                                                                          scala.Function2&lt;M1,&#8203;M2,&#8203;M&gt;&nbsp;matF)</pre>
<div class="block">Combines several sources with fan-in strategy like <a href="Merge.html" title="class in org.apache.pekko.stream.scaladsl"><code>Merge</code></a> or <a href="Concat.html" title="class in org.apache.pekko.stream.scaladsl"><code>Concat</code></a> into a single <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a> with a materialized value.</div>
</li>
</ul>
<a id="zipN(scala.collection.immutable.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipN</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;scala.collection.immutable.Seq&lt;T&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;zipN&#8203;(scala.collection.immutable.Seq&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</pre>
<div class="block">Combine the elements of multiple streams into a stream of sequences.</div>
</li>
</ul>
<a id="zipWithN(scala.Function1,scala.collection.immutable.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithN</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;O&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;O,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;zipWithN&#8203;(scala.Function1&lt;scala.collection.immutable.Seq&lt;T&gt;,&#8203;O&gt;&nbsp;zipper,
                                                    scala.collection.immutable.Seq&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;&gt;&nbsp;sources)</pre>
</li>
</ul>
<a id="queue(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../BoundedSourceQueue.html" title="interface in org.apache.pekko.stream">BoundedSourceQueue</a>&lt;T&gt;&gt;&nbsp;queue&#8203;(int&nbsp;bufferSize)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.BoundedSourceQueue</code>.
 You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received. The buffer size is passed in as a parameter.
 Elements in the buffer will be discarded if downstream is terminated.
 <p>
 Pushed elements may be dropped if there is no space available in the buffer. Elements will also be dropped if the
 queue is failed through the materialized <code>BoundedQueueSource</code> or the <code>Source</code> is cancelled by the downstream.
 An element that was reported to be <code>enqueued</code> is not guaranteed to be processed by the rest of the stream. If the
 queue is failed by calling <code>BoundedQueueSource.fail</code> or the downstream cancels the stream, elements in the buffer
 are discarded.
 <p>
 Acknowledgement of pushed elements is immediate.
 <code>pekko.stream.BoundedSourceQueue.offer</code> returns <code>pekko.stream.QueueOfferResult</code> which is implemented as:
 <p>
 <code>QueueOfferResult.Enqueued</code>       element was added to buffer, but may still be discarded later when the queue is
                                   failed or cancelled
 <code>QueueOfferResult.Dropped</code>        element was dropped
 <code>QueueOfferResult.QueueComplete</code>  the queue was completed with <code>pekko.stream.BoundedSourceQueue.complete</code>
 <code>QueueOfferResult.Failure</code>        the queue was failed with <code>pekko.stream.BoundedSourceQueue.fail</code> or if
                                   the stream failed
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - size of the buffer in number of elements</dd>
</dl>
</li>
</ul>
<a id="queue(int,org.apache.pekko.stream.OverflowStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.scaladsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;&nbsp;queue&#8203;(int&nbsp;bufferSize,
                                                            <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.scaladsl.SourceQueueWithComplete</code>.
 You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received. Elements in the buffer will be discarded
 if downstream is terminated.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 Acknowledgement mechanism is available.
 <code>pekko.stream.scaladsl.SourceQueueWithComplete.offer</code> returns <code>Future[QueueOfferResult]</code> which completes with
 <code>QueueOfferResult.Enqueued</code> if element was added to buffer or sent downstream. It completes with
 <code>QueueOfferResult.Dropped</code> if element was dropped. Can also complete  with <code>QueueOfferResult.Failure</code> -
 when stream failed or <code>QueueOfferResult.QueueClosed</code> when downstream is completed.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> will not complete last <code>offer():Future</code>
 call when buffer is full.
 <p>
 Instead of using the strategy <code>pekko.stream.OverflowStrategy.dropNew</code> it's recommended to use
 <code>Source.queue(bufferSize)</code> instead which returns a <code>QueueOfferResult</code> synchronously.
 <p>
 You can watch accessibility of stream with <code>pekko.stream.scaladsl.SourceQueueWithComplete.watchCompletion</code>.
 It returns future that completes with success when the operator is completed or fails when the stream is failed.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received message will wait
 for downstream demand unless there is another message waiting for downstream demand, in that case
 offer result will be completed according to the overflow strategy.
 <p>
 The materialized SourceQueue may only be used from a single producer.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - size of buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
</dl>
</li>
</ul>
<a id="queue(int,org.apache.pekko.stream.OverflowStrategy,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="SourceQueueWithComplete.html" title="interface in org.apache.pekko.stream.scaladsl">SourceQueueWithComplete</a>&lt;T&gt;&gt;&nbsp;queue&#8203;(int&nbsp;bufferSize,
                                                            <a href="../OverflowStrategy.html" title="class in org.apache.pekko.stream">OverflowStrategy</a>&nbsp;overflowStrategy,
                                                            int&nbsp;maxConcurrentOffers)</pre>
<div class="block">Creates a <code>Source</code> that is materialized as an <code>pekko.stream.scaladsl.SourceQueueWithComplete</code>.
 You can push elements to the queue and they will be emitted to the stream if there is demand from downstream,
 otherwise they will be buffered until request for demand is received. Elements in the buffer will be discarded
 if downstream is terminated.
 <p>
 Depending on the defined <code>pekko.stream.OverflowStrategy</code> it might drop elements if
 there is no space available in the buffer.
 <p>
 Acknowledgement mechanism is available.
 <code>pekko.stream.scaladsl.SourceQueueWithComplete.offer</code> returns <code>Future[QueueOfferResult]</code> which completes with
 <code>QueueOfferResult.Enqueued</code> if element was added to buffer or sent downstream. It completes with
 <code>QueueOfferResult.Dropped</code> if element was dropped. Can also complete  with <code>QueueOfferResult.Failure</code> -
 when stream failed or <code>QueueOfferResult.QueueClosed</code> when downstream is completed.
 <p>
 The strategy <code>pekko.stream.OverflowStrategy.backpressure</code> will not complete <code>maxConcurrentOffers</code> number of
 <code>offer():Future</code> call when buffer is full.
 <p>
 Instead of using the strategy <code>pekko.stream.OverflowStrategy.dropNew</code> it's recommended to use
 <code>Source.queue(bufferSize)</code> instead which returns a <code>QueueOfferResult</code> synchronously.
 <p>
 You can watch accessibility of stream with <code>pekko.stream.scaladsl.SourceQueueWithComplete.watchCompletion</code>.
 It returns future that completes with success when the operator is completed or fails when the stream is failed.
 <p>
 The buffer can be disabled by using <code>bufferSize</code> of 0 and then received message will wait
 for downstream demand unless there is another message waiting for downstream demand, in that case
 offer result will be completed according to the overflow strategy.
 <p>
 The materialized SourceQueue may be used by up to maxConcurrentOffers concurrent producers.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bufferSize</code> - size of buffer in element count</dd>
<dd><code>overflowStrategy</code> - Strategy that is used when incoming elements cannot fit inside the buffer</dd>
<dd><code>maxConcurrentOffers</code> - maximum number of pending offers when buffer is full, should be greater than 0, not
                            applicable when <code>OverflowStrategy.dropNew</code> is used</dd>
</dl>
</li>
</ul>
<a id="unfoldResource(scala.Function0,scala.Function1,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfoldResource</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfoldResource&#8203;(scala.Function0&lt;S&gt;&nbsp;create,
                                                          scala.Function1&lt;S,&#8203;scala.Option&lt;T&gt;&gt;&nbsp;read,
                                                          scala.Function1&lt;S,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;close)</pre>
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.
 Interaction with resource happens in a blocking way.
 <p>
 Example:
 <pre><code>
 Source.unfoldResource(
   () =&gt; new BufferedReader(new FileReader("...")),
   reader =&gt; Option(reader.readLine()),
   reader =&gt; reader.close())
 </code></pre>
 <p>
 You can use the supervision strategy to handle exceptions for <code>read</code> function. All exceptions thrown by <code>create</code>
 or <code>close</code> will fail the stream.
 <p>
 <code>Restart</code> supervision strategy will close and create blocking IO again. Default strategy is <code>Stop</code> which means
 that stream will be terminated on error in <code>read</code> function by default.
 <p>
 You can configure the default dispatcher for this Source by changing the <code>pekko.stream.materializer.blocking-io-dispatcher</code> or
 set it for a given Source by using <code>ActorAttributes</code>.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>create</code> - - function that is called on stream start and creates/opens resource.</dd>
<dd><code>read</code> - - function that reads data from opened resource. It is called each time backpressure signal
             is received. Stream calls close and completes when <code>read</code> returns None.</dd>
<dd><code>close</code> - - function that closes resource</dd>
</dl>
</li>
</ul>
<a id="unfoldResourceAsync(scala.Function0,scala.Function1,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unfoldResourceAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;S&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;unfoldResourceAsync&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;S&gt;&gt;&nbsp;create,
                                                               scala.Function1&lt;S,&#8203;scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;&nbsp;read,
                                                               scala.Function1&lt;S,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;close)</pre>
<div class="block">Start a new <code>Source</code> from some resource which can be opened, read and closed.
 It's similar to <code>unfoldResource</code> but takes functions that return <code>Futures</code> instead of plain values.
 <p>
 You can use the supervision strategy to handle exceptions for <code>read</code> function or failures of produced <code>Futures</code>.
 All exceptions thrown by <code>create</code> or <code>close</code> as well as fails of returned futures will fail the stream.
 <p>
 <code>Restart</code> supervision strategy will close and create resource. Default strategy is <code>Stop</code> which means
 that stream will be terminated on error in <code>read</code> function (or future) by default.
 <p>
 You can configure the default dispatcher for this Source by changing the <code>pekko.stream.materializer.blocking-io-dispatcher</code> or
 set it for a given Source by using <code>ActorAttributes</code>.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>create</code> - - function that is called on stream start and creates/opens resource.</dd>
<dd><code>read</code> - - function that reads data from opened resource. It is called each time backpressure signal
             is received. Stream calls close and completes when <code>Future</code> from read function returns None.</dd>
<dd><code>close</code> - - function that closes resource</dd>
</dl>
</li>
</ul>
<a id="mergePrioritizedN(scala.collection.immutable.Seq,boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>mergePrioritizedN</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;mergePrioritizedN&#8203;(scala.collection.immutable.Seq&lt;scala.Tuple2&lt;<a href="Source.html" title="class in org.apache.pekko.stream.scaladsl">Source</a>&lt;T,&#8203;?&gt;,&#8203;java.lang.Object&gt;&gt;&nbsp;sourcesAndPriorities,
                                                     boolean&nbsp;eagerComplete)</pre>
<div class="block">Merge multiple <a href="Source.html" title="class in org.apache.pekko.stream.scaladsl"><code>Source</code></a>s. Prefer the sources depending on the 'priority' parameters.
 The provided sources and priorities must have the same size and order.
 <p>
 '''emits''' when one of the inputs has an element available, preferring inputs based on the 'priority' parameters if both have elements available
 <p>
 '''backpressures''' when downstream backpressures
 <p>
 '''completes''' when both upstreams complete (This behavior is changeable to completing when any upstream completes by setting <code>eagerComplete=true</code>.)
 <p>
 '''Cancels when''' downstream cancels</div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
