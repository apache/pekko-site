<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.17) on Wed Mar 01 23:28:13 CET 2023 -->
<title>Sink$</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-03-01">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Sink$";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":42,"i1":10,"i2":42,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":42,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":42,"i26":42,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":42,"i35":10,"i36":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.stream.scaladsl</a></div>
<h2 title="Class Sink$" class="title">Class Sink$</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.apache.pekko.stream.scaladsl.Sink$</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">Sink$</span>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="Sink$.html" title="class in org.apache.pekko.stream.scaladsl">Sink$</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#MODULE$">MODULE$</a></span></code></th>
<td class="colLast">
<div class="block">Static reference to the singleton instance of this Scala object.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Sink$</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRef(org.apache.pekko.actor.ActorRef,java.lang.Object)">actorRef</a></span>&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
        java.lang.Object&nbsp;onCompleteMessage)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use variant accepting both on complete and on failure message.</div>
</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRef(org.apache.pekko.actor.ActorRef,java.lang.Object,scala.Function1)">actorRef</a></span>&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
        java.lang.Object&nbsp;onCompleteMessage,
        scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</code></th>
<td class="colLast">
<div class="block">INTERNAL API</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithAck(org.apache.pekko.actor.ActorRef,java.lang.Object,java.lang.Object,java.lang.Object,scala.Function1)">actorRefWithAck</a></span>&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
               java.lang.Object&nbsp;onInitMessage,
               java.lang.Object&nbsp;ackMessage,
               java.lang.Object&nbsp;onCompleteMessage,
               scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure accepting completion and failure matchers instead.</div>
</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithAck$default$5()">actorRefWithAck$default$5</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithBackpressure(org.apache.pekko.actor.ActorRef,java.lang.Object,java.lang.Object,java.lang.Object,scala.Function1)">actorRefWithBackpressure</a></span>&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                        java.lang.Object&nbsp;onInitMessage,
                        java.lang.Object&nbsp;ackMessage,
                        java.lang.Object&nbsp;onCompleteMessage,
                        scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</code></th>
<td class="colLast">
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actorRefWithBackpressure(org.apache.pekko.actor.ActorRef,java.lang.Object,java.lang.Object,scala.Function1)">actorRefWithBackpressure</a></span>&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                        java.lang.Object&nbsp;onInitMessage,
                        java.lang.Object&nbsp;onCompleteMessage,
                        scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</code></th>
<td class="colLast">
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;org.reactivestreams.Publisher&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asPublisher(boolean)">asPublisher</a></span>&#8203;(boolean&nbsp;fanout)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that materializes into a <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cancelled()">cancelled</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that immediately cancels its upstream after materialization.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;That&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;That&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collection(scala.collection.Factory)">collection</a></span>&#8203;(scala.collection.Factory&lt;T,&#8203;That&gt;&nbsp;cbf)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that keeps on collecting incoming elements until upstream terminates.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;U&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combine(org.apache.pekko.stream.scaladsl.Sink,org.apache.pekko.stream.scaladsl.Sink,scala.collection.immutable.Seq,scala.Function1)">combine</a></span>&#8203;(<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;U,&#8203;?&gt;&nbsp;first,
       <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;U,&#8203;?&gt;&nbsp;second,
       scala.collection.immutable.Seq&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;U,&#8203;?&gt;&gt;&nbsp;rest,
       scala.Function1&lt;java.lang.Object,&#8203;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanOutShape.html" title="class in org.apache.pekko.stream">UniformFanOutShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy)</code></th>
<td class="colLast">
<div class="block">Combine several sinks with fan-out strategy like <code>Broadcast</code> or <code>Balance</code> and returns <code>Sink</code>.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;U,&#8203;T&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;U&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fold(U,scala.Function2)">fold</a></span>&#8203;(U&nbsp;zero,
    scala.Function2&lt;U,&#8203;T,&#8203;U&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>&lt;U,&#8203;T&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;U&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#foldAsync(U,scala.Function2)">foldAsync</a></span>&#8203;(U&nbsp;zero,
         scala.Function2&lt;U,&#8203;T,&#8203;scala.concurrent.Future&lt;U&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that will invoke the given asynchronous function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#foreach(scala.Function1)">foreach</a></span>&#8203;(scala.Function1&lt;T,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that will invoke the given procedure for each received element.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#foreachAsync(int,scala.Function1)">foreachAsync</a></span>&#8203;(int&nbsp;parallelism,
            scala.Function1&lt;T,&#8203;scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that will invoke the given procedure asynchronously for each received element.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#foreachParallel(int,scala.Function1,scala.concurrent.ExecutionContext)">foreachParallel</a></span>&#8203;(int&nbsp;parallelism,
               scala.Function1&lt;T,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;f,
               scala.concurrent.ExecutionContext&nbsp;ec)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use `foreachAsync` instead, it allows you to choose how to run the procedure, by calling some other API returning a Future or spawning a new Future.</div>
</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromGraph(org.apache.pekko.stream.Graph)">fromGraph</a></span>&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;g)</code></th>
<td class="colLast">
<div class="block">A graph with the shape of a sink logically is a sink, this method makes
 it so also in type.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromMaterializer(scala.Function2)">fromMaterializer</a></span>&#8203;(scala.Function2&lt;<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</code></th>
<td class="colLast">
<div class="block">Defers the creation of a <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> until materialization.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromSubscriber(org.reactivestreams.Subscriber)">fromSubscriber</a></span>&#8203;(org.reactivestreams.Subscriber&lt;T&gt;&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">Helper to create <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> from <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#futureSink(scala.concurrent.Future)">futureSink</a></span>&#8203;(scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block">Turn a <code>Future[Sink]</code> into a Sink that will consume the values of the source when the future completes successfully.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#head()">head</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the first value received.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#headOption()">headOption</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional first value received.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;java.lang.Object,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ignore()">ignore</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that will consume the stream and discard the elements.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#last()">last</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the last value received.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lastOption()">lastOption</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional last value received.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazyFutureSink(scala.Function0)">lazyFutureSink</a></span>&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a future sink until there is a first element passed from upstream.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazyInit(scala.Function1,scala.Function0)">lazyInit</a></span>&#8203;(scala.Function1&lt;T,&#8203;scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;sinkFactory,
        scala.Function0&lt;M&gt;&nbsp;fallback)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Sink.lazyFutureSink' in combination with 'Flow.prefixAndTail(1)' instead.</div>
</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.Option&lt;M&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazyInitAsync(scala.Function0)">lazyInitAsync</a></span>&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;sinkFactory)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Sink.lazyFutureSink' instead.</div>
</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lazySink(scala.Function0)">lazySink</a></span>&#8203;(scala.Function0&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Defers invoking the <code>create</code> function to create a sink until there is a first element passed from upstream.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;java.lang.Object,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#never()">never</a></span>()</code></th>
<td class="colLast">
<div class="block">A <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> that will always backpressure never cancel and never consume any elements from the stream.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onComplete(scala.Function1)">onComplete</a></span>&#8203;(scala.Function1&lt;scala.util.Try&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;callback)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that when the flow is completed, either through a failure or normal
 completion, apply the provided function with <code>Success</code>
 or <code>Failure</code>.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="SinkQueueWithCancel.html" title="interface in org.apache.pekko.stream.scaladsl">SinkQueueWithCancel</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue()">queue</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a <code>Sink</code> that is materialized as an <code>pekko.stream.scaladsl.SinkQueueWithCancel</code>.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="SinkQueueWithCancel.html" title="interface in org.apache.pekko.stream.scaladsl">SinkQueueWithCancel</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#queue(int)">queue</a></span>&#8203;(int&nbsp;maxConcurrentPulls)</code></th>
<td class="colLast">
<div class="block">Creates a <code>Sink</code> that is materialized as an <code>pekko.stream.scaladsl.SinkQueueWithCancel</code>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduce(scala.Function2)">reduce</a></span>&#8203;(scala.Function2&lt;T,&#8203;T,&#8203;T&gt;&nbsp;f)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (from the second element) and the element as input.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#seq()">seq</a></span>()</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that keeps on collecting incoming elements until upstream terminates.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>&lt;T,&#8203;M&gt;<br><a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setup(scala.Function2)">setup</a></span>&#8203;(scala.Function2&lt;<a href="../ActorMaterializer.html" title="class in org.apache.pekko.stream">ActorMaterializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'fromMaterializer' instead.</div>
</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#shape(java.lang.String)">shape</a></span>&#8203;(java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">INTERNAL API</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#takeLast(int)">takeLast</a></span>&#8203;(int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">A <code>Sink</code> that materializes into a a <code>Future</code> of <code>immutable.Seq[T]</code> containing the last <code>n</code> collected elements.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="MODULE$">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>MODULE$</h4>
<pre>public static final&nbsp;<a href="Sink$.html" title="class in org.apache.pekko.stream.scaladsl">Sink$</a> MODULE$</pre>
<div class="block">Static reference to the singleton instance of this Scala object.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Sink$</h4>
<pre>public&nbsp;Sink$()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="shape(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shape</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;T&gt;&nbsp;shape&#8203;(java.lang.String&nbsp;name)</pre>
<div class="block">INTERNAL API</div>
</li>
</ul>
<a id="fromGraph(org.apache.pekko.stream.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromGraph</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&nbsp;fromGraph&#8203;(<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../SinkShape.html" title="class in org.apache.pekko.stream">SinkShape</a>&lt;T&gt;,&#8203;M&gt;&nbsp;g)</pre>
<div class="block">A graph with the shape of a sink logically is a sink, this method makes
 it so also in type.</div>
</li>
</ul>
<a id="fromMaterializer(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromMaterializer</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;fromMaterializer&#8203;(scala.Function2&lt;<a href="../Materializer.html" title="class in org.apache.pekko.stream">Materializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</pre>
<div class="block">Defers the creation of a <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> until materialization. The <code>factory</code> function
 exposes <code>Materializer</code> which is going to be used during materialization and
 <code>Attributes</code> of the <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> returned by this method.</div>
</li>
</ul>
<a id="setup(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setup</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;setup&#8203;(scala.Function2&lt;<a href="../ActorMaterializer.html" title="class in org.apache.pekko.stream">ActorMaterializer</a>,&#8203;<a href="../Attributes.html" title="class in org.apache.pekko.stream">Attributes</a>,&#8203;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;factory)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'fromMaterializer' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Defers the creation of a <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> until materialization. The <code>factory</code> function
 exposes <code>ActorMaterializer</code> which is going to be used during materialization and
 <code>Attributes</code> of the <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> returned by this method.</div>
</li>
</ul>
<a id="fromSubscriber(org.reactivestreams.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromSubscriber</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;fromSubscriber&#8203;(org.reactivestreams.Subscriber&lt;T&gt;&nbsp;subscriber)</pre>
<div class="block">Helper to create <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> from <code>Subscriber</code>.</div>
</li>
</ul>
<a id="cancelled()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cancelled</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;cancelled()</pre>
<div class="block">A <code>Sink</code> that immediately cancels its upstream after materialization.</div>
</li>
</ul>
<a id="head()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>head</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;head()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the first value received.
 If the stream completes before signaling at least a single element, the Future will be failed with a <code>NoSuchElementException</code>.
 If the stream signals an error errors before signaling at least a single element, the Future will be failed with the streams exception.
 <p>
 See also <a href="#headOption()"><code>&lt;T&gt;headOption()</code></a>.</div>
</li>
</ul>
<a id="headOption()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headOption</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;&nbsp;headOption()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional first value received.
 If the stream completes before signaling at least a single element, the value of the Future will be <code>None</code>.
 If the stream signals an error errors before signaling at least a single element, the Future will be failed with the streams exception.
 <p>
 See also <a href="#head()"><code>&lt;T&gt;head()</code></a>.</div>
</li>
</ul>
<a id="last()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>last</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;last()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the last value received.
 If the stream completes before signaling at least a single element, the Future will be failed with a <code>NoSuchElementException</code>.
 If the stream signals an error, the Future will be failed with the stream's exception.
 <p>
 See also <a href="#lastOption()"><code>&lt;T&gt;lastOption()</code></a>, <a href="#takeLast(int)"><code>&lt;T&gt;takeLast(int)</code></a>.</div>
</li>
</ul>
<a id="lastOption()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lastOption</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.Option&lt;T&gt;&gt;&gt;&nbsp;lastOption()</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Future</code> of the optional last value received.
 If the stream completes before signaling at least a single element, the value of the Future will be <code>None</code>.
 If the stream signals an error, the Future will be failed with the stream's exception.
 <p>
 See also <a href="#last()"><code>&lt;T&gt;last()</code></a>, <a href="#takeLast(int)"><code>&lt;T&gt;takeLast(int)</code></a>.</div>
</li>
</ul>
<a id="takeLast(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeLast</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;T&gt;&gt;&gt;&nbsp;takeLast&#8203;(int&nbsp;n)</pre>
<div class="block">A <code>Sink</code> that materializes into a a <code>Future</code> of <code>immutable.Seq[T]</code> containing the last <code>n</code> collected elements.
 <p>
 If the stream completes before signaling at least n elements, the <code>Future</code> will complete with all elements seen so far.
 If the stream never completes, the <code>Future</code> will never complete.
 If there is a failure signaled in the stream the <code>Future</code> will be completed with failure.</div>
</li>
</ul>
<a id="seq()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>seq</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;T&gt;&gt;&gt;&nbsp;seq()</pre>
<div class="block">A <code>Sink</code> that keeps on collecting incoming elements until upstream terminates.
 As upstream may be unbounded, <code>Flow[T].take</code> or the stricter <code>Flow[T].limit</code> (and their variants)
 may be used to ensure boundedness.
 Materializes into a <code>Future</code> of <code>Seq[T]</code> containing all the collected elements.
 <code>Seq</code> is limited to <code>Int.MaxValue</code> elements, this Sink will cancel the stream
 after having received that many elements.
 <p>
 See also <code>Flow.limit</code>, <code>Flow.limitWeighted</code>, <code>Flow.take</code>, <code>Flow.takeWithin</code>, <code>Flow.takeWhile</code></div>
</li>
</ul>
<a id="collection(scala.collection.Factory)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collection</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;That&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;That&gt;&gt;&nbsp;collection&#8203;(scala.collection.Factory&lt;T,&#8203;That&gt;&nbsp;cbf)</pre>
<div class="block">A <code>Sink</code> that keeps on collecting incoming elements until upstream terminates.
 As upstream may be unbounded, <code>Flow[T].take</code> or the stricter <code>Flow[T].limit</code> (and their variants)
 may be used to ensure boundedness.
 Materializes into a <code>Future</code> of <code>That[T]</code> containing all the collected elements.
 <code>That[T]</code> is limited to the limitations of the CanBuildFrom associated with it. For example, <code>Seq</code> is limited to
 <code>Int.MaxValue</code> elements. See [The Architecture of Scala 2.13's Collections](https://docs.scala-lang.org/overviews/core/architecture-of-scala-213-collections.html) for more info.
 This Sink will cancel the stream after having received that many elements.
 <p>
 See also <code>Flow.limit</code>, <code>Flow.limitWeighted</code>, <code>Flow.take</code>, <code>Flow.takeWithin</code>, <code>Flow.takeWhile</code></div>
</li>
</ul>
<a id="asPublisher(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asPublisher</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;asPublisher&#8203;(boolean&nbsp;fanout)</pre>
<div class="block">A <code>Sink</code> that materializes into a <code>Publisher</code>.
 <p>
 If <code>fanout</code> is <code>true</code>, the materialized <code>Publisher</code> will support multiple <code>Subscriber</code>s and
 the size of the <code>inputBuffer</code> configured for this operator becomes the maximum number of elements that
 the fastest <code>Subscriber</code> can be ahead of the slowest one before slowing
 the processing down due to back pressure.
 <p>
 If <code>fanout</code> is <code>false</code> then the materialized <code>Publisher</code> will only support a single <code>Subscriber</code> and
 reject any additional <code>Subscriber</code>s.</div>
</li>
</ul>
<a id="ignore()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignore</h4>
<pre class="methodSignature">public&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;java.lang.Object,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;ignore()</pre>
<div class="block">A <code>Sink</code> that will consume the stream and discard the elements.</div>
</li>
</ul>
<a id="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre class="methodSignature">public&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;java.lang.Object,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;never()</pre>
<div class="block">A <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl"><code>Sink</code></a> that will always backpressure never cancel and never consume any elements from the stream.</div>
</li>
</ul>
<a id="foreach(scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foreach</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;foreach&#8203;(scala.Function1&lt;T,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given procedure for each received element. The sink is materialized
 into a <code>Future</code> which will be completed with <code>Success</code> when reaching the
 normal end of the stream, or completed with <code>Failure</code> if there is a failure signaled in
 the stream.</div>
</li>
</ul>
<a id="foreachAsync(int,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foreachAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;foreachAsync&#8203;(int&nbsp;parallelism,
                                                                    scala.Function1&lt;T,&#8203;scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given procedure asynchronously for each received element. The sink is materialized
 into a <code>Future</code> which will be completed with <code>Success</code> when reaching the
 normal end of the stream, or completed with <code>Failure</code> if there is a failure signaled in
 the stream.</div>
</li>
</ul>
<a id="combine(org.apache.pekko.stream.scaladsl.Sink,org.apache.pekko.stream.scaladsl.Sink,scala.collection.immutable.Seq,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combine</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;U&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;combine&#8203;(<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;U,&#8203;?&gt;&nbsp;first,
                                                 <a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;U,&#8203;?&gt;&nbsp;second,
                                                 scala.collection.immutable.Seq&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;U,&#8203;?&gt;&gt;&nbsp;rest,
                                                 scala.Function1&lt;java.lang.Object,&#8203;<a href="../Graph.html" title="interface in org.apache.pekko.stream">Graph</a>&lt;<a href="../UniformFanOutShape.html" title="class in org.apache.pekko.stream">UniformFanOutShape</a>&lt;T,&#8203;U&gt;,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&gt;&nbsp;strategy)</pre>
<div class="block">Combine several sinks with fan-out strategy like <code>Broadcast</code> or <code>Balance</code> and returns <code>Sink</code>.</div>
</li>
</ul>
<a id="foreachParallel(int,scala.Function1,scala.concurrent.ExecutionContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foreachParallel</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;&gt;&nbsp;foreachParallel&#8203;(int&nbsp;parallelism,
                                                                       scala.Function1&lt;T,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;f,
                                                                       scala.concurrent.ExecutionContext&nbsp;ec)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use `foreachAsync` instead, it allows you to choose how to run the procedure, by calling some other API returning a Future or spawning a new Future. Since Akka 2.5.17.</div>
</div>
<div class="block">A <code>Sink</code> that will invoke the given function to each of the elements
 as they pass in. The sink is materialized into a <code>Future</code>
 <p>
 If <code>f</code> throws an exception and the supervision decision is
 <code>pekko.stream.Supervision.Stop</code> the <code>Future</code> will be completed with failure.
 <p>
 If <code>f</code> throws an exception and the supervision decision is
 <code>pekko.stream.Supervision.Resume</code> or <code>pekko.stream.Supervision.Restart</code> the
 element is dropped and the stream continues.
 <p>
 See also <code>Flow.mapAsyncUnordered</code></div>
</li>
</ul>
<a id="fold(java.lang.Object,scala.Function2)">
<!--   -->
</a><a id="fold(U,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fold</h4>
<pre class="methodSignature">public&nbsp;&lt;U,&#8203;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;U&gt;&gt;&nbsp;fold&#8203;(U&nbsp;zero,
                                                                 scala.Function2&lt;U,&#8203;T,&#8203;U&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>Future</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure signaled in the stream.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#foldAsync(U,scala.Function2)"><code>foldAsync(U, scala.Function2&lt;U, T, scala.concurrent.Future&lt;U&gt;&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="foldAsync(java.lang.Object,scala.Function2)">
<!--   -->
</a><a id="foldAsync(U,scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foldAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;U,&#8203;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;U&gt;&gt;&nbsp;foldAsync&#8203;(U&nbsp;zero,
                                                                      scala.Function2&lt;U,&#8203;T,&#8203;scala.concurrent.Future&lt;U&gt;&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given asynchronous function for every received element, giving it its previous
 output (or the given <code>zero</code> value) and the element as input.
 The returned <code>Future</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure signaled in the stream.
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#fold(U,scala.Function2)"><code>fold(U, scala.Function2&lt;U, T, U&gt;)</code></a></dd>
</dl>
</li>
</ul>
<a id="reduce(scala.Function2)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;T&gt;&gt;&nbsp;reduce&#8203;(scala.Function2&lt;T,&#8203;T,&#8203;T&gt;&nbsp;f)</pre>
<div class="block">A <code>Sink</code> that will invoke the given function for every received element, giving it its previous
 output (from the second element) and the element as input.
 The returned <code>Future</code> will be completed with value of the final
 function evaluation when the input stream ends, or completed with <code>Failure</code>
 if there is a failure signaled in the stream.
 <p>
 If the stream is empty (i.e. completes before signalling any elements),
 the reduce operator will fail its downstream with a <code>NoSuchElementException</code>,
 which is semantically in-line with that Scala's standard library collections
 do in such situations.
 <p>
 Adheres to the <code>ActorAttributes.SupervisionStrategy</code> attribute.</div>
</li>
</ul>
<a id="onComplete(scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onComplete</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;onComplete&#8203;(scala.Function1&lt;scala.util.Try&lt;<a href="../../Done.html" title="class in org.apache.pekko">Done</a>&gt;,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;callback)</pre>
<div class="block">A <code>Sink</code> that when the flow is completed, either through a failure or normal
 completion, apply the provided function with <code>Success</code>
 or <code>Failure</code>.</div>
</li>
</ul>
<a id="actorRef(org.apache.pekko.actor.ActorRef,java.lang.Object,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRef</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;actorRef&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                                          java.lang.Object&nbsp;onCompleteMessage,
                                          scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</pre>
<div class="block">INTERNAL API
 <p>
 Sends the elements of the stream to the given <code>ActorRef</code>.
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given <code>onCompleteMessage</code>
 will be sent to the destination actor.
 When the stream is completed with failure the <code>onFailureMessage</code> will be invoked
 and its result will be sent to the destination actor.
 <p>
 It will request at most <code>maxInputBufferSize</code> number of elements from
 upstream, but there is no back-pressure signal from the destination actor,
 i.e. if the actor is not consuming the messages fast enough the mailbox
 of the actor will grow. For potentially slow consumer actors it is recommended
 to use a bounded mailbox with zero <code>mailbox-push-timeout-time</code> or use a rate
 limiting operator in front of this <code>Sink</code>.</div>
</li>
</ul>
<a id="actorRef(org.apache.pekko.actor.ActorRef,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRef</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;actorRef&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                                          java.lang.Object&nbsp;onCompleteMessage)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use variant accepting both on complete and on failure message. Since Akka 2.6.0.</div>
</div>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code>.
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given <code>onCompleteMessage</code>
 will be sent to the destination actor.
 When the stream is completed with failure a <code>pekko.actor.Status.Failure</code>
 message will be sent to the destination actor.
 <p>
 It will request at most <code>maxInputBufferSize</code> number of elements from
 upstream, but there is no back-pressure signal from the destination actor,
 i.e. if the actor is not consuming the messages fast enough the mailbox
 of the actor will grow. For potentially slow consumer actors it is recommended
 to use a bounded mailbox with zero <code>mailbox-push-timeout-time</code> or use a rate
 limiting operator in front of this <code>Sink</code>.</div>
</li>
</ul>
<a id="actorRefWithBackpressure(org.apache.pekko.actor.ActorRef,java.lang.Object,java.lang.Object,java.lang.Object,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithBackpressure</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;actorRefWithBackpressure&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                                                          java.lang.Object&nbsp;onInitMessage,
                                                          java.lang.Object&nbsp;ackMessage,
                                                          java.lang.Object&nbsp;onCompleteMessage,
                                                          scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</pre>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal.
 First element is always <code>onInitMessage</code>, then stream is waiting for acknowledgement message
 <code>ackMessage</code> from the given actor which means that it is ready to process
 elements. It also requires <code>ackMessage</code> message after each stream element
 to make backpressure work.
 <p>
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given <code>onCompleteMessage</code>
 will be sent to the destination actor.
 When the stream is completed with failure - result of <code>onFailureMessage(throwable)</code>
 function will be sent to the destination actor.</div>
</li>
</ul>
<a id="actorRefWithBackpressure(org.apache.pekko.actor.ActorRef,java.lang.Object,java.lang.Object,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithBackpressure</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;actorRefWithBackpressure&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                                                          java.lang.Object&nbsp;onInitMessage,
                                                          java.lang.Object&nbsp;onCompleteMessage,
                                                          scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</pre>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal.
 First element is always <code>onInitMessage</code>, then stream is waiting for acknowledgement message
 from the given actor which means that it is ready to process
 elements. It also requires an ack message after each stream element
 to make backpressure work. This variant will consider any message as ack message.
 <p>
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given <code>onCompleteMessage</code>
 will be sent to the destination actor.
 When the stream is completed with failure - result of <code>onFailureMessage(throwable)</code>
 function will be sent to the destination actor.</div>
</li>
</ul>
<a id="actorRefWithAck(org.apache.pekko.actor.ActorRef,java.lang.Object,java.lang.Object,java.lang.Object,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithAck</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="../../NotUsed.html" title="class in org.apache.pekko">NotUsed</a>&gt;&nbsp;actorRefWithAck&#8203;(<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;ref,
                                                 java.lang.Object&nbsp;onInitMessage,
                                                 java.lang.Object&nbsp;ackMessage,
                                                 java.lang.Object&nbsp;onCompleteMessage,
                                                 scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;onFailureMessage)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use actorRefWithBackpressure accepting completion and failure matchers instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal.
 First element is always <code>onInitMessage</code>, then stream is waiting for acknowledgement message
 <code>ackMessage</code> from the given actor which means that it is ready to process
 elements. It also requires <code>ackMessage</code> message after each stream element
 to make backpressure work.
 <p>
 If the target actor terminates the stream will be canceled.
 When the stream is completed successfully the given <code>onCompleteMessage</code>
 will be sent to the destination actor.
 When the stream is completed with failure - result of <code>onFailureMessage(throwable)</code>
 function will be sent to the destination actor.</div>
</li>
</ul>
<a id="actorRefWithAck$default$5()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actorRefWithAck$default$5</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;scala.Function1&lt;java.lang.Throwable,&#8203;java.lang.Object&gt;&nbsp;actorRefWithAck$default$5()</pre>
</li>
</ul>
<a id="queue(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="SinkQueueWithCancel.html" title="interface in org.apache.pekko.stream.scaladsl">SinkQueueWithCancel</a>&lt;T&gt;&gt;&nbsp;queue&#8203;(int&nbsp;maxConcurrentPulls)</pre>
<div class="block">Creates a <code>Sink</code> that is materialized as an <code>pekko.stream.scaladsl.SinkQueueWithCancel</code>.
 <code>pekko.stream.scaladsl.SinkQueueWithCancel.pull</code> method is pulling element from the stream and returns <code></code>Future[Option[T]<code></code>.
 <code>Future</code> completes when element is available.
 <p>
 Before calling pull method second time you need to ensure that number of pending pulls is less then <code></code>maxConcurrentPulls<code></code>
 or wait until some of the previous Futures completes.
 Pull returns Failed future with ''IllegalStateException'' if there will be more then <code></code>maxConcurrentPulls<code></code> number of pending pulls.
 <p>
 <code>Sink</code> will request at most number of elements equal to size of <code>inputBuffer</code> from
 upstream and then stop back pressure.  You can configure size of input
 buffer by using <code>Sink.withAttributes</code> method.
 <p>
 For stream completion you need to pull all elements from <code>pekko.stream.scaladsl.SinkQueueWithCancel</code> including last None
 as completion marker
 <p>
 See also <code>pekko.stream.scaladsl.SinkQueueWithCancel</code></div>
</li>
</ul>
<a id="queue()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;<a href="SinkQueueWithCancel.html" title="interface in org.apache.pekko.stream.scaladsl">SinkQueueWithCancel</a>&lt;T&gt;&gt;&nbsp;queue()</pre>
<div class="block">Creates a <code>Sink</code> that is materialized as an <code>pekko.stream.scaladsl.SinkQueueWithCancel</code>.
 <code>pekko.stream.scaladsl.SinkQueueWithCancel.pull</code> method is pulling element from the stream and returns <code></code>Future[Option[T}<code></code>.
 <code>Future</code> completes when element is available.
 <p>
 Before calling pull method second time you need to wait until previous Future completes.
 Pull returns Failed future with ''IllegalStateException'' if previous future has not yet completed.
 <p>
 <code>Sink</code> will request at most number of elements equal to size of <code>inputBuffer</code> from
 upstream and then stop back pressure.  You can configure size of input
 buffer by using <code>Sink.withAttributes</code> method.
 <p>
 For stream completion you need to pull all elements from <code>pekko.stream.scaladsl.SinkQueueWithCancel</code> including last None
 as completion marker
 <p>
 See also <code>pekko.stream.scaladsl.SinkQueueWithCancel</code></div>
</li>
</ul>
<a id="lazyInit(scala.Function1,scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazyInit</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;lazyInit&#8203;(scala.Function1&lt;T,&#8203;scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;sinkFactory,
                                                                     scala.Function0&lt;M&gt;&nbsp;fallback)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Sink.lazyFutureSink' in combination with 'Flow.prefixAndTail(1)' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Creates a real <code>Sink</code> upon receiving the first element. Internal <code>Sink</code> will not be created if there are no elements,
 because of completion or error.
 <p>
 If upstream completes before an element was received then the <code>Future</code> is completed with the value created by fallback.
 If upstream fails before an element was received, <code>sinkFactory</code> throws an exception, or materialization of the internal
 sink fails then the <code>Future</code> is completed with the exception.
 Otherwise the <code>Future</code> is completed with the materialized value of the internal sink.</div>
</li>
</ul>
<a id="lazyInitAsync(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazyInitAsync</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;scala.Option&lt;M&gt;&gt;&gt;&nbsp;lazyInitAsync&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;sinkFactory)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use 'Sink.lazyFutureSink' instead. Since Akka 2.6.0.</div>
</div>
<div class="block">Creates a real <code>Sink</code> upon receiving the first element. Internal <code>Sink</code> will not be created if there are no elements,
 because of completion or error.
 <p>
 If upstream completes before an element was received then the <code>Future</code> is completed with <code>None</code>.
 If upstream fails before an element was received, <code>sinkFactory</code> throws an exception, or materialization of the internal
 sink fails then the <code>Future</code> is completed with the exception.
 Otherwise the <code>Future</code> is completed with the materialized value of the internal sink.</div>
</li>
</ul>
<a id="futureSink(scala.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>futureSink</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;futureSink&#8203;(scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;future)</pre>
<div class="block">Turn a <code>Future[Sink]</code> into a Sink that will consume the values of the source when the future completes successfully.
 If the <code>Future</code> is completed with a failure the stream is failed.
 <p>
 The materialized future value is completed with the materialized value of the future sink or failed with a
 <code>NeverMaterializedException</code> if upstream fails or downstream cancels before the future has completed.</div>
</li>
</ul>
<a id="lazySink(scala.Function0)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lazySink</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;lazySink&#8203;(scala.Function0&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a sink until there is a first element passed from upstream.
 <p>
 The materialized future value is completed with the materialized value of the created sink when that has successfully
 been materialized.
 <p>
 If the <code>create</code> function throws or returns or the stream fails to materialize, in this
 case the materialized future value is failed with a <code>pekko.stream.NeverMaterializedException</code>.</div>
</li>
</ul>
<a id="lazyFutureSink(scala.Function0)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>lazyFutureSink</h4>
<pre class="methodSignature">public&nbsp;&lt;T,&#8203;M&gt;&nbsp;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;scala.concurrent.Future&lt;M&gt;&gt;&nbsp;lazyFutureSink&#8203;(scala.Function0&lt;scala.concurrent.Future&lt;<a href="Sink.html" title="class in org.apache.pekko.stream.scaladsl">Sink</a>&lt;T,&#8203;M&gt;&gt;&gt;&nbsp;create)</pre>
<div class="block">Defers invoking the <code>create</code> function to create a future sink until there is a first element passed from upstream.
 <p>
 The materialized future value is completed with the materialized value of the created sink when that has successfully
 been materialized.
 <p>
 If the <code>create</code> function throws or returns a future that is failed, or the stream fails to materialize, in this
 case the materialized future value is failed with a <code>pekko.stream.NeverMaterializedException</code>.</div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
