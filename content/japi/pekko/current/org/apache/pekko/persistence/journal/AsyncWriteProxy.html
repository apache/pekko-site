<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.17) on Wed Mar 01 23:28:13 CET 2023 -->
<title>AsyncWriteProxy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-03-01">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="AsyncWriteProxy";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.persistence.journal</a></div>
<h2 title="Interface AsyncWriteProxy" class="title">Interface AsyncWriteProxy</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd><code><a href="../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code>, <code><a href="../../actor/ActorLogging.html" title="interface in org.apache.pekko.actor">ActorLogging</a></code>, <code><a href="AsyncRecovery.html" title="interface in org.apache.pekko.persistence.journal">AsyncRecovery</a></code>, <code><a href="AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code>, <code><a href="../../dispatch/RequiresMessageQueue.html" title="interface in org.apache.pekko.dispatch">RequiresMessageQueue</a>&lt;<a href="../../dispatch/DequeBasedMessageQueueSemantics.html" title="interface in org.apache.pekko.dispatch">DequeBasedMessageQueueSemantics</a>&gt;</code>, <code><a href="../../actor/Stash.html" title="interface in org.apache.pekko.actor">Stash</a></code>, <code><a href="../../actor/StashSupport.html" title="interface in org.apache.pekko.actor">StashSupport</a></code>, <code><a href="../../actor/UnrestrictedStash.html" title="interface in org.apache.pekko.actor">UnrestrictedStash</a></code>, <code><a href="WriteJournalBase.html" title="interface in org.apache.pekko.persistence.journal">WriteJournalBase</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">AsyncWriteProxy</span>
extends <a href="AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a>, <a href="../../actor/Stash.html" title="interface in org.apache.pekko.actor">Stash</a>, <a href="../../actor/ActorLogging.html" title="interface in org.apache.pekko.actor">ActorLogging</a></pre>
<div class="block">INTERNAL API.
 <p>
 A journal that delegates actual storage to a target actor. For testing only.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="AsyncWriteProxy.InitTimeout$.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteProxy.InitTimeout$</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="AsyncWriteProxy.SetStore.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteProxy.SetStore</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="AsyncWriteProxy.SetStore$.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteProxy.SetStore$</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.org.apache.pekko.actor.Actor">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;org.apache.pekko.actor.<a href="../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></h3>
<code><a href="../../actor/Actor.emptyBehavior$.html" title="class in org.apache.pekko.actor">Actor.emptyBehavior$</a>, <a href="../../actor/Actor.ignoringBehavior$.html" title="class in org.apache.pekko.actor">Actor.ignoringBehavior$</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.org.apache.pekko.persistence.journal.AsyncWriteJournal">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;org.apache.pekko.persistence.journal.<a href="AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></h3>
<code><a href="AsyncWriteJournal.Desequenced.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteJournal.Desequenced</a>, <a href="AsyncWriteJournal.Desequenced$.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteJournal.Desequenced$</a>, <a href="AsyncWriteJournal.Resequencer.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteJournal.Resequencer</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aroundPreStart()">aroundPreStart</a></span>()</code></th>
<td class="colLast">
<div class="block">INTERNAL API.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aroundReceive(scala.PartialFunction,java.lang.Object)">aroundReceive</a></span>&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;receive,
             java.lang.Object&nbsp;msg)</code></th>
<td class="colLast">
<div class="block">INTERNAL API.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asyncDeleteMessagesTo(java.lang.String,long)">asyncDeleteMessagesTo</a></span>&#8203;(java.lang.String&nbsp;persistenceId,
                     long&nbsp;toSequenceNr)</code></th>
<td class="colLast">
<div class="block">Plugin API: asynchronously deletes all persistent messages up to <code>toSequenceNr</code>
 (inclusive).</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asyncReadHighestSequenceNr(java.lang.String,long)">asyncReadHighestSequenceNr</a></span>&#8203;(java.lang.String&nbsp;persistenceId,
                          long&nbsp;fromSequenceNr)</code></th>
<td class="colLast">
<div class="block">Plugin API: asynchronously reads the highest stored sequence number for the
 given <code>persistenceId</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asyncReplayMessages(java.lang.String,long,long,long,scala.Function1)">asyncReplayMessages</a></span>&#8203;(java.lang.String&nbsp;persistenceId,
                   long&nbsp;fromSequenceNr,
                   long&nbsp;toSequenceNr,
                   long&nbsp;max,
                   scala.Function1&lt;<a href="../PersistentRepr.html" title="interface in org.apache.pekko.persistence">PersistentRepr</a>,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;replayCallback)</code></th>
<td class="colLast">
<div class="block">Plugin API: asynchronously replays persistent messages.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asyncWriteMessages(scala.collection.immutable.Seq)">asyncWriteMessages</a></span>&#8203;(scala.collection.immutable.Seq&lt;<a href="../AtomicWrite.html" title="class in org.apache.pekko.persistence">AtomicWrite</a>&gt;&nbsp;messages)</code></th>
<td class="colLast">
<div class="block">Plugin API: asynchronously writes a batch (<code>Seq</code>) of persistent messages to the
 journal.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInitialized_$eq(boolean)">isInitialized_$eq</a></span>&#8203;(boolean&nbsp;x$1)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInitTimedOut_$eq(boolean)">isInitTimedOut_$eq</a></span>&#8203;(boolean&nbsp;x$1)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>scala.Option&lt;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#store()">store</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#store_$eq(scala.Option)">store_$eq</a></span>&#8203;(scala.Option&lt;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;x$1)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#super$aroundPreStart()">super$aroundPreStart</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#super$aroundReceive(scala.PartialFunction,java.lang.Object)">super$aroundReceive</a></span>&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;receive,
                   java.lang.Object&nbsp;msg)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout()">timeout</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.actor.Actor">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.actor.<a href="../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></h3>
<code><a href="../../actor/Actor.html#aroundPostRestart(java.lang.Throwable)">aroundPostRestart</a>, <a href="../../actor/Actor.html#aroundPostStop()">aroundPostStop</a>, <a href="../../actor/Actor.html#aroundPreRestart(java.lang.Throwable,scala.Option)">aroundPreRestart</a>, <a href="../../actor/Actor.html#context()">context</a>, <a href="../../actor/Actor.html#org$apache$pekko$actor$Actor$_setter_$context_$eq(org.apache.pekko.actor.ActorContext)">org$apache$pekko$actor$Actor$_setter_$context_$eq</a>, <a href="../../actor/Actor.html#org$apache$pekko$actor$Actor$_setter_$self_$eq(org.apache.pekko.actor.ActorRef)">org$apache$pekko$actor$Actor$_setter_$self_$eq</a>, <a href="../../actor/Actor.html#postRestart(java.lang.Throwable)">postRestart</a>, <a href="../../actor/Actor.html#preStart()">preStart</a>, <a href="../../actor/Actor.html#self()">self</a>, <a href="../../actor/Actor.html#sender()">sender</a>, <a href="../../actor/Actor.html#supervisorStrategy()">supervisorStrategy</a>, <a href="../../actor/Actor.html#unhandled(java.lang.Object)">unhandled</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.actor.ActorLogging">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.actor.<a href="../../actor/ActorLogging.html" title="interface in org.apache.pekko.actor">ActorLogging</a></h3>
<code><a href="../../actor/ActorLogging.html#_log_$eq(org.apache.pekko.event.LoggingAdapter)">_log_$eq</a>, <a href="../../actor/ActorLogging.html#log()">log</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.persistence.journal.AsyncWriteJournal">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.persistence.journal.<a href="AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></h3>
<code><a href="AsyncWriteJournal.html#isReplayFilterEnabled()">isReplayFilterEnabled</a>, <a href="AsyncWriteJournal.html#org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq(scala.PartialFunction)">org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq</a>, <a href="AsyncWriteJournal.html#receive()">receive</a>, <a href="AsyncWriteJournal.html#receivePluginInternal()">receivePluginInternal</a>, <a href="AsyncWriteJournal.html#receiveWriteJournal()">receiveWriteJournal</a>, <a href="AsyncWriteJournal.html#resequencerCounter_$eq(long)">resequencerCounter_$eq</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.actor.StashSupport">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.actor.<a href="../../actor/StashSupport.html" title="interface in org.apache.pekko.actor">StashSupport</a></h3>
<code><a href="../../actor/StashSupport.html#actorCell()">actorCell</a>, <a href="../../actor/StashSupport.html#clearStash()">clearStash</a>, <a href="../../actor/StashSupport.html#context()">context</a>, <a href="../../actor/StashSupport.html#enqueueFirst(org.apache.pekko.dispatch.Envelope)">enqueueFirst</a>, <a href="../../actor/StashSupport.html#mailbox()">mailbox</a>, <a href="../../actor/StashSupport.html#org$apache$pekko$actor$StashSupport$_setter_$mailbox_$eq(org.apache.pekko.dispatch.DequeBasedMessageQueueSemantics)">org$apache$pekko$actor$StashSupport$_setter_$mailbox_$eq</a>, <a href="../../actor/StashSupport.html#prepend(scala.collection.immutable.Seq)">prepend</a>, <a href="../../actor/StashSupport.html#self()">self</a>, <a href="../../actor/StashSupport.html#stash()">stash</a>, <a href="../../actor/StashSupport.html#theStash_$eq(scala.collection.immutable.Vector)">theStash_$eq</a>, <a href="../../actor/StashSupport.html#unstash()">unstash</a>, <a href="../../actor/StashSupport.html#unstashAll()">unstashAll</a>, <a href="../../actor/StashSupport.html#unstashAll(scala.Function1)">unstashAll</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.actor.UnrestrictedStash">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.actor.<a href="../../actor/UnrestrictedStash.html" title="interface in org.apache.pekko.actor">UnrestrictedStash</a></h3>
<code><a href="../../actor/UnrestrictedStash.html#postStop()">postStop</a>, <a href="../../actor/UnrestrictedStash.html#preRestart(java.lang.Throwable,scala.Option)">preRestart</a>, <a href="../../actor/UnrestrictedStash.html#super$postStop()">super$postStop</a>, <a href="../../actor/UnrestrictedStash.html#super$preRestart(java.lang.Throwable,scala.Option)">super$preRestart</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.persistence.journal.WriteJournalBase">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.persistence.journal.<a href="WriteJournalBase.html" title="interface in org.apache.pekko.persistence.journal">WriteJournalBase</a></h3>
<code><a href="WriteJournalBase.html#adaptFromJournal(org.apache.pekko.persistence.PersistentRepr)">adaptFromJournal</a>, <a href="WriteJournalBase.html#adaptToJournal(org.apache.pekko.persistence.PersistentRepr)">adaptToJournal</a>, <a href="WriteJournalBase.html#org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq(org.apache.pekko.persistence.Persistence)">org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq</a>, <a href="WriteJournalBase.html#persistence()">persistence</a>, <a href="WriteJournalBase.html#preparePersistentBatch(scala.collection.immutable.Seq)">preparePersistentBatch</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="super$aroundPreStart()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>super$aroundPreStart</h4>
<pre class="methodSignature">void&nbsp;super$aroundPreStart()</pre>
</li>
</ul>
<a id="super$aroundReceive(scala.PartialFunction,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>super$aroundReceive</h4>
<pre class="methodSignature">void&nbsp;super$aroundReceive&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;receive,
                         java.lang.Object&nbsp;msg)</pre>
</li>
</ul>
<a id="isInitialized_$eq(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isInitialized_$eq</h4>
<pre class="methodSignature">void&nbsp;isInitialized_$eq&#8203;(boolean&nbsp;x$1)</pre>
</li>
</ul>
<a id="isInitTimedOut_$eq(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isInitTimedOut_$eq</h4>
<pre class="methodSignature">void&nbsp;isInitTimedOut_$eq&#8203;(boolean&nbsp;x$1)</pre>
</li>
</ul>
<a id="store()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>store</h4>
<pre class="methodSignature">scala.Option&lt;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;store()</pre>
</li>
</ul>
<a id="store_$eq(scala.Option)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>store_$eq</h4>
<pre class="methodSignature">void&nbsp;store_$eq&#8203;(scala.Option&lt;<a href="../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&gt;&nbsp;x$1)</pre>
</li>
</ul>
<a id="aroundPreStart()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aroundPreStart</h4>
<pre class="methodSignature">void&nbsp;aroundPreStart()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../actor/Actor.html#aroundPreStart()">Actor</a></code></span></div>
<div class="block">INTERNAL API.
 <p>
 Can be overridden to intercept calls to <code>preStart</code>. Calls <code>preStart</code> by default.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../actor/Actor.html#aroundPreStart()">aroundPreStart</a></code>&nbsp;in interface&nbsp;<code><a href="../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code></dd>
</dl>
</li>
</ul>
<a id="aroundReceive(scala.PartialFunction,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aroundReceive</h4>
<pre class="methodSignature">void&nbsp;aroundReceive&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;receive,
                   java.lang.Object&nbsp;msg)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../actor/Actor.html#aroundReceive(scala.PartialFunction,java.lang.Object)">Actor</a></code></span></div>
<div class="block">INTERNAL API.
 <p>
 Can be overridden to intercept calls to this actor's current behavior.
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../actor/Actor.html#aroundReceive(scala.PartialFunction,java.lang.Object)">aroundReceive</a></code>&nbsp;in interface&nbsp;<code><a href="../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>receive</code> - current behavior.</dd>
<dd><code>msg</code> - current message.</dd>
</dl>
</li>
</ul>
<a id="timeout()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature"><a href="../../util/Timeout.html" title="class in org.apache.pekko.util">Timeout</a>&nbsp;timeout()</pre>
</li>
</ul>
<a id="asyncWriteMessages(scala.collection.immutable.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncWriteMessages</h4>
<pre class="methodSignature">scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&gt;&nbsp;asyncWriteMessages&#8203;(scala.collection.immutable.Seq&lt;<a href="../AtomicWrite.html" title="class in org.apache.pekko.persistence">AtomicWrite</a>&gt;&nbsp;messages)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="AsyncWriteJournal.html#asyncWriteMessages(scala.collection.immutable.Seq)">AsyncWriteJournal</a></code></span></div>
<div class="block">Plugin API: asynchronously writes a batch (<code>Seq</code>) of persistent messages to the
 journal.
 <p>
 The batch is only for performance reasons, i.e. all messages don't have to be written
 atomically. Higher throughput can typically be achieved by using batch inserts of many
 records compared to inserting records one-by-one, but this aspect depends on the
 underlying data store and a journal implementation can implement it as efficient as
 possible. Journals should aim to persist events in-order for a given <code>persistenceId</code>
 as otherwise in case of a failure, the persistent state may be end up being inconsistent.
 <p>
 Each <code>AtomicWrite</code> message contains the single <code>PersistentRepr</code> that corresponds to
 the event that was passed to the <code>persist</code> method of the <code>PersistentActor</code>, or it
 contains several <code>PersistentRepr</code> that corresponds to the events that were passed
 to the <code>persistAll</code> method of the <code>PersistentActor</code>. All <code>PersistentRepr</code> of the
 <code>AtomicWrite</code> must be written to the data store atomically, i.e. all or none must
 be stored. If the journal (data store) cannot support atomic writes of multiple
 events it should reject such writes with a <code>Try</code> <code>Failure</code> with an
 <code>UnsupportedOperationException</code> describing the issue. This limitation should
 also be documented by the journal plugin.
 <p>
 If there are failures when storing any of the messages in the batch the returned
 <code>Future</code> must be completed with failure. The <code>Future</code> must only be completed with
 success when all messages in the batch have been confirmed to be stored successfully,
 i.e. they will be readable, and visible, in a subsequent replay. If there is
 uncertainty about if the messages were stored or not the <code>Future</code> must be completed
 with failure.
 <p>
 Data store connection problems must be signaled by completing the <code>Future</code> with
 failure.
 <p>
 The journal can also signal that it rejects individual messages (<code>AtomicWrite</code>) by
 the returned <code>immutable.Seq[Try[Unit}</code>. It is possible but not mandatory to reduce
 number of allocations by returning <code>Future.successful(Nil)</code> for the happy path,
 i.e. when no messages are rejected. Otherwise the returned <code>Seq</code> must have as many elements
 as the input <code>messages</code> <code>Seq</code>. Each <code>Try</code> element signals if the corresponding
 <code>AtomicWrite</code> is rejected or not, with an exception describing the problem. Rejecting
 a message means it was not stored, i.e. it must not be included in a later replay.
 Rejecting a message is typically done before attempting to store it, e.g. because of
 serialization error.
 <p>
 Data store connection problems must not be signaled as rejections.
 <p>
 It is possible but not mandatory to reduce number of allocations by returning
 <code>Future.successful(Nil)</code> for the happy path, i.e. when no messages are rejected.
 <p>
 Calls to this method are serialized by the enclosing journal actor. If you spawn
 work in asynchronous tasks it is alright that they complete the futures in any order,
 but the actual writes for a specific persistenceId should be serialized to avoid
 issues such as events of a later write are visible to consumers (query side, or replay)
 before the events of an earlier write are visible.
 A PersistentActor will not send a new WriteMessages request before the previous one
 has been completed.
 <p>
 Please note that the <code>sender</code> field of the contained PersistentRepr objects has been
 nulled out (i.e. set to <code>ActorRef.noSender</code>) in order to not use space in the journal
 for a sender reference that will likely be obsolete during replay.
 <p>
 Please also note that requests for the highest sequence number may be made concurrently
 to this call executing for the same <code>persistenceId</code>, in particular it is possible that
 a restarting actor tries to recover before its outstanding writes have completed. In
 the latter case it is highly desirable to defer reading the highest sequence number
 until all outstanding writes have completed, otherwise the PersistentActor may reuse
 sequence numbers.
 <p>
 This call is protected with a circuit-breaker.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="AsyncWriteJournal.html#asyncWriteMessages(scala.collection.immutable.Seq)">asyncWriteMessages</a></code>&nbsp;in interface&nbsp;<code><a href="AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code></dd>
</dl>
</li>
</ul>
<a id="asyncDeleteMessagesTo(java.lang.String,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncDeleteMessagesTo</h4>
<pre class="methodSignature">scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;&nbsp;asyncDeleteMessagesTo&#8203;(java.lang.String&nbsp;persistenceId,
                                                                       long&nbsp;toSequenceNr)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="AsyncWriteJournal.html#asyncDeleteMessagesTo(java.lang.String,long)">AsyncWriteJournal</a></code></span></div>
<div class="block">Plugin API: asynchronously deletes all persistent messages up to <code>toSequenceNr</code>
 (inclusive).
 <p>
 This call is protected with a circuit-breaker.
 Message deletion doesn't affect the highest sequence number of messages,
 journal must maintain the highest sequence number and never decrease it.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="AsyncWriteJournal.html#asyncDeleteMessagesTo(java.lang.String,long)">asyncDeleteMessagesTo</a></code>&nbsp;in interface&nbsp;<code><a href="AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code></dd>
</dl>
</li>
</ul>
<a id="asyncReplayMessages(java.lang.String,long,long,long,scala.Function1)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncReplayMessages</h4>
<pre class="methodSignature">scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;&nbsp;asyncReplayMessages&#8203;(java.lang.String&nbsp;persistenceId,
                                                                     long&nbsp;fromSequenceNr,
                                                                     long&nbsp;toSequenceNr,
                                                                     long&nbsp;max,
                                                                     scala.Function1&lt;<a href="../PersistentRepr.html" title="interface in org.apache.pekko.persistence">PersistentRepr</a>,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;replayCallback)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="AsyncRecovery.html#asyncReplayMessages(java.lang.String,long,long,long,scala.Function1)">AsyncRecovery</a></code></span></div>
<div class="block">Plugin API: asynchronously replays persistent messages. Implementations replay
 a message by calling <code>replayCallback</code>. The returned future must be completed
 when all messages (matching the sequence number bounds) have been replayed.
 The future must be completed with a failure if any of the persistent messages
 could not be replayed.
 <p>
 The <code>replayCallback</code> must also be called with messages that have been marked
 as deleted. In this case a replayed message's <code>deleted</code> method must return
 <code>true</code>.
 <p>
 The <code>toSequenceNr</code> is the lowest of what was returned by <a href="AsyncRecovery.html#asyncReadHighestSequenceNr(java.lang.String,long)"><code>AsyncRecovery.asyncReadHighestSequenceNr(java.lang.String, long)</code></a>
 and what the user specified as recovery <code>pekko.persistence.Recovery</code> parameter.
 This does imply that this call is always preceded by reading the highest sequence
 number for the given <code>persistenceId</code>.
 <p>
 This call is NOT protected with a circuit-breaker because it may take long time
 to replay all events. The plugin implementation itself must protect against
 an unresponsive backend store and make sure that the returned Future is
 completed with success or failure within reasonable time. It is not allowed
 to ignore completing the future.
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="AsyncRecovery.html#asyncReplayMessages(java.lang.String,long,long,long,scala.Function1)">asyncReplayMessages</a></code>&nbsp;in interface&nbsp;<code><a href="AsyncRecovery.html" title="interface in org.apache.pekko.persistence.journal">AsyncRecovery</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>persistenceId</code> - persistent actor id.</dd>
<dd><code>fromSequenceNr</code> - sequence number where replay should start (inclusive).</dd>
<dd><code>toSequenceNr</code> - sequence number where replay should end (inclusive).</dd>
<dd><code>max</code> - maximum number of messages to be replayed.</dd>
<dd><code>replayCallback</code> - called to replay a single message. Can be called from any
                       thread.
 <p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal"><code>AsyncWriteJournal</code></a></dd>
</dl>
</li>
</ul>
<a id="asyncReadHighestSequenceNr(java.lang.String,long)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>asyncReadHighestSequenceNr</h4>
<pre class="methodSignature">scala.concurrent.Future&lt;java.lang.Object&gt;&nbsp;asyncReadHighestSequenceNr&#8203;(java.lang.String&nbsp;persistenceId,
                                                                     long&nbsp;fromSequenceNr)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="AsyncRecovery.html#asyncReadHighestSequenceNr(java.lang.String,long)">AsyncRecovery</a></code></span></div>
<div class="block">Plugin API: asynchronously reads the highest stored sequence number for the
 given <code>persistenceId</code>. The persistent actor will use the highest sequence
 number after recovery as the starting point when persisting new events.
 This sequence number is also used as <code>toSequenceNr</code> in subsequent call
 to <a href="AsyncRecovery.html#asyncReplayMessages(java.lang.String,long,long,long,scala.Function1)"><code>AsyncRecovery.asyncReplayMessages(java.lang.String, long, long, long, scala.Function1&lt;org.apache.pekko.persistence.PersistentRepr, scala.runtime.BoxedUnit&gt;)</code></a> unless the user has specified a lower <code>toSequenceNr</code>.
 Journal must maintain the highest sequence number and never decrease it.
 <p>
 This call is protected with a circuit-breaker.
 <p>
 Please also note that requests for the highest sequence number may be made concurrently
 to writes executing for the same <code>persistenceId</code>, in particular it is possible that
 a restarting actor tries to recover before its outstanding writes have completed.
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="AsyncRecovery.html#asyncReadHighestSequenceNr(java.lang.String,long)">asyncReadHighestSequenceNr</a></code>&nbsp;in interface&nbsp;<code><a href="AsyncRecovery.html" title="interface in org.apache.pekko.persistence.journal">AsyncRecovery</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>persistenceId</code> - persistent actor id.</dd>
<dd><code>fromSequenceNr</code> - hint where to start searching for the highest sequence
                       number. When a persistent actor is recovering this
                       <code>fromSequenceNr</code> will be the sequence number of the used
                       snapshot or <code>0L</code> if no snapshot is used.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
