<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.17) on Wed Mar 01 23:28:13 CET 2023 -->
<title>AsyncWriteJournal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-03-01">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="AsyncWriteJournal";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":6,"i4":6,"i5":6,"i6":6,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.apache.pekko.persistence.journal.japi</a></div>
<h2 title="Class AsyncWriteJournal" class="title">Class AsyncWriteJournal</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="AsyncRecovery.html" title="class in org.apache.pekko.persistence.journal.japi">org.apache.pekko.persistence.journal.japi.AsyncRecovery</a></li>
<li>
<ul class="inheritance">
<li>org.apache.pekko.persistence.journal.japi.AsyncWriteJournal</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="../../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code>, <code><a href="../AsyncRecovery.html" title="interface in org.apache.pekko.persistence.journal">AsyncRecovery</a></code>, <code><a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code>, <code><a href="../WriteJournalBase.html" title="interface in org.apache.pekko.persistence.journal">WriteJournalBase</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">AsyncWriteJournal</span>
extends <a href="AsyncRecovery.html" title="class in org.apache.pekko.persistence.journal.japi">AsyncRecovery</a>
implements <a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></pre>
<div class="block">Java API: abstract journal, optimized for asynchronous, non-blocking writes.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.org.apache.pekko.actor.Actor">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;org.apache.pekko.actor.<a href="../../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></h3>
<code><a href="../../../actor/Actor.emptyBehavior$.html" title="class in org.apache.pekko.actor">Actor.emptyBehavior$</a>, <a href="../../../actor/Actor.ignoringBehavior$.html" title="class in org.apache.pekko.actor">Actor.ignoringBehavior$</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.org.apache.pekko.persistence.journal.AsyncWriteJournal">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;org.apache.pekko.persistence.journal.<a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></h3>
<code><a href="../AsyncWriteJournal.Desequenced.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteJournal.Desequenced</a>, <a href="../AsyncWriteJournal.Desequenced$.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteJournal.Desequenced$</a>, <a href="../AsyncWriteJournal.Resequencer.html" title="class in org.apache.pekko.persistence.journal">AsyncWriteJournal.Resequencer</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">AsyncWriteJournal</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asyncDeleteMessagesTo(java.lang.String,long)">asyncDeleteMessagesTo</a></span>&#8203;(java.lang.String&nbsp;persistenceId,
                     long&nbsp;toSequenceNr)</code></th>
<td class="colLast">
<div class="block">Plugin API: asynchronously deletes all persistent messages up to <code>toSequenceNr</code>
 (inclusive).</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asyncWriteMessages(scala.collection.immutable.Seq)">asyncWriteMessages</a></span>&#8203;(scala.collection.immutable.Seq&lt;<a href="../../AtomicWrite.html" title="class in org.apache.pekko.persistence">AtomicWrite</a>&gt;&nbsp;messages)</code></th>
<td class="colLast">
<div class="block">Plugin API: asynchronously writes a batch (<code>Seq</code>) of persistent messages to the
 journal.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../actor/ActorContext.html" title="interface in org.apache.pekko.actor">ActorContext</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#context()">context</a></span>()</code></th>
<td class="colLast">
<div class="block">Scala API: Stores the context for this actor, including self, and sender.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;java.lang.Void&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#doAsyncDeleteMessagesTo(java.lang.String,long)">doAsyncDeleteMessagesTo</a></span>&#8203;(java.lang.String&nbsp;persistenceId,
                       long&nbsp;toSequenceNr)</code></th>
<td class="colLast">
<div class="block">Java API, Plugin API: synchronously deletes all persistent messages up to `toSequenceNr`.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#doAsyncReadHighestSequenceNr(java.lang.String,long)">doAsyncReadHighestSequenceNr</a></span>&#8203;(java.lang.String&nbsp;persistenceId,
                            long&nbsp;fromSequenceNr)</code></th>
<td class="colLast">
<div class="block">Java API, Plugin API: asynchronously reads the highest stored sequence number for the given
 `persistenceId`.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;java.lang.Void&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#doAsyncReplayMessages(java.lang.String,long,long,long,java.util.function.Consumer)">doAsyncReplayMessages</a></span>&#8203;(java.lang.String&nbsp;persistenceId,
                     long&nbsp;fromSequenceNr,
                     long&nbsp;toSequenceNr,
                     long&nbsp;max,
                     java.util.function.Consumer&lt;<a href="../../PersistentRepr.html" title="interface in org.apache.pekko.persistence">PersistentRepr</a>&gt;&nbsp;replayCallback)</code></th>
<td class="colLast">
<div class="block">Java API, Plugin API: asynchronously replays persistent messages.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>scala.concurrent.Future&lt;java.lang.Iterable&lt;java.util.Optional&lt;java.lang.Exception&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#doAsyncWriteMessages(java.lang.Iterable)">doAsyncWriteMessages</a></span>&#8203;(java.lang.Iterable&lt;<a href="../../AtomicWrite.html" title="class in org.apache.pekko.persistence">AtomicWrite</a>&gt;&nbsp;messages)</code></th>
<td class="colLast">
<div class="block">Java API, Plugin API: asynchronously writes a batch (`Iterable`) of persistent messages to the
 journal.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#org$apache$pekko$actor$Actor$_setter_$context_$eq(org.apache.pekko.actor.ActorContext)">org$apache$pekko$actor$Actor$_setter_$context_$eq</a></span>&#8203;(<a href="../../../actor/ActorContext.html" title="interface in org.apache.pekko.actor">ActorContext</a>&nbsp;x$1)</code></th>
<td class="colLast">
<div class="block">Scala API: Stores the context for this actor, including self, and sender.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#org$apache$pekko$actor$Actor$_setter_$self_$eq(org.apache.pekko.actor.ActorRef)">org$apache$pekko$actor$Actor$_setter_$self_$eq</a></span>&#8203;(<a href="../../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;x$1)</code></th>
<td class="colLast">
<div class="block">The 'self' field holds the ActorRef for this actor.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq(scala.PartialFunction)">org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq</a></span>&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;x$1)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq(org.apache.pekko.persistence.Persistence)">org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq</a></span>&#8203;(<a href="../../Persistence.html" title="class in org.apache.pekko.persistence">Persistence</a>&nbsp;x$1)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../Persistence.html" title="class in org.apache.pekko.persistence">Persistence</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#persistence()">persistence</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#receiveWriteJournal()">receiveWriteJournal</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="../../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#self()">self</a></span>()</code></th>
<td class="colLast">
<div class="block">The 'self' field holds the ActorRef for this actor.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.persistence.journal.japi.AsyncRecovery">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;org.apache.pekko.persistence.journal.japi.<a href="AsyncRecovery.html" title="class in org.apache.pekko.persistence.journal.japi">AsyncRecovery</a></h3>
<code><a href="AsyncRecovery.html#asyncReadHighestSequenceNr(java.lang.String,long)">asyncReadHighestSequenceNr</a>, <a href="AsyncRecovery.html#asyncReplayMessages(java.lang.String,long,long,long,scala.Function1)">asyncReplayMessages</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.actor.Actor">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.actor.<a href="../../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></h3>
<code><a href="../../../actor/Actor.html#aroundPostRestart(java.lang.Throwable)">aroundPostRestart</a>, <a href="../../../actor/Actor.html#aroundPostStop()">aroundPostStop</a>, <a href="../../../actor/Actor.html#aroundPreRestart(java.lang.Throwable,scala.Option)">aroundPreRestart</a>, <a href="../../../actor/Actor.html#aroundPreStart()">aroundPreStart</a>, <a href="../../../actor/Actor.html#aroundReceive(scala.PartialFunction,java.lang.Object)">aroundReceive</a>, <a href="../../../actor/Actor.html#postRestart(java.lang.Throwable)">postRestart</a>, <a href="../../../actor/Actor.html#postStop()">postStop</a>, <a href="../../../actor/Actor.html#preRestart(java.lang.Throwable,scala.Option)">preRestart</a>, <a href="../../../actor/Actor.html#preStart()">preStart</a>, <a href="../../../actor/Actor.html#sender()">sender</a>, <a href="../../../actor/Actor.html#supervisorStrategy()">supervisorStrategy</a>, <a href="../../../actor/Actor.html#unhandled(java.lang.Object)">unhandled</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.persistence.journal.AsyncRecovery">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.persistence.journal.<a href="../AsyncRecovery.html" title="interface in org.apache.pekko.persistence.journal">AsyncRecovery</a></h3>
<code><a href="../AsyncRecovery.html#asyncReadHighestSequenceNr(java.lang.String,long)">asyncReadHighestSequenceNr</a>, <a href="../AsyncRecovery.html#asyncReplayMessages(java.lang.String,long,long,long,scala.Function1)">asyncReplayMessages</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.persistence.journal.AsyncWriteJournal">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.persistence.journal.<a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></h3>
<code><a href="../AsyncWriteJournal.html#isReplayFilterEnabled()">isReplayFilterEnabled</a>, <a href="../AsyncWriteJournal.html#receive()">receive</a>, <a href="../AsyncWriteJournal.html#receivePluginInternal()">receivePluginInternal</a>, <a href="../AsyncWriteJournal.html#resequencerCounter_$eq(long)">resequencerCounter_$eq</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.apache.pekko.persistence.journal.WriteJournalBase">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.pekko.persistence.journal.<a href="../WriteJournalBase.html" title="interface in org.apache.pekko.persistence.journal">WriteJournalBase</a></h3>
<code><a href="../WriteJournalBase.html#adaptFromJournal(org.apache.pekko.persistence.PersistentRepr)">adaptFromJournal</a>, <a href="../WriteJournalBase.html#adaptToJournal(org.apache.pekko.persistence.PersistentRepr)">adaptToJournal</a>, <a href="../WriteJournalBase.html#preparePersistentBatch(scala.collection.immutable.Seq)">preparePersistentBatch</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>AsyncWriteJournal</h4>
<pre>public&nbsp;AsyncWriteJournal()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="asyncDeleteMessagesTo(java.lang.String,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncDeleteMessagesTo</h4>
<pre class="methodSignature">public final&nbsp;scala.concurrent.Future&lt;scala.runtime.BoxedUnit&gt;&nbsp;asyncDeleteMessagesTo&#8203;(java.lang.String&nbsp;persistenceId,
                                                                                    long&nbsp;toSequenceNr)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../AsyncWriteJournal.html#asyncDeleteMessagesTo(java.lang.String,long)">AsyncWriteJournal</a></code></span></div>
<div class="block">Plugin API: asynchronously deletes all persistent messages up to <code>toSequenceNr</code>
 (inclusive).
 <p>
 This call is protected with a circuit-breaker.
 Message deletion doesn't affect the highest sequence number of messages,
 journal must maintain the highest sequence number and never decrease it.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../AsyncWriteJournal.html#asyncDeleteMessagesTo(java.lang.String,long)">asyncDeleteMessagesTo</a></code>&nbsp;in interface&nbsp;<code><a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code></dd>
</dl>
</li>
</ul>
<a id="asyncWriteMessages(scala.collection.immutable.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asyncWriteMessages</h4>
<pre class="methodSignature">public final&nbsp;scala.concurrent.Future&lt;scala.collection.immutable.Seq&lt;scala.util.Try&lt;scala.runtime.BoxedUnit&gt;&gt;&gt;&nbsp;asyncWriteMessages&#8203;(scala.collection.immutable.Seq&lt;<a href="../../AtomicWrite.html" title="class in org.apache.pekko.persistence">AtomicWrite</a>&gt;&nbsp;messages)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../AsyncWriteJournal.html#asyncWriteMessages(scala.collection.immutable.Seq)">AsyncWriteJournal</a></code></span></div>
<div class="block">Plugin API: asynchronously writes a batch (<code>Seq</code>) of persistent messages to the
 journal.
 <p>
 The batch is only for performance reasons, i.e. all messages don't have to be written
 atomically. Higher throughput can typically be achieved by using batch inserts of many
 records compared to inserting records one-by-one, but this aspect depends on the
 underlying data store and a journal implementation can implement it as efficient as
 possible. Journals should aim to persist events in-order for a given <code>persistenceId</code>
 as otherwise in case of a failure, the persistent state may be end up being inconsistent.
 <p>
 Each <code>AtomicWrite</code> message contains the single <code>PersistentRepr</code> that corresponds to
 the event that was passed to the <code>persist</code> method of the <code>PersistentActor</code>, or it
 contains several <code>PersistentRepr</code> that corresponds to the events that were passed
 to the <code>persistAll</code> method of the <code>PersistentActor</code>. All <code>PersistentRepr</code> of the
 <code>AtomicWrite</code> must be written to the data store atomically, i.e. all or none must
 be stored. If the journal (data store) cannot support atomic writes of multiple
 events it should reject such writes with a <code>Try</code> <code>Failure</code> with an
 <code>UnsupportedOperationException</code> describing the issue. This limitation should
 also be documented by the journal plugin.
 <p>
 If there are failures when storing any of the messages in the batch the returned
 <code>Future</code> must be completed with failure. The <code>Future</code> must only be completed with
 success when all messages in the batch have been confirmed to be stored successfully,
 i.e. they will be readable, and visible, in a subsequent replay. If there is
 uncertainty about if the messages were stored or not the <code>Future</code> must be completed
 with failure.
 <p>
 Data store connection problems must be signaled by completing the <code>Future</code> with
 failure.
 <p>
 The journal can also signal that it rejects individual messages (<code>AtomicWrite</code>) by
 the returned <code>immutable.Seq[Try[Unit}</code>. It is possible but not mandatory to reduce
 number of allocations by returning <code>Future.successful(Nil)</code> for the happy path,
 i.e. when no messages are rejected. Otherwise the returned <code>Seq</code> must have as many elements
 as the input <code>messages</code> <code>Seq</code>. Each <code>Try</code> element signals if the corresponding
 <code>AtomicWrite</code> is rejected or not, with an exception describing the problem. Rejecting
 a message means it was not stored, i.e. it must not be included in a later replay.
 Rejecting a message is typically done before attempting to store it, e.g. because of
 serialization error.
 <p>
 Data store connection problems must not be signaled as rejections.
 <p>
 It is possible but not mandatory to reduce number of allocations by returning
 <code>Future.successful(Nil)</code> for the happy path, i.e. when no messages are rejected.
 <p>
 Calls to this method are serialized by the enclosing journal actor. If you spawn
 work in asynchronous tasks it is alright that they complete the futures in any order,
 but the actual writes for a specific persistenceId should be serialized to avoid
 issues such as events of a later write are visible to consumers (query side, or replay)
 before the events of an earlier write are visible.
 A PersistentActor will not send a new WriteMessages request before the previous one
 has been completed.
 <p>
 Please note that the <code>sender</code> field of the contained PersistentRepr objects has been
 nulled out (i.e. set to <code>ActorRef.noSender</code>) in order to not use space in the journal
 for a sender reference that will likely be obsolete during replay.
 <p>
 Please also note that requests for the highest sequence number may be made concurrently
 to this call executing for the same <code>persistenceId</code>, in particular it is possible that
 a restarting actor tries to recover before its outstanding writes have completed. In
 the latter case it is highly desirable to defer reading the highest sequence number
 until all outstanding writes have completed, otherwise the PersistentActor may reuse
 sequence numbers.
 <p>
 This call is protected with a circuit-breaker.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../AsyncWriteJournal.html#asyncWriteMessages(scala.collection.immutable.Seq)">asyncWriteMessages</a></code>&nbsp;in interface&nbsp;<code><a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code></dd>
</dl>
</li>
</ul>
<a id="context()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>context</h4>
<pre class="methodSignature">public&nbsp;<a href="../../../actor/ActorContext.html" title="interface in org.apache.pekko.actor">ActorContext</a>&nbsp;context()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../actor/Actor.html#context()">Actor</a></code></span></div>
<div class="block">Scala API: Stores the context for this actor, including self, and sender.
 It is implicit to support operations such as <code>forward</code>.
 <p>
 WARNING: Only valid within the Actor itself, so do not close over it and
 publish it to other threads!
 <p>
 <code>pekko.actor.ActorContext</code> is the Scala API. <code>getContext</code> returns a
 <code>pekko.actor.AbstractActor.ActorContext</code>, which is the Java API of the actor
 context.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../actor/Actor.html#context()">context</a></code>&nbsp;in interface&nbsp;<code><a href="../../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code></dd>
</dl>
</li>
</ul>
<a id="org$apache$pekko$actor$Actor$_setter_$context_$eq(org.apache.pekko.actor.ActorContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>org$apache$pekko$actor$Actor$_setter_$context_$eq</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;org$apache$pekko$actor$Actor$_setter_$context_$eq&#8203;(<a href="../../../actor/ActorContext.html" title="interface in org.apache.pekko.actor">ActorContext</a>&nbsp;x$1)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../actor/Actor.html#org$apache$pekko$actor$Actor$_setter_$context_$eq(org.apache.pekko.actor.ActorContext)">Actor</a></code></span></div>
<div class="block">Scala API: Stores the context for this actor, including self, and sender.
 It is implicit to support operations such as <code>forward</code>.
 <p>
 WARNING: Only valid within the Actor itself, so do not close over it and
 publish it to other threads!
 <p>
 <code>pekko.actor.ActorContext</code> is the Scala API. <code>getContext</code> returns a
 <code>pekko.actor.AbstractActor.ActorContext</code>, which is the Java API of the actor
 context.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../actor/Actor.html#org$apache$pekko$actor$Actor$_setter_$context_$eq(org.apache.pekko.actor.ActorContext)">org$apache$pekko$actor$Actor$_setter_$context_$eq</a></code>&nbsp;in interface&nbsp;<code><a href="../../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code></dd>
</dl>
</li>
</ul>
<a id="org$apache$pekko$actor$Actor$_setter_$self_$eq(org.apache.pekko.actor.ActorRef)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>org$apache$pekko$actor$Actor$_setter_$self_$eq</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;org$apache$pekko$actor$Actor$_setter_$self_$eq&#8203;(<a href="../../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;x$1)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../actor/Actor.html#org$apache$pekko$actor$Actor$_setter_$self_$eq(org.apache.pekko.actor.ActorRef)">Actor</a></code></span></div>
<div class="block">The 'self' field holds the ActorRef for this actor.
 <p></p>
 Can be used to send messages to itself:
 <pre>
 self ! message
 </pre></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../actor/Actor.html#org$apache$pekko$actor$Actor$_setter_$self_$eq(org.apache.pekko.actor.ActorRef)">org$apache$pekko$actor$Actor$_setter_$self_$eq</a></code>&nbsp;in interface&nbsp;<code><a href="../../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code></dd>
</dl>
</li>
</ul>
<a id="org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq(scala.PartialFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq&#8203;(scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;x$1)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../AsyncWriteJournal.html#org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq(scala.PartialFunction)">org$apache$pekko$persistence$journal$AsyncWriteJournal$_setter_$receiveWriteJournal_$eq</a></code>&nbsp;in interface&nbsp;<code><a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code></dd>
</dl>
</li>
</ul>
<a id="org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq(org.apache.pekko.persistence.Persistence)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq&#8203;(<a href="../../Persistence.html" title="class in org.apache.pekko.persistence">Persistence</a>&nbsp;x$1)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../WriteJournalBase.html#org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq(org.apache.pekko.persistence.Persistence)">org$apache$pekko$persistence$journal$WriteJournalBase$_setter_$persistence_$eq</a></code>&nbsp;in interface&nbsp;<code><a href="../WriteJournalBase.html" title="interface in org.apache.pekko.persistence.journal">WriteJournalBase</a></code></dd>
</dl>
</li>
</ul>
<a id="persistence()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>persistence</h4>
<pre class="methodSignature">public&nbsp;<a href="../../Persistence.html" title="class in org.apache.pekko.persistence">Persistence</a>&nbsp;persistence()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../WriteJournalBase.html#persistence()">persistence</a></code>&nbsp;in interface&nbsp;<code><a href="../WriteJournalBase.html" title="interface in org.apache.pekko.persistence.journal">WriteJournalBase</a></code></dd>
</dl>
</li>
</ul>
<a id="receiveWriteJournal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>receiveWriteJournal</h4>
<pre class="methodSignature">public final&nbsp;scala.PartialFunction&lt;java.lang.Object,&#8203;scala.runtime.BoxedUnit&gt;&nbsp;receiveWriteJournal()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../AsyncWriteJournal.html#receiveWriteJournal()">receiveWriteJournal</a></code>&nbsp;in interface&nbsp;<code><a href="../AsyncWriteJournal.html" title="interface in org.apache.pekko.persistence.journal">AsyncWriteJournal</a></code></dd>
</dl>
</li>
</ul>
<a id="self()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>self</h4>
<pre class="methodSignature">public final&nbsp;<a href="../../../actor/ActorRef.html" title="class in org.apache.pekko.actor">ActorRef</a>&nbsp;self()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../actor/Actor.html#self()">Actor</a></code></span></div>
<div class="block">The 'self' field holds the ActorRef for this actor.
 <p></p>
 Can be used to send messages to itself:
 <pre>
 self ! message
 </pre></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../actor/Actor.html#self()">self</a></code>&nbsp;in interface&nbsp;<code><a href="../../../actor/Actor.html" title="interface in org.apache.pekko.actor">Actor</a></code></dd>
</dl>
</li>
</ul>
<a id="doAsyncWriteMessages(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doAsyncWriteMessages</h4>
<pre class="methodSignature">public abstract&nbsp;scala.concurrent.Future&lt;java.lang.Iterable&lt;java.util.Optional&lt;java.lang.Exception&gt;&gt;&gt;&nbsp;doAsyncWriteMessages&#8203;(java.lang.Iterable&lt;<a href="../../AtomicWrite.html" title="class in org.apache.pekko.persistence">AtomicWrite</a>&gt;&nbsp;messages)</pre>
<div class="block">Java API, Plugin API: asynchronously writes a batch (`Iterable`) of persistent messages to the
 journal.

 <p>The batch is only for performance reasons, i.e. all messages don't have to be written
 atomically. Higher throughput can typically be achieved by using batch inserts of many records
 compared to inserting records one-by-one, but this aspect depends on the underlying data store
 and a journal implementation can implement it as efficient as possible. Journals should aim to
 persist events in-order for a given `persistenceId` as otherwise in case of a failure, the
 persistent state may be end up being inconsistent.

 <p>Each `AtomicWrite` message contains the single `PersistentRepr` that corresponds to the
 event that was passed to the `persist` method of the `PersistentActor`, or it contains several
 `PersistentRepr` that corresponds to the events that were passed to the `persistAll` method of
 the `PersistentActor`. All `PersistentRepr` of the `AtomicWrite` must be written to the data
 store atomically, i.e. all or none must be stored. If the journal (data store) cannot support
 atomic writes of multiple events it should reject such writes with an `Optional` with an
 `UnsupportedOperationException` describing the issue. This limitation should also be documented
 by the journal plugin.

 <p>If there are failures when storing any of the messages in the batch the returned `Future`
 must be completed with failure. The `Future` must only be completed with success when all
 messages in the batch have been confirmed to be stored successfully, i.e. they will be
 readable, and visible, in a subsequent replay. If there is uncertainty about if the messages
 were stored or not the `Future` must be completed with failure.

 <p>Data store connection problems must be signaled by completing the `Future` with failure.

 <p>The journal can also signal that it rejects individual messages (`AtomicWrite`) by the
 returned `Iterable&lt;Optional&lt;Exception&gt;&gt;`. The returned `Iterable` must have as many
 elements as the input `messages` `Iterable`. Each `Optional` element signals if the
 corresponding `AtomicWrite` is rejected or not, with an exception describing the problem.
 Rejecting a message means it was not stored, i.e. it must not be included in a later replay.
 Rejecting a message is typically done before attempting to store it, e.g. because of
 serialization error.

 <p>Data store connection problems must not be signaled as rejections.

 <p>Note that it is possible to reduce number of allocations by caching some result `Iterable`
 for the happy path, i.e. when no messages are rejected.

 <p>Calls to this method are serialized by the enclosing journal actor. If you spawn work in
 asynchronous tasks it is alright that they complete the futures in any order, but the actual
 writes for a specific persistenceId should be serialized to avoid issues such as events of a
 later write are visible to consumers (query side, or replay) before the events of an earlier
 write are visible. This can also be done with consistent hashing if it is too fine grained to
 do it on the persistenceId level. Normally a `PersistentActor` will only have one outstanding
 write request to the journal but it may emit several write requests when `persistAsync` is used
 and the max batch size is reached.

 <p>This call is protected with a circuit-breaker.</div>
</li>
</ul>
<a id="doAsyncDeleteMessagesTo(java.lang.String,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doAsyncDeleteMessagesTo</h4>
<pre class="methodSignature">public abstract&nbsp;scala.concurrent.Future&lt;java.lang.Void&gt;&nbsp;doAsyncDeleteMessagesTo&#8203;(java.lang.String&nbsp;persistenceId,
                                                                                long&nbsp;toSequenceNr)</pre>
<div class="block">Java API, Plugin API: synchronously deletes all persistent messages up to `toSequenceNr`.

 <p>This call is protected with a circuit-breaker.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>AsyncRecoveryPlugin</code></dd>
</dl>
</li>
</ul>
<a id="doAsyncReplayMessages(java.lang.String,long,long,long,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doAsyncReplayMessages</h4>
<pre class="methodSignature">public abstract&nbsp;scala.concurrent.Future&lt;java.lang.Void&gt;&nbsp;doAsyncReplayMessages&#8203;(java.lang.String&nbsp;persistenceId,
                                                                              long&nbsp;fromSequenceNr,
                                                                              long&nbsp;toSequenceNr,
                                                                              long&nbsp;max,
                                                                              java.util.function.Consumer&lt;<a href="../../PersistentRepr.html" title="interface in org.apache.pekko.persistence">PersistentRepr</a>&gt;&nbsp;replayCallback)</pre>
<div class="block">Java API, Plugin API: asynchronously replays persistent messages. Implementations replay a
 message by calling `replayCallback`. The returned future must be completed when all messages
 (matching the sequence number bounds) have been replayed. The future must be completed with a
 failure if any of the persistent messages could not be replayed.

 <p>The `replayCallback` must also be called with messages that have been marked as deleted. In
 this case a replayed message's `deleted` method must return `true`.

 <p>The `toSequenceNr` is the lowest of what was returned by <a href="#doAsyncReadHighestSequenceNr(java.lang.String,long)"><code>doAsyncReadHighestSequenceNr(java.lang.String, long)</code></a> and what the user specified as recovery <a href="../../Recovery.html" title="class in org.apache.pekko.persistence"><code>Recovery</code></a> parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>persistenceId</code> - id of the persistent actor.</dd>
<dd><code>fromSequenceNr</code> - sequence number where replay should start (inclusive).</dd>
<dd><code>toSequenceNr</code> - sequence number where replay should end (inclusive).</dd>
<dd><code>max</code> - maximum number of messages to be replayed.</dd>
<dd><code>replayCallback</code> - called to replay a single message. Can be called from any thread.</dd>
</dl>
</li>
</ul>
<a id="doAsyncReadHighestSequenceNr(java.lang.String,long)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>doAsyncReadHighestSequenceNr</h4>
<pre class="methodSignature">public abstract&nbsp;scala.concurrent.Future&lt;java.lang.Long&gt;&nbsp;doAsyncReadHighestSequenceNr&#8203;(java.lang.String&nbsp;persistenceId,
                                                                                     long&nbsp;fromSequenceNr)</pre>
<div class="block">Java API, Plugin API: asynchronously reads the highest stored sequence number for the given
 `persistenceId`. The persistent actor will use the highest sequence number after recovery as
 the starting point when persisting new events. This sequence number is also used as
 `toSequenceNr` in subsequent call to [[#asyncReplayMessages]] unless the user has specified a
 lower `toSequenceNr`.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>persistenceId</code> - id of the persistent actor.</dd>
<dd><code>fromSequenceNr</code> - hint where to start searching for the highest sequence number.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
