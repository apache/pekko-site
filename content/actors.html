<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Classic Actors · Pekko Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='Apache Pekko is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.'/>
<link rel="canonical" href="https://doc.akka.io/docs/akka/currentactors.html"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/warnOldVersion.js"></script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/snippets.js"></script>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>

<!--
<link rel="shortcut icon" href="images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Pekko Documentation
</a>
<div class="version-number">
HEAD+20230118-1331
</div>
</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="typed/guide/introduction.html" class="page">Introduction to Pekko</a></li>
    <li><a href="typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="typed/guide/modules.html" class="page">Overview of Pekko libraries and modules</a></li>
    <li><a href="typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="typed/guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
    <li><a href="typed/guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
  </ul></li>
  <li><a href="general/index.html" class="page">General Concepts</a>
  <ul>
    <li><a href="general/terminology.html" class="page">Terminology, Concepts</a></li>
    <li><a href="general/actor-systems.html" class="page">Actor Systems</a></li>
    <li><a href="general/actors.html" class="page">What is an Actor?</a></li>
    <li><a href="general/supervision.html" class="page">Supervision and Monitoring</a></li>
    <li><a href="general/addressing.html" class="page">Actor References, Paths and Addresses</a></li>
    <li><a href="general/remoting.html" class="page">Location Transparency</a></li>
    <li><a href="general/jmm.html" class="page">Pekko and the Java Memory Model</a></li>
    <li><a href="general/message-delivery-reliability.html" class="page">Message Delivery Reliability</a></li>
    <li><a href="general/configuration.html" class="page">Configuration</a></li>
    <li><a href="general/configuration-reference.html" class="page">Default configuration</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="typed/routers.html" class="page">Routers</a></li>
    <li><a href="typed/stash.html" class="page">Stash</a></li>
    <li><a href="typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="typed/testing.html" class="page">Testing</a></li>
    <li><a href="typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="typed/from-classic.html" class="page">Learning Pekko Typed from Classic</a></li>
  </ul></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="remoting.html" class="page">Classic Remoting (Deprecated)</a></li>
    <li><a href="split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="coordination.html" class="page">Coordination</a></li>
    <li><a href="typed/choosing-cluster.html" class="page">Choosing Pekko Cluster</a></li>
  </ul></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a>
  <ul>
    <li><a href="typed/persistence.html" class="page">Event Sourcing</a></li>
    <li><a href="typed/replicated-eventsourcing.html" class="page">Replicated Event Sourcing</a></li>
    <li><a href="typed/cqrs.html" class="page">CQRS</a></li>
    <li><a href="typed/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="typed/persistence-snapshot.html" class="page">Snapshotting</a></li>
    <li><a href="typed/persistence-testing.html" class="page">Testing</a></li>
    <li><a href="typed/persistence-fsm.html" class="page">EventSourced behaviors as finite state machines</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Schema Evolution for Event Sourced Actors</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-plugins.html" class="page">Persistence Plugins</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="typed/replicated-eventsourcing-examples.html" class="page">Replicated Event Sourcing Examples</a></li>
  </ul></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a>
  <ul>
    <li><a href="typed/durable-state/persistence.html" class="page">Durable State</a></li>
    <li><a href="typed/durable-state/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="typed/durable-state/cqrs.html" class="page">CQRS</a></li>
    <li><a href="durable-state/persistence-query.html" class="page">Persistence Query</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="general/stream/stream-design.html" class="page">Design Principles behind Pekko Streams</a></li>
    <li><a href="stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="stream/stream-context.html" class="page">Context Propagation</a></li>
    <li><a href="stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="stream/futures-interop.html" class="page">Futures interop</a></li>
    <li><a href="stream/actor-interop.html" class="page">Actors interop</a></li>
    <li><a href="stream/reactive-streams-interop.html" class="page">Reactive Streams Interop</a></li>
    <li><a href="stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a>
  <ul>
    <li><a href="typed/logging.html" class="page">Logging</a></li>
    <li><a href="common/circuitbreaker.html" class="page">Circuit Breaker</a></li>
    <li><a href="futures.html" class="page">Futures patterns</a></li>
    <li><a href="typed/extending.html" class="page">Extending Pekko</a></li>
  </ul></li>
  <li><a href="common/other-modules.html" class="page">Other Pekko modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a>
  <ul>
    <li><a href="additional/packaging.html" class="page">Packaging</a></li>
    <li><a href="additional/operations.html" class="page">Operating a Cluster</a></li>
    <li><a href="additional/deploying.html" class="page">Deploying</a></li>
    <li><a href="additional/rolling-updates.html" class="page">Rolling Updates</a></li>
  </ul></li>
  <li><a href="project/index.html" class="page">Project Information</a>
  <ul>
    <li><a href="common/binary-compatibility-rules.html" class="page">Binary Compatibility Rules</a></li>
    <li><a href="project/scala3.html" class="page">Scala 3 support</a></li>
    <li><a href="project/downstream-upgrade-strategy.html" class="page">Downstream upgrade strategy</a></li>
    <li><a href="common/may-change.html" class="page">Modules marked &ldquo;May Change&rdquo;</a></li>
    <li><a href="additional/ide.html" class="page">IDE Tips</a></li>
    <li><a href="project/immutable.html" class="page">Immutability using Lombok</a></li>
    <li><a href="additional/osgi.html" class="page">Pekko in OSGi</a></li>
    <li><a href="project/migration-guides.html" class="page">Migration Guides</a></li>
    <li><a href="project/rolling-update.html" class="page">Rolling Updates and Versions</a></li>
    <li><a href="project/issue-tracking.html" class="page">Issue Tracking</a></li>
    <li><a href="project/licenses.html" class="page">Licenses</a></li>
    <li><a href="additional/faq.html" class="page">Frequently Asked Questions</a></li>
    <li><a href="additional/books.html" class="page">Books and Videos</a></li>
    <li><a href="project/examples.html" class="page">Example projects</a></li>
    <li><a href="project/links.html" class="page">Project</a></li>
  </ul></li>
  <li><a href="index-classic.html" class="page">Pekko Classic</a>
  <ul>
    <li><a href="index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="index-cluster.html" class="page">Classic Clustering</a></li>
    <li><a href="index-network.html" class="page">Classic Networking</a></li>
    <li><a href="index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="index.html">Pekko Documentation</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Pekko Documentation
</a>
<div class="version-number">
HEAD+20230118-1331
</div>
</div>
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="typed/guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="typed/guide/introduction.html" class="page">Introduction to Pekko</a></li>
    <li><a href="typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="typed/guide/modules.html" class="page">Overview of Pekko libraries and modules</a></li>
    <li><a href="typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="typed/guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
    <li><a href="typed/guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
  </ul></li>
  <li><a href="general/index.html" class="page">General Concepts</a>
  <ul>
    <li><a href="general/terminology.html" class="page">Terminology, Concepts</a></li>
    <li><a href="general/actor-systems.html" class="page">Actor Systems</a></li>
    <li><a href="general/actors.html" class="page">What is an Actor?</a></li>
    <li><a href="general/supervision.html" class="page">Supervision and Monitoring</a></li>
    <li><a href="general/addressing.html" class="page">Actor References, Paths and Addresses</a></li>
    <li><a href="general/remoting.html" class="page">Location Transparency</a></li>
    <li><a href="general/jmm.html" class="page">Pekko and the Java Memory Model</a></li>
    <li><a href="general/message-delivery-reliability.html" class="page">Message Delivery Reliability</a></li>
    <li><a href="general/configuration.html" class="page">Configuration</a></li>
    <li><a href="general/configuration-reference.html" class="page">Default configuration</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Actors</a>
  <ul>
    <li><a href="typed/actors.html" class="page">Introduction to Actors</a></li>
    <li><a href="typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="typed/routers.html" class="page">Routers</a></li>
    <li><a href="typed/stash.html" class="page">Stash</a></li>
    <li><a href="typed/fsm.html" class="page">Behaviors as finite state machines</a></li>
    <li><a href="coordinated-shutdown.html" class="page">Coordinated Shutdown</a></li>
    <li><a href="typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="typed/mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="typed/testing.html" class="page">Testing</a></li>
    <li><a href="typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="typed/style-guide.html" class="page">Style guide</a></li>
    <li><a href="typed/from-classic.html" class="page">Learning Pekko Typed from Classic</a></li>
  </ul></li>
  <li><a href="typed/index-cluster.html" class="page">Cluster</a>
  <ul>
    <li><a href="typed/cluster.html" class="page">Cluster Usage</a></li>
    <li><a href="typed/cluster-concepts.html" class="page">Cluster Specification</a></li>
    <li><a href="typed/cluster-membership.html" class="page">Cluster Membership Service</a></li>
    <li><a href="typed/failure-detector.html" class="page">Phi Accrual Failure Detector</a></li>
    <li><a href="typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="typed/cluster-sharding-concepts.html" class="page">Cluster Sharding concepts</a></li>
    <li><a href="typed/cluster-sharded-daemon-process.html" class="page">Sharded Daemon Process</a></li>
    <li><a href="typed/cluster-dc.html" class="page">Multi-DC Cluster</a></li>
    <li><a href="typed/distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="typed/reliable-delivery.html" class="page">Reliable delivery</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="serialization-jackson.html" class="page">Serialization with Jackson</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
    <li><a href="remoting-artery.html" class="page">Artery Remoting</a></li>
    <li><a href="remoting.html" class="page">Classic Remoting (Deprecated)</a></li>
    <li><a href="split-brain-resolver.html" class="page">Split Brain Resolver</a></li>
    <li><a href="coordination.html" class="page">Coordination</a></li>
    <li><a href="typed/choosing-cluster.html" class="page">Choosing Pekko Cluster</a></li>
  </ul></li>
  <li><a href="typed/index-persistence.html" class="page">Persistence (Event Sourcing)</a>
  <ul>
    <li><a href="typed/persistence.html" class="page">Event Sourcing</a></li>
    <li><a href="typed/replicated-eventsourcing.html" class="page">Replicated Event Sourcing</a></li>
    <li><a href="typed/cqrs.html" class="page">CQRS</a></li>
    <li><a href="typed/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="typed/persistence-snapshot.html" class="page">Snapshotting</a></li>
    <li><a href="typed/persistence-testing.html" class="page">Testing</a></li>
    <li><a href="typed/persistence-fsm.html" class="page">EventSourced behaviors as finite state machines</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Schema Evolution for Event Sourced Actors</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-plugins.html" class="page">Persistence Plugins</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="typed/replicated-eventsourcing-examples.html" class="page">Replicated Event Sourcing Examples</a></li>
  </ul></li>
  <li><a href="typed/index-persistence-durable-state.html" class="page">Persistence (Durable State)</a>
  <ul>
    <li><a href="typed/durable-state/persistence.html" class="page">Durable State</a></li>
    <li><a href="typed/durable-state/persistence-style.html" class="page">Style Guide</a></li>
    <li><a href="typed/durable-state/cqrs.html" class="page">CQRS</a></li>
    <li><a href="durable-state/persistence-query.html" class="page">Persistence Query</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="general/stream/stream-design.html" class="page">Design Principles behind Pekko Streams</a></li>
    <li><a href="stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="stream/stream-context.html" class="page">Context Propagation</a></li>
    <li><a href="stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="stream/futures-interop.html" class="page">Futures interop</a></li>
    <li><a href="stream/actor-interop.html" class="page">Actors interop</a></li>
    <li><a href="stream/reactive-streams-interop.html" class="page">Reactive Streams Interop</a></li>
    <li><a href="stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a>
  <ul>
    <li><a href="typed/logging.html" class="page">Logging</a></li>
    <li><a href="common/circuitbreaker.html" class="page">Circuit Breaker</a></li>
    <li><a href="futures.html" class="page">Futures patterns</a></li>
    <li><a href="typed/extending.html" class="page">Extending Pekko</a></li>
  </ul></li>
  <li><a href="common/other-modules.html" class="page">Other Pekko modules</a></li>
  <li><a href="additional/deploy.html" class="page">Package, Deploy and Run</a>
  <ul>
    <li><a href="additional/packaging.html" class="page">Packaging</a></li>
    <li><a href="additional/operations.html" class="page">Operating a Cluster</a></li>
    <li><a href="additional/deploying.html" class="page">Deploying</a></li>
    <li><a href="additional/rolling-updates.html" class="page">Rolling Updates</a></li>
  </ul></li>
  <li><a href="project/index.html" class="page">Project Information</a>
  <ul>
    <li><a href="common/binary-compatibility-rules.html" class="page">Binary Compatibility Rules</a></li>
    <li><a href="project/scala3.html" class="page">Scala 3 support</a></li>
    <li><a href="project/downstream-upgrade-strategy.html" class="page">Downstream upgrade strategy</a></li>
    <li><a href="common/may-change.html" class="page">Modules marked &ldquo;May Change&rdquo;</a></li>
    <li><a href="additional/ide.html" class="page">IDE Tips</a></li>
    <li><a href="project/immutable.html" class="page">Immutability using Lombok</a></li>
    <li><a href="additional/osgi.html" class="page">Pekko in OSGi</a></li>
    <li><a href="project/migration-guides.html" class="page">Migration Guides</a></li>
    <li><a href="project/rolling-update.html" class="page">Rolling Updates and Versions</a></li>
    <li><a href="project/issue-tracking.html" class="page">Issue Tracking</a></li>
    <li><a href="project/licenses.html" class="page">Licenses</a></li>
    <li><a href="additional/faq.html" class="page">Frequently Asked Questions</a></li>
    <li><a href="additional/books.html" class="page">Books and Videos</a></li>
    <li><a href="project/examples.html" class="page">Example projects</a></li>
    <li><a href="project/links.html" class="page">Project</a></li>
  </ul></li>
  <li><a href="index-classic.html" class="page">Pekko Classic</a>
  <ul>
    <li><a href="index-actors.html" class="page">Classic Actors</a></li>
    <li><a href="index-cluster.html" class="page">Classic Clustering</a></li>
    <li><a href="index-network.html" class="page">Classic Networking</a></li>
    <li><a href="index-utilities-classic.html" class="page">Classic Utilities</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="index.html">Pekko Documentation</a></li>
  <li><a href="index-classic.html">Pekko Classic</a></li>
  <li><a href="index-actors.html">Classic Actors</a></li>
  <li>Classic Actors</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#classic-actors" name="classic-actors" class="anchor"><span class="anchor-link"></span></a>Classic Actors</h1><div class="callout note "><div class="callout-title">Note</div>
<p>Pekko Classic pertains to the original Actor APIs, which have been improved by more type safe and guided Actor APIs. Pekko Classic is still fully supported and existing applications can continue to use the classic APIs. It is also possible to use the new Actor APIs together with classic actors in the same ActorSystem, see <a href="typed/coexisting.html">coexistence</a>. For new projects we recommend using <a href="typed/actors.html">the new Actor API</a>.</p></div>
<h2><a href="#module-info" name="module-info" class="anchor"><span class="anchor-link"></span></a>Module info</h2>
<p>To use Classic Actors, add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">val PekkoVersion = "HEAD+20230118-1331"
libraryDependencies ++= Seq(
  "org.apache.pekko" %% "pekko-actor" % PekkoVersion,
  "org.apache.pekko" %% "pekko-testkit" % PekkoVersion % Test
)</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;properties&gt;
  &lt;scala.binary.version&gt;2.13&lt;/scala.binary.version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
      &lt;artifactId&gt;pekko-bom_${scala.binary.version}&lt;/artifactId&gt;
      &lt;version&gt;HEAD+20230118-1331&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-actor_${scala.binary.version}&lt;/artifactId&gt;
  &lt;/dependency&gt
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.pekko&lt;/groupId&gt;
    &lt;artifactId&gt;pekko-testkit_${scala.binary.version}&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt
&lt;/dependencies&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("org.apache.pekko:pekko-bom_${versions.ScalaBinary}:HEAD+20230118-1331")

  implementation "org.apache.pekko:pekko-actor_${versions.ScalaBinary}"
  testImplementation "org.apache.pekko:pekko-testkit_${versions.ScalaBinary}"
}</code></pre></dd></dl>
<table class="project-info">
<tr><th colspan="2">Project Info: Pekko Actors (classic)</th></tr>
  <tr><th>Artifact</th><td><div>org.apache.pekko</div>
  <div>pekko-actor</div>
  <div>HEAD+20230118-1331</div>
  <div><a href="project/links.html#snapshots-repository">Snapshots are available</a></div>
  </td></tr>
  <tr><th>JDK versions</th><td><div>Adopt OpenJDK 8</div><div>Adopt OpenJDK 11</div></td></tr>
  <tr><th>Scala versions</th><td>2.13.8, 2.12.16, 3.1.2</td></tr>
  <tr><th>JPMS module name</th><td>pekko.actor</td></tr>
  <tr><th>License</th><td><div><a href="https://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="noopener noreferrer">Apache-2.0</a></div>
  </td></tr>
  
  <tr><th>Home page</th><td><a href="https://akka.io/">https://akka.io/</a></td></tr>
  <tr><th>API documentation</th><td>
  <div><a href="https://doc.akka.io/api/akka/snapshot/akka/actor/index.html" target="_blank" rel="noopener noreferrer">API (Scaladoc)</a></div>
  <div><a href="https://doc.akka.io/japi/akka/snapshot/akka/actor/package-summary.html" target="_blank" rel="noopener noreferrer">API (Javadoc)</a></div>
  </td></tr>
  <tr><th>Forums</th><td>
  <div><a href="https://discuss.akka.io" target="_blank" rel="noopener noreferrer">Lightbend Discuss</a></div>
  <div><a href="https://gitter.im/akka/akka" target="_blank" rel="noopener noreferrer">akka/akka Gitter channel</a></div>
  </td></tr>
  <tr><th>Release notes</th><td><a href="https://akka.io/blog/news-archive.html">akka.io blog</a></td></tr>
  <tr><th>Issues</th><td><a href="https://github.com/akka/akka/issues" target="_blank" rel="noopener noreferrer">Github issues</a></td></tr>
  <tr><th>Sources</th><td><a href="https://github.com/apache/incubator-pekko" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-pekko</a></td></tr>
</table>

<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>

<p>The <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> provides a higher level of abstraction for writing concurrent and distributed systems. It alleviates the developer from having to deal with explicit locking and thread management, making it easier to write correct concurrent and parallel systems. Actors were defined in the 1973 paper by Carl Hewitt but have been popularized by the Erlang language and used for example at Ericsson with great success to build highly concurrent and reliable telecom systems.</p>

<p>The API of Pekko’s Actors is similar to Scala Actors which has borrowed some of its syntax from Erlang.</p>

<h2><a href="#creating-actors" name="creating-actors" class="anchor"><span class="anchor-link"></span></a>Creating Actors</h2>
<div class="callout note "><div class="callout-title">Note</div>
<p>Since Pekko enforces parental supervision every actor is supervised and (potentially) the supervisor of its children, it is advisable to familiarize yourself with <a href="general/actor-systems.html">Actor Systems</a>, <a href="general/supervision.html">supervision</a> and <a href="general/supervision.html#actors-and-exceptions">handling exceptions</a> as well as <a href="general/addressing.html">Actor References, Paths and Addresses</a>.</p></div>
<h3><a href="#defining-an-actor-class" name="defining-an-actor-class" class="anchor"><span class="anchor-link"></span></a>Defining an Actor class</h3><div class="group-scala">
<p>Actors are implemented by extending the <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>Actor</code></a> base trait and implementing the <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#receive:org.apache.pekko.actor.Actor.Receive" title="pekko.actor.Actor"><code>receive</code></a> method. The <code>receive</code> method should define a series of case statements (which has the type <code>PartialFunction[Any, Unit]</code>) that define which messages your Actor can handle, using standard Scala pattern matching, along with the implementation of how the messages should be processed.</p></div><div class="group-java">
<p>Actor classes are implemented by extending the <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html" title="pekko.actor.AbstractActor"><code>AbstractActor</code></a> class and setting the “initial behavior” in the <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#createReceive()" title="pekko.actor.AbstractActor"><code>createReceive</code></a> method.</p>
<p>The <code>createReceive</code> method has no arguments and returns <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.Receive.html" title="pekko.actor.AbstractActor.Receive"><code>AbstractActor.Receive</code></a>. It defines which messages your Actor can handle, along with the implementation of how the messages should be processed. You can build such behavior with a builder named <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/typed/javadsl/ReceiveBuilder.html" title="pekko.actor.typed.javadsl.ReceiveBuilder"><code>ReceiveBuilder</code></a>. This build has a convenient factory in <code>AbstractActor</code> called <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#receiveBuilder()" title="pekko.actor.AbstractActor"><code>receiveBuilder</code></a>.</p></div>
<p>Here is an example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L22-L26" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.Actor
import pekko.actor.Props
import pekko.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case &quot;test&quot; =&gt; log.info(&quot;received test&quot;)
    case _      =&gt; log.info(&quot;received unknown message&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/MyActor.java#L17-L20" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.AbstractActor;
import org.apache.pekko.event.Logging;
import org.apache.pekko.event.LoggingAdapter;

public class MyActor extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            s -&gt; {
              log.info(&quot;Received String message: {}&quot;, s);
            })
        .matchAny(o -&gt; log.info(&quot;received unknown message&quot;))
        .build();
  }
}</code></pre></dd>
</dl>
<p>Please note that the Pekko Actor <span class="group-scala"><code>receive</code></span> message loop is exhaustive, which is different compared to Erlang and the late Scala Actors. This means that you need to provide a pattern match for all messages that it can accept and if you want to be able to handle unknown messages then you need to have a default case as in the example above. Otherwise an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/UnhandledMessage.html" title="org.apache.pekko.actor.UnhandledMessage"><code>UnhandledMessage</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/UnhandledMessage.html" title="org.apache.pekko.actor.UnhandledMessage"><code>UnhandledMessage</code></a></span> will be published to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span>&rsquo;s <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/event/EventStream.html" title="org.apache.pekko.event.EventStream"><code>EventStream</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/event/EventStream.html" title="org.apache.pekko.event.EventStream"><code>EventStream</code></a></span>.</p>
<p>Note further that the return type of the behavior defined above is <a href="http://www.scala-lang.org/api/2.13.8/scala/Unit.html" title="scala.Unit"><code>Unit</code></a>; if the actor shall reply to the received message then this must be done explicitly as explained below.</p>
<p>The result of the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#receive:org.apache.pekko.actor.Actor.Receive" title="pekko.actor.Actor"><code>receive</code></a> method is a partial function object, which is</span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#createReceive()" title="pekko.actor.AbstractActor"><code>createReceive</code></a> method is <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.Receive.html" title="pekko.actor.AbstractActor.Receive"><code>AbstractActor.Receive</code></a> which is a wrapper around partial scala function object. It is</span> stored within the actor as its “initial behavior”, see <a href="actors.html#become-unbecome">Become/Unbecome</a> for further information on changing the behavior of an actor after its construction.</p><div class="group-scala">
<h4><a href="#here-is-another-example-that-you-can-edit-and-run-in-the-browser-" name="here-is-another-example-that-you-can-edit-and-run-in-the-browser-" class="anchor"><span class="anchor-link"></span></a>Here is another example that you can edit and run in the browser:</h4>

        <div data-scalafiddle="true"    data-template="Pekko"   data-minheight="400px"  data-layout="v75" >
          <pre class="prettyprint"><code class="language-scala">import org.apache.pekko.actor.{ Actor, ActorRef, ActorSystem, PoisonPill, Props }
import language.postfixOps
import scala.concurrent.duration._

case object Ping
case object Pong

class Pinger extends Actor {
  var countDown = 100

  def receive = {
    case Pong =>
      println(s"${self.path} received pong, count down $countDown")

      if (countDown > 0) {
        countDown -= 1
        sender() ! Ping
      } else {
        sender() ! PoisonPill
        self ! PoisonPill
      }
  }
}

class Ponger(pinger: ActorRef) extends Actor {
  def receive = {
    case Ping =>
      println(s"${self.path} received ping")
      pinger ! Pong
  }
}

    val system = ActorSystem("pingpong")

    val pinger = system.actorOf(Props[Pinger](), "pinger")

    val ponger = system.actorOf(Props(classOf[Ponger], pinger), "ponger")

    import system.dispatcher
    system.scheduler.scheduleOnce(500 millis) {
      ponger ! Ping
    }
</code></pre>
        </div>
        <script defer="true" src="https://embed.scalafiddle.io/integration.js"></script>
        </div>
<h3><a href="#props" name="props" class="anchor"><span class="anchor-link"></span></a>Props</h3>
<p><span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span> is a configuration class to specify options for the creation of actors, think of it as an immutable and thus freely shareable recipe for creating an actor including associated deployment information (e.g., which dispatcher to use, see more below). Here are some examples of how to create a <code>Props</code> instance.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L420-L424" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.actor.Props

val props1 = Props[MyActor]()
val props2 = Props(new ActorWithArgs(&quot;arg&quot;)) // careful, see below
val props3 = Props(classOf[ActorWithArgs], &quot;arg&quot;) // no support for value class arguments</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L36" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.Props;
Props props1 = Props.create(MyActor.class);
Props props2 =
    Props.create(ActorWithArgs.class, () -&gt; new ActorWithArgs(&quot;arg&quot;)); // careful, see below
Props props3 = Props.create(ActorWithArgs.class, &quot;arg&quot;);</code></pre></dd>
</dl>
<p>The second variant shows how to pass constructor arguments to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span> being created, but it should only be used outside of actors as explained below.</p>
<p>The last line shows a possibility to pass constructor arguments regardless of the context it is being used in. The presence of a matching constructor is verified during construction of the <code>Props</code> object, resulting in an <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html" title="java.lang.IllegalArgumentException"><code>IllegalArgumentException</code></a> if no or multiple matching constructors are found.</p><div class="callout note group-scala"><div class="callout-title">Note</div>
<p>The recommended approach to create the actor <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span> is not supported for cases when the actor constructor takes value classes as arguments.</p></div>
<h4><a href="#dangerous-variants" name="dangerous-variants" class="anchor"><span class="anchor-link"></span></a>Dangerous Variants</h4>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L428-L430" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// NOT RECOMMENDED within another actor:
// encourages to close over enclosing class
val props7 = Props(new MyActor)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L528-L530" target="_blank" title="Go to snippet source">source</a><code class="language-java">// NOT RECOMMENDED within another actor:
// encourages to close over enclosing class
Props props7 = Props.create(ActorWithArgs.class, () -&gt; new ActorWithArgs(&quot;arg&quot;));</code></pre></dd>
</dl>
<p>This method is not recommended being used within another actor because it encourages to close over the enclosing scope, resulting in non-serializable <code>Props</code> and possibly race conditions (breaking the actor encapsulation). On the other hand, using this variant in a <code>Props</code> factory in the actor’s companion object as documented under “Recommended Practices” below is completely fine.</p>
<p>There were two use-cases for these methods: passing constructor arguments to the actor—which is solved by the newly introduced <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Props$.html#apply(clazz:Class[_],args:Any*):org.apache.pekko.actor.Props" title="pekko.actor.Props"><code>Props.apply(clazz, args)</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/Props.html#create(java.lang.Class,java.lang.Object...)" title="pekko.actor.Props"><code>Props.create(clazz, args)</code></a></span> method above or the recommended practice below—and creating actors “on the spot” as anonymous classes. The latter should be solved by making these actors named classes instead (if they are not declared within a top-level <code>object</code> then the enclosing instance’s <code>this</code> reference needs to be passed as the first argument).</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Declaring one actor within another is very dangerous and breaks actor encapsulation. Never pass an actor’s <code>this</code> reference into <code>Props</code>!</p></div><div class="group-scala">
<h4><a href="#edge-cases" name="edge-cases" class="anchor"><span class="anchor-link"></span></a>Edge cases</h4>
<p>There are two edge cases in actor creation with <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Props.html" title="pekko.actor.Props"><code>actor.Props</code></a>:</p>
<ul>
  <li>An actor with <a href="http://www.scala-lang.org/api/2.13.8/scala/AnyVal.html" title="scala.AnyVal"><code>AnyVal</code></a> arguments.</li>
</ul>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/PropsEdgeCaseSpec.scala#L21-L22" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case class MyValueClass(v: Int) extends AnyVal
</code></pre>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/PropsEdgeCaseSpec.scala#L28-L33" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class ValueActor(value: MyValueClass) extends Actor {
  def receive = {
    case multiplier: Long =&gt; sender() ! (value.v * multiplier)
  }
}
val valueClassProp = Props(classOf[ValueActor], MyValueClass(5)) // Unsupported</code></pre>
<ul>
  <li>An actor with default constructor values.</li>
</ul>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/PropsEdgeCaseSpec.scala#L37-L51" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class DefaultValueActor(a: Int, b: Int = 5) extends Actor {
  def receive = {
    case x: Int =&gt; sender() ! ((a + x) * b)
  }
}

val defaultValueProp1 = Props(classOf[DefaultValueActor], 2.0) // Unsupported

class DefaultValueActor2(b: Int = 5) extends Actor {
  def receive = {
    case x: Int =&gt; sender() ! (x * b)
  }
}
val defaultValueProp2 = Props[DefaultValueActor2]() // Unsupported
val defaultValueProp3 = Props(classOf[DefaultValueActor2]) // Unsupported</code></pre>
<p>In both cases, an <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html" title="java.lang.IllegalArgumentException"><code>IllegalArgumentException</code></a> will be thrown stating no matching constructor could be found.</p>
<p>The next section explains the recommended ways to create <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>Actor</code></a> props in a way, which simultaneously safe-guards against these edge cases.</p></div>
<h4><a href="#recommended-practices" name="recommended-practices" class="anchor"><span class="anchor-link"></span></a>Recommended Practices</h4>
<p>It is a good idea to provide <span class="group-scala">factory methods on the companion object of each <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span></span> <span class="group-java">static factory methods for each <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span></span> which help keeping the creation of suitable <code>Props</code> as close to the actor definition as possible. This also avoids the pitfalls associated with using the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Props$.html#apply(clazz:Class[_],args:Any*):org.apache.pekko.actor.Props" title="pekko.actor.Props"><code>Props.apply(...)</code></a> method which takes a by-name argument, since within a companion object</span> <span class="group-java"> <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/Props.html#create(java.lang.Class,java.lang.Object...)" title="pekko.actor.Props"><code>Props.create(...)</code></a> method which takes arguments as constructor parameters, since within static method</span> the given code block will not retain a reference to its enclosing scope:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L82-L109" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object DemoActor {

  /**
   * Create Props for an actor of this type.
   *
   * @param magicNumber The magic number to be passed to this actor’s constructor.
   * @return a Props for creating this actor, which can then be further configured
   *         (e.g. calling `.withDispatcher()` on it)
   */
  def props(magicNumber: Int): Props = Props(new DemoActor(magicNumber))
}

class DemoActor(magicNumber: Int) extends Actor {
  def receive = {
    case x: Int =&gt; sender() ! (x + magicNumber)
  }
}

class SomeOtherActor extends Actor {
  // Props(new DemoActor(42)) would not be safe
  context.actorOf(DemoActor.props(42), &quot;demo&quot;)
  // ...
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L188-L233" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class DemoActor extends AbstractActor {
  /**
   * Create Props for an actor of this type.
   *
   * @param magicNumber The magic number to be passed to this actor’s constructor.
   * @return a Props for creating this actor, which can then be further configured (e.g. calling
   *     `.withDispatcher()` on it)
   */
  static Props props(Integer magicNumber) {
    // You need to specify the actual type of the returned actor
    // since Java 8 lambdas have some runtime type information erased
    return Props.create(DemoActor.class, () -&gt; new DemoActor(magicNumber));
  }

  private final Integer magicNumber;

  public DemoActor(Integer magicNumber) {
    this.magicNumber = magicNumber;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            Integer.class,
            i -&gt; {
              getSender().tell(i + magicNumber, getSelf());
            })
        .build();
  }
}

static class SomeOtherActor extends AbstractActor {
  // Props(new DemoActor(42)) would not be safe
  ActorRef demoActor = getContext().actorOf(DemoActor.props(42), &quot;demo&quot;);
  // ...
}</code></pre></dd>
</dl>
<p>Another good practice is to declare what messages an Actor can receive <span class="group-scala">in the companion object of the Actor</span> <span class="group-java">as close to the actor definition as possible (e.g. as static classes inside the Actor or using other suitable class)</span>, which makes easier to know what it can receive:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L117-L127" target="_blank" title="Go to snippet source">source</a><code class="language-scala">object MyActor {
  case class Greeting(from: String)
  case object Goodbye
}
class MyActor extends Actor with ActorLogging {
  import MyActor._
  def receive = {
    case Greeting(greeter) =&gt; log.info(s&quot;I was greeted by $greeter.&quot;)
    case Goodbye           =&gt; log.info(&quot;Someone said goodbye to me.&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L238-L262" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class DemoMessagesActor extends AbstractLoggingActor {

  public static class Greeting {
    private final String from;

    public Greeting(String from) {
      this.from = from;
    }

    public String getGreeter() {
      return from;
    }
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            Greeting.class,
            g -&gt; {
              log().info(&quot;I was greeted by {}&quot;, g.getGreeter());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<h3><a href="#creating-actors-with-props" name="creating-actors-with-props" class="anchor"><span class="anchor-link"></span></a>Creating Actors with Props</h3>
<p>Actors are created by passing a <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span> instance into the <code>actorOf</code> factory method which is available on <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span> and <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html" title="org.apache.pekko.actor.ActorContext"><code>ActorContext</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html" title="org.apache.pekko.actor.ActorContext"><code>ActorContext</code></a></span>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L436-L440" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.actor.ActorSystem

// ActorSystem is a heavy object: create only one per application
val system = ActorSystem(&quot;mySystem&quot;)
val myActor = system.actorOf(Props[MyActor](), &quot;myactor2&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L39-L40" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.ActorRef;
import org.apache.pekko.actor.ActorSystem;</code></pre></dd>
</dl>
<p>Using the <code>ActorSystem</code> will create top-level actors, supervised by the actor system’s provided guardian actor while using an actor’s context will create a child actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L53-L60" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class FirstActor extends Actor {
  val child = context.actorOf(Props[MyActor](), name = &quot;myChild&quot;)
  def receive = {
    case x =&gt; sender() ! x
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L87-L96" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class FirstActor extends AbstractActor {
  final ActorRef child = getContext().actorOf(Props.create(MyActor.class), &quot;myChild&quot;);

  @Override
  public Receive createReceive() {
    return receiveBuilder().matchAny(x -&gt; getSender().tell(x, getSelf())).build();
  }
}</code></pre></dd>
</dl>
<p>It is recommended to create a hierarchy of children, grand-children and so on such that it fits the logical failure-handling structure of the application, see <a href="general/actor-systems.html">Actor Systems</a>.</p>
<p>The call to <code>actorOf</code> returns an instance of <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span>. This is a handle to the actor instance and the only way to interact with it. The <code>ActorRef</code> is immutable and has a one to one relationship with the Actor it represents. The <code>ActorRef</code> is also serializable and network-aware. This means that you can serialize it, send it over the wire and use it on a remote host, and it will still be representing the same Actor on the original node, across the network.</p>
<p>The name parameter is optional, but you should preferably name your actors, since that is used in log messages and for identifying actors. The name must not be empty or start with <code>$</code>, but it may contain URL encoded characters (eg., <code>%20</code> for a blank space). If the given name is already in use by another child to the same parent an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/InvalidActorNameException.html" title="org.apache.pekko.actor.InvalidActorNameException"><code>InvalidActorNameException</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/InvalidActorNameException.html" title="org.apache.pekko.actor.InvalidActorNameException"><code>InvalidActorNameException</code></a></span> is thrown.</p>
<p>Actors are automatically started asynchronously when created.</p><div class="group-scala">
<h4><a href="#value-classes-as-constructor-arguments" name="value-classes-as-constructor-arguments" class="anchor"><span class="anchor-link"></span></a>Value classes as constructor arguments</h4>
<p>The recommended way to instantiate actor props uses reflection at runtime to determine the correct actor constructor to be invoked and due to technical limitations it is not supported when said constructor takes arguments that are value classes. In these cases you should either unpack the arguments or create the props by calling the constructor manually:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L68-L77" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class Argument(val value: String) extends AnyVal
class ValueClassActor(arg: Argument) extends Actor {
  def receive = { case _ =&gt; () }
}

object ValueClassActor {
  def props1(arg: Argument) = Props(classOf[ValueClassActor], arg) // fails at runtime
  def props2(arg: Argument) = Props(classOf[ValueClassActor], arg.value) // ok
  def props3(arg: Argument) = Props(new ValueClassActor(arg)) // ok
}</code></pre></div>
<h3><a href="#dependency-injection" name="dependency-injection" class="anchor"><span class="anchor-link"></span></a>Dependency Injection</h3>
<p>If your <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span> has a constructor that takes parameters then those need to be part of the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span> as well, as described <a href="actors.html#props">above</a>. But there are cases when a factory method must be used, for example when the actual constructor arguments are determined by a dependency injection framework.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L461-L474" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.actor.IndirectActorProducer

class DependencyInjector(applicationContext: AnyRef, beanName: String) extends IndirectActorProducer {

  override def actorClass = classOf[Actor]
  override def produce() =
    new Echo(beanName)

  def this(beanName: String) = this(&quot;&quot;, beanName)
}

val actorRef = system.actorOf(Props(classOf[DependencyInjector], applicationContext, &quot;hello&quot;), &quot;helloBean&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/DependencyInjectionDocTest.java#L28-L29" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.Actor;
import org.apache.pekko.actor.IndirectActorProducer;
class DependencyInjector implements IndirectActorProducer {
  final Object applicationContext;
  final String beanName;

  public DependencyInjector(Object applicationContext, String beanName) {
    this.applicationContext = applicationContext;
    this.beanName = beanName;
  }

  @Override
  public Class&lt;? extends Actor&gt; actorClass() {
    return TheActor.class;
  }

  @Override
  public TheActor produce() {
    TheActor result;
    result = new TheActor((String) applicationContext);
    return result;
  }
}

  final ActorRef myActor =
      getContext()
          .actorOf(
              Props.create(DependencyInjector.class, applicationContext, &quot;TheActor&quot;), &quot;TheActor&quot;);</code></pre></dd>
</dl><div class="callout warning "><div class="callout-title">Warning</div>
<p>You might be tempted at times to offer an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/IndirectActorProducer.html" title="org.apache.pekko.actor.IndirectActorProducer"><code>IndirectActorProducer</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/IndirectActorProducer.html" title="org.apache.pekko.actor.IndirectActorProducer"><code>IndirectActorProducer</code></a></span> which always returns the same instance, e.g. by using a <span class="group-scala"><code>lazy val</code>.</span> <span class="group-java">static field.</span> This is not supported, as it goes against the meaning of an actor restart, which is described here: <a href="general/supervision.html#supervision-restart">What Restarting Means</a>.</p>
<p>When using a dependency injection framework, actor beans <em>MUST NOT</em> have singleton scope.</p>
<h2><a href="#actor-api" name="actor-api" class="anchor"><span class="anchor-link"></span></a>Actor API</h2>
<p><span class="group-scala">The <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span> trait defines only one abstract method, the above mentioned <code>receive</code>, which implements the behavior of the actor.</span> <span class="group-java">The <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/AbstractActor.html" title="org.apache.pekko.actor.AbstractActor"><code>AbstractActor</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/AbstractActor.html" title="org.apache.pekko.actor.AbstractActor"><code>AbstractActor</code></a></span> class defines a method called <code>createReceive</code>, that is used to set the “initial behavior” of the actor.</span></p>
<p>If the current actor behavior does not match a received message, <code>unhandled</code> is called, which by default publishes an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/UnhandledMessage.html" title="org.apache.pekko.actor.UnhandledMessage"><code>actor.UnhandledMessage(message, sender, recipient)</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/UnhandledMessage.html" title="org.apache.pekko.actor.UnhandledMessage"><code>actor.UnhandledMessage(message, sender, recipient)</code></a></span> on the actor system’s event stream (set configuration item <code>pekko.actor.debug.unhandled</code> to <code>on</code> to have them converted into actual Debug messages).</p>
<p>In addition, it offers:</p>
<ul>
  <li><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#self:org.apache.pekko.actor.ActorRef" title="pekko.actor.Actor"><code>self</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getSelf()" title="pekko.actor.AbstractActor"><code>getSelf()</code></a></span> reference to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span> of the actor</li>
  <li><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#sender():org.apache.pekko.actor.ActorRef" title="pekko.actor.Actor"><code>sender</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getSender()" title="pekko.actor.AbstractActor"><code>getSender()</code></a></span> reference sender Actor of the last received message, typically used as described in  <span class="group-scala"><a href="#actor-reply">Actor.Reply</a></span>  <span class="group-java"><a href="#lambdaactor-reply">LambdaActor.Reply</a></span></li>
  <li><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#supervisorStrategy:org.apache.pekko.actor.SupervisorStrategy" title="pekko.actor.Actor"><code>supervisorStrategy</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#supervisorStrategy()" title="pekko.actor.AbstractActor"><code>supervisorStrategy()</code></a></span> user overridable definition the strategy to use for supervising child actors</li>
</ul>
<p>This strategy is typically declared inside the actor to have access  to the actor’s internal state within the decider function: since failure is  communicated as a message sent to the supervisor and processed like other  messages (albeit outside the normal behavior), all values and variables  within the actor are available, as is the <code>sender</code> reference (which will  be the immediate child reporting the failure; if the original failure  occurred within a distant descendant it is still reported one level up at a  time).</p>
<ul>
  <li><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#context:org.apache.pekko.actor.ActorContext" title="pekko.actor.Actor"><code>context</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getContext()" title="pekko.actor.AbstractActor"><code>getContext()</code></a></span> exposes contextual information for the actor and the current message, such as:
    <ul>
      <li>factory methods to create child actors (<code>actorOf</code>)</li>
      <li>system that the actor belongs to</li>
      <li>parent supervisor</li>
      <li>supervised children</li>
      <li>lifecycle monitoring</li>
      <li>hotswap behavior stack as described in <span class="group-scala"><a href="#actor-hotswap">Actor.HotSwap</a></span> <span class="group-java"><a href="#actor-hotswap">Become/Unbecome</a></span></li>
    </ul>
  </li>
</ul>
<p>@@@ div { .group-scala }</p>
<p>You can import the members in the <code>context</code> to avoid prefixing access with <code>context.</code></p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L339-L345" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class FirstActor extends Actor {
  import context._
  val myActor = actorOf(Props[MyActor](), name = &quot;myactor&quot;)
  def receive = {
    case x =&gt; myActor ! x
  }
}</code></pre></div>
<p>The remaining visible methods are user-overridable life-cycle hooks which are described in the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/actor/src/main/scala/org/apache/pekko/actor/Actor.scala#L599-L645" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def preStart(): Unit = ()

def postStop(): Unit = ()

def preRestart(@unused reason: Throwable, @unused message: Option[Any]): Unit = {
  context.children.foreach { child =&gt;
    context.unwatch(child)
    context.stop(child)
  }
  postStop()
}

def postRestart(@unused reason: Throwable): Unit = {
  preStart()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L278-L292" target="_blank" title="Go to snippet source">source</a><code class="language-java">public void preStart() {}

public void preRestart(Throwable reason, Optional&lt;Object&gt; message) {
  for (ActorRef each : getContext().getChildren()) {
    getContext().unwatch(each);
    getContext().stop(each);
  }
  postStop();
}

public void postRestart(Throwable reason) {
  preStart();
}

public void postStop() {}</code></pre></dd>
</dl>
<p>The implementations shown above are the defaults provided by the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>Actor</code></a> trait.</span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html" title="pekko.actor.AbstractActor"><code>AbstractActor</code></a> class.</span></p>
<h3><a href="#actor-lifecycle" name="actor-lifecycle" class="anchor"><span class="anchor-link"></span></a>Actor Lifecycle</h3>
<p><img src="./images/actor_lifecycle.png" alt="actor_lifecycle.png" /></p>
<p>A path in an actor system represents a &ldquo;place&rdquo; that might be occupied by a living actor. Initially (apart from system initialized actors) a path is empty. When <code>actorOf()</code> is called it assigns an <em>incarnation</em> of the actor described by the passed <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span> to the given path. An actor incarnation is identified by the path <em>and a UID</em>.</p>
<p>It is worth noting about the difference between:</p>
<ul>
  <li>restart</li>
  <li>stop, followed by a re-creation of the actor</li>
</ul>
<p>as explained below.</p>
<p>A restart only swaps the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html" title="org.apache.pekko.actor.Actor"><code>Actor</code></a></span> instance defined by the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Props.html" title="org.apache.pekko.actor.Props"><code>Props</code></a></span> but the incarnation and hence the UID remains the same. As long as the incarnation is the same, you can keep using the same <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span>. Restart is handled by the <a href="fault-tolerance.html#creating-a-supervisor-strategy">Supervision Strategy</a> of actor&rsquo;s parent actor, and there is more discussion about <a href="general/supervision.html#supervision-restart">what restart means</a>.</p>
<p>The lifecycle of an incarnation ends when the actor is stopped. At that point, the appropriate lifecycle events are called and watching actors are notified of the termination. After the incarnation is stopped, the path can be reused again by creating an actor with <code>actorOf()</code>. In this case, the name of the new incarnation will be the same as the previous one, but the UIDs will differ. An actor can be stopped by the actor itself, another actor or the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span> (see <a href="actors.html#stopping-actors">Stopping actors</a>).</p><div class="callout note "><div class="callout-title">Note</div>
<p>It is important to note that Actors do not stop automatically when no longer referenced, every Actor that is created must also explicitly be destroyed. The only simplification is that stopping a parent Actor will also recursively stop all the child Actors that this parent has created.</p></div>
<p>An <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span> always represents an incarnation (path and UID) not just a given path. Therefore, if an actor is stopped, and a new one with the same name is created then an <code>ActorRef</code> of the old incarnation will not point to the new one.</p>
<p><span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html" title="org.apache.pekko.actor.ActorSelection"><code>ActorSelection</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html" title="org.apache.pekko.actor.ActorSelection"><code>ActorSelection</code></a></span> on the other hand points to the path (or multiple paths if wildcards are used) and is completely oblivious to which incarnation is currently occupying it. <code>ActorSelection</code> cannot be watched for this reason. It is possible to resolve the current incarnation&rsquo;s <code>ActorRef</code> living under the path by sending an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Identify.html" title="org.apache.pekko.actor.Identify"><code>Identify</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Identify.html" title="org.apache.pekko.actor.Identify"><code>Identify</code></a></span> message to the <code>ActorSelection</code> which will be replied to with an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorIdentity.html" title="org.apache.pekko.actor.ActorIdentity"><code>ActorIdentity</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorIdentity.html" title="org.apache.pekko.actor.ActorIdentity"><code>ActorIdentity</code></a></span> containing the correct reference (see <a href="actors.html#actorselection">ActorSelection</a>). This can also be done with the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html#resolveOne(timeout:scala.concurrent.duration.FiniteDuration):scala.concurrent.Future[actor.ActorRef]" title="org.apache.pekko.actor.ActorSelection"><code>resolveOne</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html#resolveOne(java.time.Duration)" title="org.apache.pekko.actor.ActorSelection"><code>resolveOne</code></a></span> method of the <code>ActorSelection</code>, which returns a <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span> of the matching <code>ActorRef</code>.</p>
<a id="deathwatch"></a>
<h3><a href="#lifecycle-monitoring-aka-deathwatch" name="lifecycle-monitoring-aka-deathwatch" class="anchor"><span class="anchor-link"></span></a>Lifecycle Monitoring aka DeathWatch</h3>
<p>To be notified when another actor terminates (i.e., stops permanently, not a temporary failure and restart), an actor may register itself for reception of the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span> message dispatched by the other actor upon termination (see <a href="actors.html#stopping-actors">Stopping Actors</a>). This service is provided by the <code>DeathWatch</code> component of the actor system.</p>
<p>Registering a monitor is easy:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L583-L597" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.actor.{ Actor, Props, Terminated }

class WatchActor extends Actor {
  val child = context.actorOf(Props.empty, &quot;child&quot;)
  context.watch(child) // &lt;-- this is the only call needed for registration
  var lastSender = context.system.deadLetters

  def receive = {
    case &quot;kill&quot; =&gt;
      context.stop(child)
      lastSender = sender()
    case Terminated(`child`) =&gt;
      lastSender ! &quot;finished&quot;
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L60" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.Terminated;
static class WatchActor extends AbstractActor {
  private final ActorRef child = getContext().actorOf(Props.empty(), &quot;target&quot;);
  private ActorRef lastSender = system.deadLetters();

  public WatchActor() {
    getContext().watch(child); // &lt;-- this is the only call needed for registration
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            &quot;kill&quot;,
            s -&gt; {
              getContext().stop(child);
              lastSender = getSender();
            })
        .match(
            Terminated.class,
            t -&gt; t.actor().equals(child),
            t -&gt; {
              lastSender.tell(&quot;finished&quot;, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>It should be noted that the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span> message is generated independently of the order in which registration and termination occur. In particular, the watching actor will receive a <code>Terminated</code> message even if the watched actor has already been terminated at the time of registration.</p>
<p>Registering multiple times does not necessarily lead to multiple messages being generated, but there is no guarantee that only exactly one such message is received: if termination of the watched actor has generated and queued the message, and another registration is done before this message has been processed, then a second message will be queued because registering for monitoring of an already terminated actor leads to the immediate generation of the <code>Terminated</code> message.</p>
<p>It is also possible to deregister from watching another actor’s liveliness using <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#unwatch(subject:org.apache.pekko.actor.ActorRef):org.apache.pekko.actor.ActorRef" title="org.apache.pekko.actor.ActorContext"><code>context.unwatch(target)</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#unwatch(org.apache.pekko.actor.ActorRef)" title="org.apache.pekko.actor.ActorContext"><code>context.unwatch(target)</code></a></span>. This works even if the <code>Terminated</code> message has already been enqueued in the mailbox; after calling <code>unwatch</code> no <code>Terminated</code> message for that actor will be processed anymore.</p>
<h3><a href="#start-hook" name="start-hook" class="anchor"><span class="anchor-link"></span></a>Start Hook</h3>
<p>Right after starting the actor, its <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#preStart():Unit" title="pekko.actor.Actor"><code>preStart</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#preStart()" title="pekko.actor.AbstractActor"><code>preStart</code></a></span> method is invoked.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L136-L138" target="_blank" title="Go to snippet source">source</a><code class="language-scala">override def preStart(): Unit = {
  child = context.actorOf(Props[MyActor](), &quot;child&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L306-L309" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public void preStart() {
  target = getContext().actorOf(Props.create(MyActor.class, &quot;target&quot;));
}</code></pre></dd>
</dl>
<p>This method is called when the actor is first created. During restarts, it is called by the default implementation of <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#postRestart(reason:Throwable):Unit" title="pekko.actor.Actor"><code>postRestart</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#postRestart(java.lang.Throwable)" title="pekko.actor.AbstractActor"><code>postRestart</code></a></span>, which means that by overriding that method you can choose whether the initialization code in this method is called only exactly once for this actor or every restart. Initialization code which is part of the actor’s constructor will always be called when an instance of the actor class is created, which happens at every restart.</p>
<a id="restart-hook"></a>
<h3><a href="#restart-hooks" name="restart-hooks" class="anchor"><span class="anchor-link"></span></a>Restart Hooks</h3>
<p>All actors are supervised, i.e., linked to another actor with a fault handling strategy. Actors may be restarted in case an exception is thrown while processing a message (see <a href="general/supervision.html">supervision</a>). This restart involves the hooks mentioned above:</p>
<ol>
  <li>The old actor is informed by calling <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#preRestart(reason:Throwable,message:Option[Any]):Unit" title="pekko.actor.Actor"><code>preRestart</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#preRestart(java.lang.Throwable,java.util.Optional)" title="pekko.actor.AbstractActor"><code>preRestart</code></a></span> with the exception  which caused the restart, and the message which triggered that exception; the  latter may be <code>None</code> if the restart was not caused by processing a  message, e.g. when a supervisor does not trap the exception and is restarted  in turn by its supervisor, or if an actor is restarted due to a sibling’s  failure. If the message is available, then that message’s sender is also  accessible in the usual way (i.e. by calling <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#sender():org.apache.pekko.actor.ActorRef" title="pekko.actor.Actor"><code>sender</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getSender()" title="pekko.actor.AbstractActor"><code>getSender()</code></a></span>).  This method is the best place for cleaning up, preparing hand-over to the  fresh actor instance, etc. By default, it stops all children and calls  <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#postStop():Unit" title="pekko.actor.Actor"><code>postStop</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#postStop()" title="pekko.actor.AbstractActor"><code>postStop</code></a></span>.</li>
  <li>The initial factory from the <code>actorOf</code> call is used  to produce the fresh instance.</li>
  <li>The new actor’s <code>postRestart</code> method is invoked with the exception  which caused the restart. By default the <code>preStart</code>  is called, just as in the normal start-up case.</li>
</ol>
<p>An actor restart replaces only the actual actor object; the contents of the mailbox are unaffected by the restart, so the processing of messages will resume after the <code>postRestart</code> hook returns. The message that triggered the exception will not be received again. Any message sent to an actor while it is being restarted will be queued to its mailbox as usual.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Be aware that the ordering of failure notifications relative to user messages is not deterministic. In particular, a parent might restart its child before it has processed the last messages sent by the child before the failure. See <a href="general/message-delivery-reliability.html#message-ordering">Discussion: Message Ordering</a> for details.</p></div>
<h3><a href="#stop-hook" name="stop-hook" class="anchor"><span class="anchor-link"></span></a>Stop Hook</h3>
<p>After stopping an actor, its <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#postStop():Unit" title="pekko.actor.Actor"><code>postStop</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#postStop()" title="pekko.actor.AbstractActor"><code>postStop</code></a></span> hook is called, which may be used e.g. for deregistering this actor from other services. This hook is guaranteed to run after message queuing has been disabled for this actor, i.e. messages sent to a stopped actor will be redirected to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html#deadLetters:org.apache.pekko.actor.ActorRef" title="org.apache.pekko.actor.ActorSystem"><code>deadLetters</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html#deadLetters()" title="org.apache.pekko.actor.ActorSystem"><code>deadLetters</code></a></span> of the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span>.</p>
<a id="actorselection"></a>
<h2><a href="#identifying-actors-via-actor-selection" name="identifying-actors-via-actor-selection" class="anchor"><span class="anchor-link"></span></a>Identifying Actors via Actor Selection</h2>
<p>As described in <a href="general/addressing.html">Actor References, Paths and Addresses</a>, each actor has a unique logical path, which is obtained by following the chain of actors from child to parent until reaching the root of the actor system, and it has a physical path, which may differ if the supervision chain includes any remote supervisors. These paths are used by the system to look up actors, e.g. when a remote message is received and the recipient is searched, but they are also useful more directly: actors may look up other actors by specifying absolute or relative paths—logical or physical—and receive back an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html" title="org.apache.pekko.actor.ActorSelection"><code>ActorSelection</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html" title="org.apache.pekko.actor.ActorSelection"><code>ActorSelection</code></a></span> with the result:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L625-L628" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// will look up this absolute path
context.actorSelection(&quot;/user/serviceA/aggregator&quot;)
// will look up sibling beneath same supervisor
context.actorSelection(&quot;../joe&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L332-L335" target="_blank" title="Go to snippet source">source</a><code class="language-java">// will look up this absolute path
getContext().actorSelection(&quot;/user/serviceA/actor&quot;);
// will look up sibling beneath same supervisor
getContext().actorSelection(&quot;../joe&quot;);</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>It is always preferable to communicate with other Actors using their ActorRef instead of relying upon ActorSelection. Exceptions are</p>
<ul>
  <li>sending messages using the <a href="persistence.html#at-least-once-delivery">At-Least-Once Delivery</a> facility</li>
  <li>initiating the first contact with a remote system</li>
</ul>
<p>In all other cases, ActorRefs can be provided during Actor creation or initialization, passing them from parent to child or introducing Actors by sending their ActorRefs to other Actors within messages.</p></div>
<p>The supplied path is parsed as a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URI.html" title="java.net.URI"><code>java.net.URI</code></a>, which means that it is split on <code>/</code> into path elements. If the path starts with <code>/</code>, it is absolute and the look-up starts at the root guardian (which is the parent of <code>&quot;/user&quot;</code>); otherwise it starts at the current actor. If a path element equals <code>..</code>, the look-up will take a step “up” towards the supervisor of the currently traversed actor, otherwise it will step “down” to the named child. It should be noted that the <code>..</code> in actor paths here always means the logical structure, i.e. the supervisor.</p>
<p>The path elements of an actor selection may contain wildcard patterns allowing for broadcasting of messages to that section:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L631-L634" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// will look all children to serviceB with names starting with worker
context.actorSelection(&quot;/user/serviceB/worker*&quot;)
// will look up all siblings beneath same supervisor
context.actorSelection(&quot;../*&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L339-L342" target="_blank" title="Go to snippet source">source</a><code class="language-java">// will look all children to serviceB with names starting with worker
getContext().actorSelection(&quot;/user/serviceB/worker*&quot;);
// will look up all siblings beneath same supervisor
getContext().actorSelection(&quot;../*&quot;);</code></pre></dd>
</dl>
<p>Messages can be sent via the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html" title="org.apache.pekko.actor.ActorSelection"><code>ActorSelection</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html" title="org.apache.pekko.actor.ActorSelection"><code>ActorSelection</code></a></span> and the path of the <code>ActorSelection</code> is looked up when delivering each message. If the selection does not match any actors the message will be dropped.</p>
<p>To acquire an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span> for an <code>ActorSelection</code> you need to send a message to the selection and use the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#sender():org.apache.pekko.actor.ActorRef" title="pekko.actor.Actor"><code>sender</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getSender()" title="pekko.actor.AbstractActor"><code>getSender()</code></a></span>) reference of the reply from the actor. There is a built-in <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Identify.html" title="org.apache.pekko.actor.Identify"><code>Identify</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Identify.html" title="org.apache.pekko.actor.Identify"><code>Identify</code></a></span> message that all Actors will understand and automatically reply to with an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorIdentity.html" title="org.apache.pekko.actor.ActorIdentity"><code>ActorIdentity</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorIdentity.html" title="org.apache.pekko.actor.ActorIdentity"><code>ActorIdentity</code></a></span> message containing the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span>. This message is handled specially by the actors which are traversed in the sense that if a concrete name lookup fails (i.e. a non-wildcard path element does not correspond to a live actor) then a negative result is generated. Please note that this does not mean that delivery of that reply is guaranteed, it still is a normal message.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L644-L661" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.actor.{ Actor, ActorIdentity, Identify, Props, Terminated }

class Follower extends Actor {
  val identifyId = 1
  context.actorSelection(&quot;/user/another&quot;) ! Identify(identifyId)

  def receive = {
    case ActorIdentity(`identifyId`, Some(ref)) =&gt;
      context.watch(ref)
      context.become(active(ref))
    case ActorIdentity(`identifyId`, None) =&gt; context.stop(self)

  }

  def active(another: ActorRef): Actor.Receive = {
    case Terminated(`another`) =&gt; context.stop(self)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L43-L45" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.ActorIdentity;
import org.apache.pekko.actor.ActorSelection;
import org.apache.pekko.actor.Identify;
static class Follower extends AbstractActor {
  final Integer identifyId = 1;

  public Follower() {
    ActorSelection selection = getContext().actorSelection(&quot;/user/another&quot;);
    selection.tell(new Identify(identifyId), getSelf());
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            ActorIdentity.class,
            id -&gt; id.getActorRef().isPresent(),
            id -&gt; {
              ActorRef ref = id.getActorRef().get();
              getContext().watch(ref);
              getContext().become(active(ref));
            })
        .match(
            ActorIdentity.class,
            id -&gt; !id.getActorRef().isPresent(),
            id -&gt; {
              getContext().stop(getSelf());
            })
        .build();
  }

  final AbstractActor.Receive active(final ActorRef another) {
    return receiveBuilder()
        .match(
            Terminated.class, t -&gt; t.actor().equals(another), t -&gt; getContext().stop(getSelf()))
        .build();
  }
}</code></pre></dd>
</dl>
<p>You can also acquire an <code>ActorRef</code> for an <code>ActorSelection</code> with the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html#resolveOne(timeout:scala.concurrent.duration.FiniteDuration):scala.concurrent.Future[actor.ActorRef]" title="org.apache.pekko.actor.ActorSelection"><code>resolveOne</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSelection.html#resolveOne(java.time.Duration)" title="org.apache.pekko.actor.ActorSelection"><code>resolveOne</code></a></span> method of the <code>ActorSelection</code>. It returns a <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span> of the matching <code>ActorRef</code> if such an actor exists. It is completed with failure <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorNotFound.html" title="org.apache.pekko.actor.ActorNotFound"><code>ActorNotFound</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorNotFound.html" title="org.apache.pekko.actor.ActorNotFound"><code>ActorNotFound</code></a></span> if no such actor exists or the identification didn&rsquo;t complete within the supplied <code>timeout</code>.</p>
<p>Remote actor addresses may also be looked up, if <a href="remoting.html">remoting</a> is enabled:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L637" target="_blank" title="Go to snippet source">source</a><code class="language-scala">context.actorSelection(&quot;pekko://app@otherhost:1234/user/serviceB&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L346" target="_blank" title="Go to snippet source">source</a><code class="language-java">getContext().actorSelection(&quot;pekko://app@otherhost:1234/user/serviceB&quot;);</code></pre></dd>
</dl>
<p>An example demonstrating actor look-up is given in <a href="remoting-artery.html#looking-up-remote-actors">Remoting Sample</a>.</p>
<h2><a href="#messages-and-immutability" name="messages-and-immutability" class="anchor"><span class="anchor-link"></span></a>Messages and immutability</h2><div class="callout warning "><div class="callout-title">IMPORTANT</div>
<p>Messages can be any kind of object but have to be immutable. <span class="group-scala">Scala</span> <span class="group-java">Pekko</span> can’t enforce immutability (yet) so this has to be by convention. <span class="group-scala">Primitives like String, Int, Boolean are always immutable. Apart from these the recommended approach is to use Scala case classes that are immutable (if you don’t explicitly expose the state) and works great with pattern matching at the receiver side.</span></p></div>
<p>Here is an <span class="group-scala">example:</span> <span class="group-java">example of an immutable message:</span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L325-L328" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case class User(name: String)

// define the case class
case class Register(user: User)
val user = User(&quot;Mike&quot;)
// create a new case class message
val message = Register(user)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ImmutableMessage.java#L21-L37" target="_blank" title="Go to snippet source">source</a><code class="language-java">public class ImmutableMessage {
  private final int sequenceNumber;
  private final List&lt;String&gt; values;

  public ImmutableMessage(int sequenceNumber, List&lt;String&gt; values) {
    this.sequenceNumber = sequenceNumber;
    this.values = Collections.unmodifiableList(new ArrayList&lt;String&gt;(values));
  }

  public int getSequenceNumber() {
    return sequenceNumber;
  }

  public List&lt;String&gt; getValues() {
    return values;
  }
}</code></pre></dd>
</dl>
<h2><a href="#send-messages" name="send-messages" class="anchor"><span class="anchor-link"></span></a>Send messages</h2>
<p>Messages are sent to an Actor through one of the following methods.</p>
<ul>
  <li><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/ActorRef.html#!(message:Any)(implicitsender:org.apache.pekko.actor.ActorRef):Unit" title="pekko.actor.ActorRef"><code>!</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/ActorRef.html#tell(java.lang.Object,org.apache.pekko.actor.ActorRef)" title="pekko.actor.ActorRef"><code>tell</code></a></span> means “fire-and-forget”, e.g. send a message asynchronously and return  immediately. <span class="group-scala">Also known as <code>tell</code>.</span></li>
  <li><span class="group-scala"><code>?</code></span> <span class="group-java"><code>ask</code></span> sends a message asynchronously and returns a <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span>  representing a possible reply. <span class="group-scala">Also known as <code>ask</code>.</span></li>
</ul>
<p>Message ordering is guaranteed on a per-sender basis.</p><div class="callout note "><div class="callout-title">Note</div>
<p>There are performance implications of using <code>ask</code> since something needs to keep track of when it times out, there needs to be something that bridges a <code>Promise</code> into an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span> and it also needs to be reachable through remoting. So always prefer <code>tell</code> for performance, and only <code>ask</code> if you must.</p></div><div class="group-java">
<p>In all these methods you have the option of passing along your own <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span>. Make it a practice of doing so because it will allow the receiver actors to be able to respond to your message since the sender reference is sent along with the message.</p></div>
<a id="actors-tell-sender"></a>
<h3><a href="#tell-fire-forget" name="tell-fire-forget" class="anchor"><span class="anchor-link"></span></a>Tell: Fire-forget</h3>
<p>This is the preferred way of sending messages. No blocking waiting for a message. This gives the best concurrency and scalability characteristics.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L485" target="_blank" title="Go to snippet source">source</a><code class="language-scala">actorRef ! message</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L317-L318" target="_blank" title="Go to snippet source">source</a><code class="language-java">// don’t forget to think about who is the sender (2nd argument)
target.tell(message, getSelf());</code></pre></dd>
</dl><div class="group-scala">
<p>If invoked from within an Actor, then the sending actor reference will be implicitly passed along with the message and available to the receiving Actor in its <code>sender(): ActorRef</code> member method. The target actor can use this to reply to the original sender, by using <code>sender() ! replyMsg</code>.</p>
<p>If invoked from an instance that is <strong>not</strong> an Actor the sender will be <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/ActorSystem.html#deadLetters:org.apache.pekko.actor.ActorRef" title="pekko.actor.ActorSystem"><code>deadLetters</code></a> actor reference by default.</p></div><div class="group-java">
<p>The sender reference is passed along with the message and available within the receiving actor via its <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getSender()" title="pekko.actor.AbstractActor"><code>getSender()</code></a> method while processing this message. Inside of an actor it is usually <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getSelf()" title="pekko.actor.AbstractActor"><code>getSelf()</code></a> who shall be the sender, but there can be cases where replies shall be routed to some other actor—e.g. the parent—in which the second argument to <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/ActorRef.html#tell(java.lang.Object,org.apache.pekko.actor.ActorRef)" title="pekko.actor.ActorRef"><code>tell</code></a> would be a different one. Outside of an actor and if no reply is needed the second argument can be <code>null</code>; if a reply is needed outside of an actor you can use the ask-pattern described next.</p></div>
<a id="actors-ask"></a>
<h3><a href="#ask-send-and-receive-future" name="ask-send-and-receive-future" class="anchor"><span class="anchor-link"></span></a>Ask: Send-And-Receive-Future</h3>
<p>The <code>ask</code> pattern involves actors as well as futures, hence it is offered as a use pattern rather than a method on <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L692-L707" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.pattern.{ ask, pipe }
import system.dispatcher // The ExecutionContext that will be used
final case class Result(x: Int, s: String, d: Double)
case object Request

implicit val timeout: Timeout = 5.seconds // needed for `?` below

val f: Future[Result] =
  for {
    x &lt;- ask(actorA, Request).mapTo[Int] // call pattern directly
    s &lt;- actorB.ask(Request).mapTo[String] // call by implicit conversion
    d &lt;- (actorC ? Request).mapTo[Double] // call by symbolic name
  } yield Result(x, s, d)

f.pipeTo(actorD) // .. or ..
pipe(f) to actorD</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L48-L51" target="_blank" title="Go to snippet source">source</a><code class="language-java">import static org.apache.pekko.pattern.Patterns.ask;
import static org.apache.pekko.pattern.Patterns.pipe;

import java.util.concurrent.CompletableFuture;
final Duration t = Duration.ofSeconds(5);

// using 1000ms timeout
CompletableFuture&lt;Object&gt; future1 =
    ask(actorA, &quot;request&quot;, Duration.ofMillis(1000)).toCompletableFuture();

// using timeout from above
CompletableFuture&lt;Object&gt; future2 = ask(actorB, &quot;another request&quot;, t).toCompletableFuture();

CompletableFuture&lt;Result&gt; transformed =
    future1.thenCombine(future2, (x, s) -&gt; new Result((String) x, (String) s));

pipe(transformed, system.dispatcher()).to(actorC);</code></pre></dd>
</dl>
<p>This example demonstrates <code>ask</code> together with the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/pattern/PipeToSupport$PipeableFuture.html#pipeTo(recipient:org.apache.pekko.actor.ActorRef)(implicitsender:org.apache.pekko.actor.ActorRef):scala.concurrent.Future[T]" title="pekko.pattern.PipeToSupport$PipeableFuture"><code>pipeTo</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/pattern/PipeToSupport.PipeableCompletionStage.html#pipeTo(org.apache.pekko.actor.ActorRef,org.apache.pekko.actor.ActorRef)" title="pekko.pattern.PipeToSupport.PipeableCompletionStage"><code>pipeTo</code></a></span> pattern on futures, because this is likely to be a common combination. Please note that all of the above is completely non-blocking and asynchronous: <code>ask</code> produces a <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span>, <span class="group-scala">three</span> <span class="group-java">two</span> of which are composed into a new future using the <span class="group-scala">for-comprehension and then <code>pipeTo</code> installs an <code>onComplete</code>-handler on the <code>Future</code> to affect</span> <span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletableFuture.html#allOf(java.util.concurrent.CompletableFuture...)" title="java.util.concurrent.CompletableFuture"><code>CompletableFuture.allOf</code></a> and <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html#thenApply(java.util.function.Function)" title="java.util.concurrent.CompletionStage"><code>thenApply</code></a> methods and then <code>pipe</code> installs a handler on the <code>CompletionStage</code> to effect</span> the submission of the aggregated <code>Result</code> to another actor.</p>
<p>Using <code>ask</code> will send a message to the receiving Actor as with <code>tell</code>, and the receiving actor must reply with <span class="group-scala"><code>sender() ! reply</code></span> <span class="group-java"><code>getSender().tell(reply, getSelf())</code> </span> in order to complete the returned <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> with a value. The <code>ask</code> operation involves creating an internal actor for handling this reply, which needs to have a timeout after which it is destroyed in order not to leak resources; see more below.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>To complete the <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span> with an exception you need to send an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Status$$Failure.html" title="org.apache.pekko.actor.Status.Failure"><code>Status.Failure</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Status$$Failure.html" title="org.apache.pekko.actor.Status.Failure"><code>Status.Failure</code></a></span> message to the sender. This is <em>not done automatically</em> when an actor throws an exception while processing a message.</p>
<p><span class="group-scala">Please note that Scala&rsquo;s <code>Try</code> sub types <a href="http://www.scala-lang.org/api/2.13.8/scala/util/Failure.html" title="scala.util.Failure"><code>scala.util.Failure</code></a> and <a href="http://www.scala-lang.org/api/2.13.8/scala/util/Success.html" title="scala.util.Success"><code>scala.util.Success</code></a> are not treated especially, and would complete the ask <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> with the given value - only the <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Status$.html" title="pekko.actor.Status"><code>actor.Status</code></a> messages are treated specially by the ask pattern.</span></p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L154-L161" target="_blank" title="Go to snippet source">source</a><code class="language-scala">try {
  val result = operation()
  sender() ! result
} catch {
  case e: Exception =&gt;
    sender() ! pekko.actor.Status.Failure(e)
    throw e
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L359-L365" target="_blank" title="Go to snippet source">source</a><code class="language-java">try {
  String result = operation();
  getSender().tell(result, getSelf());
} catch (Exception e) {
  getSender().tell(new org.apache.pekko.actor.Status.Failure(e), getSelf());
  throw e;
}</code></pre></dd>
</dl>
<p>If the actor does not complete the <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html" title="scala.concurrent.Future"><code>Future</code></a></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html" title="java.util.concurrent.CompletionStage"><code>CompletionStage</code></a></span>, it will expire after the timeout period, <span class="group-scala">completing it with an <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/pattern/AskTimeoutException.html" title="pekko.pattern.AskTimeoutException"><code>AskTimeoutException</code></a>. The timeout is taken from one of the following locations in order of precedence:</span> <span class="group-java">specified as parameter to the <code>ask</code> method; this will complete the <code>CompletionStage</code> with an <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/pattern/AskTimeoutException.html" title="pekko.pattern.AskTimeoutException"><code>AskTimeoutException</code></a>.</span></p><div class="group-scala">
<ol>
  <li>
    <p>explicitly given timeout as in:</p>
    <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L509-L511" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.concurrent.duration._
import org.apache.pekko.pattern.ask
val future = myActor.ask(&quot;hello&quot;)(5 seconds)</code></pre>
  </li>
  <li>
    <p>implicit argument of type <code>org.apache.pekko.util.Timeout</code>, e.g.</p>
    <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L495-L500" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.concurrent.duration._
import org.apache.pekko
import pekko.util.Timeout
import pekko.pattern.ask
implicit val timeout: Timeout = 5.seconds
val future = myActor ? &quot;hello&quot;</code></pre>
  </li>
</ol></div>
<p>The <span class="group-scala"><a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#onComplete[U](f:scala.util.Try[T]=%3EU)(implicitexecutor:scala.concurrent.ExecutionContext):Unit" title="scala.concurrent.Future"><code>onComplete</code></a> method of the <code>Future</code></span><span class="group-java"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html#thenRun(java.lang.Runnable)" title="java.util.concurrent.CompletionStage"><code>thenRun</code></a> method of the <code>CompletionStage</code></span> can be used to register a callback to get a notification when the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> completes, giving you a way to avoid blocking.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>When using future callbacks, <span class="group-scala">such as <a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#onComplete[U](f:scala.util.Try[T]=%3EU)(implicitexecutor:scala.concurrent.ExecutionContext):Unit" title="scala.concurrent.Future"><code>onComplete</code></a>, or <a href="http://www.scala-lang.org/api/2.13.8/scala/concurrent/Future.html#map[S](f:T=%3ES)(implicitexecutor:scala.concurrent.ExecutionContext):scala.concurrent.Future[S]" title="scala.concurrent.Future"><code>map</code></a></span><span class="group-scala">such as <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html#thenRun(java.lang.Runnable)" title="java.util.concurrent.CompletionStage"><code>thenRun</code></a>, or <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html#thenApply(java.util.function.Function)" title="java.util.concurrent.CompletionStage"><code>thenApply</code></a></span> inside actors you need to carefully avoid closing over the containing actor’s reference, i.e. do not call methods or access mutable state on the enclosing actor from within the callback. This would break the actor encapsulation and may introduce synchronization bugs and race conditions because the callback will be scheduled concurrently to the enclosing actor. Unfortunately, there is not yet a way to detect these illegal accesses at compile time. See also: <a href="general/jmm.html#jmm-shared-state">Actors and shared mutable state</a></p></div>
<h3><a href="#forward-message" name="forward-message" class="anchor"><span class="anchor-link"></span></a>Forward message</h3>
<p>You can forward a message from one actor to another. This means that the original sender address/reference is maintained even though the message is going through a &lsquo;mediator&rsquo;. This can be useful when writing actors that work as routers, load-balancers, replicators etc.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L452" target="_blank" title="Go to snippet source">source</a><code class="language-scala">target.forward(message)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L322" target="_blank" title="Go to snippet source">source</a><code class="language-java">target.forward(result, getContext());</code></pre></dd>
</dl>
<h2><a href="#receive-messages" name="receive-messages" class="anchor"><span class="anchor-link"></span></a>Receive messages</h2>
<p>An Actor has to <span class="group-scala">implement the <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#receive:org.apache.pekko.actor.Actor.Receive" title="pekko.actor.Actor"><code>receive</code></a> method to receive messages:</span> <span class="group-java">define its initial receive behavior by implementing the <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#createReceive()" title="pekko.actor.AbstractActor"><code>createReceive</code></a> method in the <code>AbstractActor</code>:</span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/actor/src/main/scala/org/apache/pekko/actor/Actor.scala#L390-L533" target="_blank" title="Go to snippet source">source</a><code class="language-scala">type Receive = PartialFunction[Any, Unit]

def receive: Actor.Receive</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L101-L104" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public Receive createReceive() {
  return receiveBuilder().match(String.class, s -&gt; System.out.println(s.toLowerCase())).build();
}</code></pre></dd>
</dl><div class="group-scala">
<p>This method returns a <code>PartialFunction</code>, e.g. a ‘match/case’ clause in which the message can be matched against the different case clauses using Scala pattern matching. Here is an example:</p></div><div class="group-java">
<p>The return type is <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.Receive.html" title="pekko.actor.AbstractActor.Receive"><code>AbstractActor.Receive</code></a> that defines which messages your Actor can handle, along with the implementation of how the messages should be processed. You can build such behavior with a builder named <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#receiveBuilder()" title="pekko.actor.AbstractActor"><code>receiveBuilder</code></a>. Here is an example:</p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L22-L26" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko
import pekko.actor.Actor
import pekko.actor.Props
import pekko.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case &quot;test&quot; =&gt; log.info(&quot;received test&quot;)
    case _      =&gt; log.info(&quot;received unknown message&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/MyActor.java#L17-L20" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.AbstractActor;
import org.apache.pekko.event.Logging;
import org.apache.pekko.event.LoggingAdapter;

public class MyActor extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            s -&gt; {
              log.info(&quot;Received String message: {}&quot;, s);
            })
        .matchAny(o -&gt; log.info(&quot;received unknown message&quot;))
        .build();
  }
}</code></pre></dd>
</dl><div class="group-java">
<p>In case you want to provide many <code>match</code> cases but want to avoid creating a long call trail, you can split the creation of the builder into multiple statements as in the example:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/GraduallyBuiltActor.java#L17-L21" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.AbstractActor;
import org.apache.pekko.event.Logging;
import org.apache.pekko.event.LoggingAdapter;
import org.apache.pekko.japi.pf.ReceiveBuilder;

public class GraduallyBuiltActor extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  @Override
  public Receive createReceive() {
    ReceiveBuilder builder = ReceiveBuilder.create();

    builder.match(
        String.class,
        s -&gt; {
          log.info(&quot;Received String message: {}&quot;, s);
        });

    // do some other stuff in between

    builder.matchAny(o -&gt; log.info(&quot;received unknown message&quot;));

    return builder.build();
  }
}</code></pre>
<p>Using small methods is a good practice, also in actors. It&rsquo;s recommended to delegate the actual work of the message processing to methods instead of defining a huge <code>ReceiveBuilder</code> with lots of code in each lambda. A well-structured actor can look like this:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L110-L138" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class WellStructuredActor extends AbstractActor {

  public static class Msg1 {}

  public static class Msg2 {}

  public static class Msg3 {}

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(Msg1.class, this::receiveMsg1)
        .match(Msg2.class, this::receiveMsg2)
        .match(Msg3.class, this::receiveMsg3)
        .build();
  }

  private void receiveMsg1(Msg1 msg) {
    // actual work
  }

  private void receiveMsg2(Msg2 msg) {
    // actual work
  }

  private void receiveMsg3(Msg3 msg) {
    // actual work
  }
}</code></pre>
<p>That has benefits such as:</p>
<ul>
  <li>easier to see what kind of messages the actor can handle</li>
  <li>readable stack traces in case of exceptions</li>
  <li>works better with performance profiling tools</li>
  <li>Java HotSpot has a better opportunity for making optimizations</li>
</ul>
<p>The <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.Receive.html" title="pekko.actor.AbstractActor.Receive"><code>Receive</code></a> can be implemented in other ways than using the <code>ReceiveBuilder</code> since in the end, it is just a wrapper around a Scala <code>PartialFunction</code>. In Java, you can implement <code>PartialFunction</code> by extending <code>AbstractPartialFunction</code>. For example, one could implement an adapter to <a href="https://docs.vavr.io/#_pattern_matching">Vavr Pattern Matching DSL</a>. See the <a href="https://github.com/apache/incubator-pekko-samples/tree/2.5/akka-sample-vavr">Pekko Vavr sample project</a> for more details.</p>
<p>If the validation of the <code>ReceiveBuilder</code> match logic turns out to be a bottleneck for some of your actors you can consider implementing it at a lower level by extending <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/UntypedAbstractActor.html" title="pekko.actor.UntypedAbstractActor"><code>UntypedAbstractActor</code></a> instead of <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html" title="pekko.actor.AbstractActor"><code>AbstractActor</code></a>. The partial functions created by the <code>ReceiveBuilder</code> consist of multiple lambda expressions for every match statement, where each lambda is referencing the code to be run. This is something that the JVM can have problems optimizing and the resulting code might not be as performant as the untyped version. When extending <code>UntypedAbstractActor</code> each message is received as an untyped <code>Object</code> and you have to inspect and cast it to the actual message type in other ways, like this:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L143-L170" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class OptimizedActor extends UntypedAbstractActor {

  public static class Msg1 {}

  public static class Msg2 {}

  public static class Msg3 {}

  @Override
  public void onReceive(Object msg) throws Exception {
    if (msg instanceof Msg1) receiveMsg1((Msg1) msg);
    else if (msg instanceof Msg2) receiveMsg2((Msg2) msg);
    else if (msg instanceof Msg3) receiveMsg3((Msg3) msg);
    else unhandled(msg);
  }

  private void receiveMsg1(Msg1 msg) {
    // actual work
  }

  private void receiveMsg2(Msg2 msg) {
    // actual work
  }

  private void receiveMsg3(Msg3 msg) {
    // actual work
  }
}</code></pre></div>
<a id="actor-reply"></a>
<h2><a href="#reply-to-messages" name="reply-to-messages" class="anchor"><span class="anchor-link"></span></a>Reply to messages</h2>
<p>If you want to have a handle for replying to a message, you can use <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#sender():org.apache.pekko.actor.ActorRef" title="pekko.actor.Actor"><code>sender</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#getSender()" title="pekko.actor.AbstractActor"><code>getSender()</code></a></span>, which gives you an ActorRef. You can reply by sending to that ActorRef with <span class="group-scala"><code>sender() ! replyMsg</code>.</span> <span class="group-java"><code>getSender().tell(replyMsg, getSelf())</code>.</span> You can also store the ActorRef for replying later, or passing it on to other actors. If there is no sender (a message was sent without an actor or future context) then the sender defaults to a &lsquo;dead-letter&rsquo; actor ref.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L720" target="_blank" title="Go to snippet source">source</a><code class="language-scala">sender() ! x // replies will go to this actor</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/MyActor.java#L36" target="_blank" title="Go to snippet source">source</a><code class="language-java">getSender().tell(s, getSelf());</code></pre></dd>
</dl>
<h2><a href="#receive-timeout" name="receive-timeout" class="anchor"><span class="anchor-link"></span></a>Receive timeout</h2>
<p>The <span class="group-java"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/ActorContext.html#setReceiveTimeout(timeout:scala.concurrent.duration.Duration):Unit" title="pekko.actor.ActorContext"><code>ActorContext.setReceiveTimeout</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.ActorContext.html#setReceiveTimeout(java.time.Duration)" title="pekko.actor.AbstractActor.ActorContext"><code>ActorContext.setReceiveTimeout</code></a></span> defines the inactivity timeout after which the sending of a <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ReceiveTimeout.html" title="org.apache.pekko.actor.ReceiveTimeout"><code>ReceiveTimeout</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ReceiveTimeout.html" title="org.apache.pekko.actor.ReceiveTimeout"><code>ReceiveTimeout</code></a></span> message is triggered. When specified, the receive function should be able to handle an <code>org.apache.pekko.actor.ReceiveTimeout</code> message. 1 millisecond is the minimum supported timeout.</p>
<p>Please note that the receive timeout might fire and enqueue the <code>ReceiveTimeout</code> message right after another message was enqueued; hence it is <strong>not guaranteed</strong> that upon reception of the receive timeout there must have been an idle period beforehand as configured via this method.</p>
<p>Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity periods).</p>
<p>To cancel the sending of receive timeout notifications, use <code>cancelReceiveTimeout</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L518-L532" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.actor.ReceiveTimeout
import scala.concurrent.duration._
class MyActor extends Actor {
  // To set an initial delay
  context.setReceiveTimeout(30 milliseconds)
  def receive = {
    case &quot;Hello&quot; =&gt;
      // To set in a response to a message
      context.setReceiveTimeout(100 milliseconds)
    case ReceiveTimeout =&gt;
      // To turn it off
      context.setReceiveTimeout(Duration.Undefined)
      throw new RuntimeException(&quot;Receive timed out&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L549-L582" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class ReceiveTimeoutActor extends AbstractActor {
  public ReceiveTimeoutActor() {
    // To set an initial delay
    getContext().setReceiveTimeout(Duration.ofSeconds(10));
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            &quot;Hello&quot;,
            s -&gt; {
              // To set in a response to a message
              getContext().setReceiveTimeout(Duration.ofSeconds(1));
            })
        .match(
            ReceiveTimeout.class,
            r -&gt; {
              // To turn it off
              getContext().cancelReceiveTimeout();
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Messages marked with <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/NotInfluenceReceiveTimeout.html" title="org.apache.pekko.actor.NotInfluenceReceiveTimeout"><code>NotInfluenceReceiveTimeout</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/NotInfluenceReceiveTimeout.html" title="org.apache.pekko.actor.NotInfluenceReceiveTimeout"><code>NotInfluenceReceiveTimeout</code></a></span> will not reset the timer. This can be useful when <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ReceiveTimeout.html" title="org.apache.pekko.actor.ReceiveTimeout"><code>ReceiveTimeout</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ReceiveTimeout.html" title="org.apache.pekko.actor.ReceiveTimeout"><code>ReceiveTimeout</code></a></span> should be fired by external inactivity but not influenced by internal activity, e.g. scheduled tick messages.</p>
<a id="actors-timers"></a>
<h2><a href="#timers-scheduled-messages" name="timers-scheduled-messages" class="anchor"><span class="anchor-link"></span></a>Timers, scheduled messages</h2>
<p>Messages can be scheduled to be sent at a later point by using the <a href="scheduler.html">Scheduler</a> directly, but when scheduling periodic or single messages in an actor to itself it&rsquo;s more convenient and safe to use the support for named timers. The lifecycle of scheduled messages can be difficult to manage when the actor is restarted and that is taken care of by the timers.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/TimerDocSpec.scala#L18-L41" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import scala.concurrent.duration._

import org.apache.pekko
import pekko.actor.Actor
import pekko.actor.Timers

object MyActor {
  private case object TickKey
  private case object FirstTick
  private case object Tick
}

class MyActor extends Actor with Timers {
  import MyActor._
  timers.startSingleTimer(TickKey, FirstTick, 500.millis)

  def receive = {
    case FirstTick =&gt;
      // do something useful here
      timers.startTimerWithFixedDelay(TickKey, Tick, 1.second)
    case Tick =&gt;
    // do something useful here
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/TimerDocTest.java#L17-L54" target="_blank" title="Go to snippet source">source</a><code class="language-java">import java.time.Duration;
import org.apache.pekko.actor.AbstractActorWithTimers;

static class MyActor extends AbstractActorWithTimers {

  private static Object TICK_KEY = &quot;TickKey&quot;;

  private static final class FirstTick {}

  private static final class Tick {}

  public MyActor() {
    getTimers().startSingleTimer(TICK_KEY, new FirstTick(), Duration.ofMillis(500));
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            FirstTick.class,
            message -&gt; {
              // do something useful here
              getTimers().startTimerWithFixedDelay(TICK_KEY, new Tick(), Duration.ofSeconds(1));
            })
        .match(
            Tick.class,
            message -&gt; {
              // do something useful here
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>The <a href="scheduler.html#schedule-periodically">Scheduler</a> documentation describes the difference between <code>fixed-delay</code> and <code>fixed-rate</code> scheduling. If you are uncertain of which one to use you should pick <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/TimerScheduler.html#startTimerWithFixedDelay(key:Any,msg:Any,initialDelay:scala.concurrent.duration.FiniteDuration,delay:scala.concurrent.duration.FiniteDuration):Unit" title="org.apache.pekko.actor.TimerScheduler"><code>startTimerWithFixedDelay</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/TimerScheduler.html#startTimerWithFixedDelay(java.lang.Object,java.lang.Object,java.time.Duration,java.time.Duration)" title="org.apache.pekko.actor.TimerScheduler"><code>startTimerWithFixedDelay</code></a></span>.</p>
<p>Each timer has a key and can be replaced or cancelled. It&rsquo;s guaranteed that a message from the previous incarnation of the timer with the same key is not received, even though it might already be enqueued in the mailbox when it was cancelled or the new timer was started.</p>
<p>The timers are bound to the lifecycle of the actor that owns it and thus are cancelled automatically when it is restarted or stopped. Note that the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/TimerScheduler.html" title="org.apache.pekko.actor.TimerScheduler"><code>TimerScheduler</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/TimerScheduler.html" title="org.apache.pekko.actor.TimerScheduler"><code>TimerScheduler</code></a></span> is not thread-safe, i.e. it must only be used within the actor that owns it.</p>
<h2><a href="#stopping-actors" name="stopping-actors" class="anchor"><span class="anchor-link"></span></a>Stopping actors</h2>
<p>Actors are stopped by invoking the <code>stop</code> method of a <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRefFactory.html" title="org.apache.pekko.actor.ActorRefFactory"><code>ActorRefFactory</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRefFactory.html" title="org.apache.pekko.actor.ActorRefFactory"><code>ActorRefFactory</code></a></span>, i.e. <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html" title="org.apache.pekko.actor.ActorContext"><code>ActorContext</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html" title="org.apache.pekko.actor.ActorContext"><code>ActorContext</code></a></span> or <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem</code></a></span>. Typically the context is used for stopping the actor itself or child actors and the system for stopping top-level actors. The actual termination of the actor is performed asynchronously, i.e. <code>stop</code> may return before the actor is stopped.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L171-L184" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class MyActor extends Actor {

  val child: ActorRef = ???

  def receive = {
    case &quot;interrupt-child&quot; =&gt;
      context.stop(child)

    case &quot;done&quot; =&gt;
      context.stop(self)
  }

}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/MyStoppingActor.java#L17-L33" target="_blank" title="Go to snippet source">source</a><code class="language-java">import org.apache.pekko.actor.ActorRef;
import org.apache.pekko.actor.AbstractActor;

public class MyStoppingActor extends AbstractActor {

  ActorRef child = null;

  // ... creation of child ...

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(&quot;interrupt-child&quot;, m -&gt; getContext().stop(child))
        .matchEquals(&quot;done&quot;, m -&gt; getContext().stop(getSelf()))
        .build();
  }
}</code></pre></dd>
</dl>
<p>Processing of the current message, if any, will continue before the actor is stopped, but additional messages in the mailbox will not be processed. By default, these messages are sent to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html#deadLetters:org.apache.pekko.actor.ActorRef" title="org.apache.pekko.actor.ActorSystem"><code>deadLetters</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html#deadLetters()" title="org.apache.pekko.actor.ActorSystem"><code>deadLetters</code></a></span> of the <code>ActorSystem</code>, but that depends on the mailbox implementation.</p>
<p>Termination of an actor proceeds in two steps: first the actor suspends its mailbox processing and sends a stop command to all its children, then it keeps processing the internal termination notifications from its children until the last one is gone, finally terminating itself (invoking <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#postStop():Unit" title="pekko.actor.Actor"><code>postStop</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#postStop()" title="pekko.actor.AbstractActor"><code>postStop</code></a></span>, dumping mailbox, publishing <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span> on the <a href="actors.html#deathwatch">DeathWatch</a>, telling its supervisor). This procedure ensures that actor system sub-trees terminate in an orderly fashion, propagating the stop command to the leaves and collecting their confirmation back to the stopped supervisor. If one of the actors do not respond (i.e. processing a message for extended periods of time and therefore not receiving the stop command), this whole process will be stuck.</p>
<p>Upon <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html#terminate():scala.concurrent.Future[actor.Terminated]" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem.terminate()</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorSystem.html#terminate()" title="org.apache.pekko.actor.ActorSystem"><code>ActorSystem.terminate()</code></a></span>, the system guardian actors will be stopped, and the aforementioned process will ensure proper termination of the whole system. See <a href="coordinated-shutdown.html">Coordinated Shutdown</a>.</p>
<p>The <code>postStop()</code> hook is invoked after an actor is fully stopped. This enables cleaning up of resources:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L142-L146" target="_blank" title="Go to snippet source">source</a><code class="language-scala">override def postStop(): Unit = {
  ()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L312-L326" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public void postStop() {
  final String message = &quot;stopped&quot;;
  // don’t forget to think about who is the sender (2nd argument)
  target.tell(message, getSelf());
  final Object result = &quot;&quot;;
  target.forward(result, getContext());
  target = null;
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>Since stopping an actor is asynchronous, you cannot immediately reuse the name of the child you just stopped; this will result in an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/InvalidActorNameException.html" title="org.apache.pekko.actor.InvalidActorNameException"><code>InvalidActorNameException</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/InvalidActorNameException.html" title="org.apache.pekko.actor.InvalidActorNameException"><code>InvalidActorNameException</code></a></span>. Instead, <code>watch()</code> the terminating actor and create its replacement in response to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span> message which will eventually arrive.</p></div>
<a id="poison-pill"></a>
<h3><a href="#poisonpill" name="poisonpill" class="anchor"><span class="anchor-link"></span></a>PoisonPill</h3>
<p>You can also send an actor the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/PoisonPill.html" title="org.apache.pekko.actor.PoisonPill"><code>PoisonPill</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/PoisonPill.html" title="org.apache.pekko.actor.PoisonPill"><code>PoisonPill</code></a></span> message, which will stop the actor when the message is processed. <code>PoisonPill</code> is enqueued as ordinary messages and will be handled after messages that were already queued in the mailbox.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L412-L413" target="_blank" title="Go to snippet source">source</a><code class="language-scala">watch(victim)
victim ! PoisonPill</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L887" target="_blank" title="Go to snippet source">source</a><code class="language-java">victim.tell(org.apache.pekko.actor.PoisonPill.getInstance(), ActorRef.noSender());</code></pre></dd>
</dl>
<a id="killing-actors"></a>
<h3><a href="#killing-an-actor" name="killing-an-actor" class="anchor"><span class="anchor-link"></span></a>Killing an Actor</h3>
<p>You can also &ldquo;kill&rdquo; an actor by sending a <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Kill.html" title="org.apache.pekko.actor.Kill"><code>Kill</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Kill.html" title="org.apache.pekko.actor.Kill"><code>Kill</code></a></span> message. Unlike <code>PoisonPill</code> this will cause the actor to throw a <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorKilledException.html" title="org.apache.pekko.actor.ActorKilledException"><code>ActorKilledException</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorKilledException.html" title="org.apache.pekko.actor.ActorKilledException"><code>ActorKilledException</code></a></span>, triggering a failure. The actor will suspend operation and its supervisor will be asked how to handle the failure, which may mean resuming the actor, restarting it or terminating it completely. See <a href="general/supervision.html#supervision-directives">What Supervision Means</a> for more information.</p>
<p>Use <code>Kill</code> like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L612-L618" target="_blank" title="Go to snippet source">source</a><code class="language-scala">context.watch(victim) // watch the Actor to receive Terminated message once it dies

victim ! Kill

expectMsgPF(hint = &quot;expecting victim to terminate&quot;) {
  case Terminated(v) if v == victim =&gt; v // the Actor has indeed terminated
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L871-L874" target="_blank" title="Go to snippet source">source</a><code class="language-java">victim.tell(org.apache.pekko.actor.Kill.getInstance(), ActorRef.noSender());

// expecting the actor to indeed terminate:
expectTerminated(Duration.ofSeconds(3), victim);</code></pre></dd>
</dl>
<p>In general, it is not recommended to overly rely on either <code>PoisonPill</code> or <code>Kill</code> in designing your actor interactions, as often a protocol-level message like <code>PleaseCleanupAndStop</code> which the actor knows how to handle is encouraged. The messages are there for being able to stop actors over which design you do not have control over.</p>
<h3><a href="#graceful-stop" name="graceful-stop" class="anchor"><span class="anchor-link"></span></a>Graceful Stop</h3>
<p><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/pattern/GracefulStopSupport.html#gracefulStop(target:org.apache.pekko.actor.ActorRef,timeout:scala.concurrent.duration.FiniteDuration,stopMessage:Any):scala.concurrent.Future[Boolean]" title="pekko.pattern.GracefulStopSupport"><code>gracefulStop</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/pattern/Patterns.html#gracefulStop(org.apache.pekko.actor.ActorRef,scala.concurrent.duration.FiniteDuration,java.lang.Object)" title="pekko.pattern.Patterns"><code>gracefulStop</code></a></span> is useful if you need to wait for termination or compose ordered termination of several actors:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L675-L685" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.pattern.gracefulStop
import scala.concurrent.Await

try {
  val stopped: Future[Boolean] = gracefulStop(actorRef, 5 seconds, Manager.Shutdown)
  Await.result(stopped, 6 seconds)
  // the actor has been stopped
} catch {
  // the actor wasn&#39;t stopped within 5 seconds
  case e: pekko.pattern.AskTimeoutException =&gt;
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L54-L57" target="_blank" title="Go to snippet source">source</a><code class="language-java">import static org.apache.pekko.pattern.Patterns.gracefulStop;
import org.apache.pekko.pattern.AskTimeoutException;
import java.util.concurrent.CompletionStage;

try {
  CompletionStage&lt;Boolean&gt; stopped =
      gracefulStop(actorRef, Duration.ofSeconds(5), Manager.SHUTDOWN);
  stopped.toCompletableFuture().get(6, TimeUnit.SECONDS);
  // the actor has been stopped
} catch (AskTimeoutException e) {
  // the actor wasn&#39;t stopped within 5 seconds
}</code></pre></dd>
</dl>
<p>When <code>gracefulStop()</code> returns successfully, the actor’s <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#postStop():Unit" title="pekko.actor.Actor"><code>postStop</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#postStop()" title="pekko.actor.AbstractActor"><code>postStop</code></a></span> hook will have been executed: there exists a happens-before edge between the end of <code>postStop()</code> and the return of <code>gracefulStop()</code>.</p>
<p>In the above example, a custom <code>Manager.Shutdown</code> message is sent to the target actor to initiate the process of stopping the actor. You can use <code>PoisonPill</code> for this, but then you have limited possibilities to perform interactions with other actors before stopping the target actor. Simple cleanup tasks can be handled in <code>postStop</code>.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Keep in mind that an actor stopping and its name being deregistered are separate events that happen asynchronously from each other. Therefore it may be that you will find the name still in use after <code>gracefulStop()</code> returned. To guarantee proper deregistration, only reuse names from within a supervisor you control and only in response to a <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Terminated.html" title="org.apache.pekko.actor.Terminated"><code>Terminated</code></a></span> message, i.e. not for top-level actors.</p></div>
<a id="actor-hotswap"></a>
<h2><a href="#become-unbecome" name="become-unbecome" class="anchor"><span class="anchor-link"></span></a>Become/Unbecome</h2>
<h3><a href="#upgrade" name="upgrade" class="anchor"><span class="anchor-link"></span></a>Upgrade</h3>
<p>Pekko supports hotswapping the Actor’s message loop (e.g. its implementation) at runtime: invoke the <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#become(behavior:org.apache.pekko.actor.Actor.Receive,discardOld:Boolean):Unit" title="org.apache.pekko.actor.ActorContext"><code>context.become</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#become(scala.PartialFunction,boolean)" title="org.apache.pekko.actor.ActorContext"><code>context.become</code></a></span> method from within the Actor. <code>become</code> takes a <span class="group-scala"><code>PartialFunction[Any, Unit]</code></span> <span class="group-java"><code>PartialFunction&lt;Object, BoxedUnit&gt;</code></span> that implements the new message handler. The hotswapped code is kept in a Stack that can be pushed and popped.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Please note that the actor will revert to its original behavior when restarted by its Supervisor.</p></div>
<p>To hotswap the Actor behavior using <code>become</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L537-L553" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class HotSwapActor extends Actor {
  import context._
  def angry: Receive = {
    case &quot;foo&quot; =&gt; sender() ! &quot;I am already angry?&quot;
    case &quot;bar&quot; =&gt; become(happy)
  }

  def happy: Receive = {
    case &quot;bar&quot; =&gt; sender() ! &quot;I am already happy :-)&quot;
    case &quot;foo&quot; =&gt; become(angry)
  }

  def receive = {
    case &quot;foo&quot; =&gt; become(angry)
    case &quot;bar&quot; =&gt; become(happy)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L639-L680" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class HotSwapActor extends AbstractActor {
  private AbstractActor.Receive angry;
  private AbstractActor.Receive happy;

  public HotSwapActor() {
    angry =
        receiveBuilder()
            .matchEquals(
                &quot;foo&quot;,
                s -&gt; {
                  getSender().tell(&quot;I am already angry?&quot;, getSelf());
                })
            .matchEquals(
                &quot;bar&quot;,
                s -&gt; {
                  getContext().become(happy);
                })
            .build();

    happy =
        receiveBuilder()
            .matchEquals(
                &quot;bar&quot;,
                s -&gt; {
                  getSender().tell(&quot;I am already happy :-)&quot;, getSelf());
                })
            .matchEquals(
                &quot;foo&quot;,
                s -&gt; {
                  getContext().become(angry);
                })
            .build();
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(&quot;foo&quot;, s -&gt; getContext().become(angry))
        .matchEquals(&quot;bar&quot;, s -&gt; getContext().become(happy))
        .build();
  }
}</code></pre></dd>
</dl>
<p>This variant of the <code>become</code> method is useful for many different things, such as to implement a Finite State Machine (FSM). It will replace the current behavior (i.e. the top of the behavior stack), which means that you do not use <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#unbecome():Unit" title="org.apache.pekko.actor.ActorContext"><code>unbecome</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#unbecome()" title="org.apache.pekko.actor.ActorContext"><code>unbecome</code></a></span>, instead always the next behavior is explicitly installed.</p>
<p>The other way of using <code>become</code> does not replace but add to the top of the behavior stack. In this case, care must be taken to ensure that the number of “pop” operations (i.e. <code>unbecome</code>) matches the number of “push” ones in the long run, otherwise this amounts to a memory leak (which is why this behavior is not the default).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L219-L244" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case object Swap
class Swapper extends Actor {
  import context._
  val log = Logging(system, this)

  def receive = {
    case Swap =&gt;
      log.info(&quot;Hi&quot;)
      become({
          case Swap =&gt;
            log.info(&quot;Ho&quot;)
            unbecome() // resets the latest &#39;become&#39; (just for fun)
        }, discardOld = false) // push on top instead of replace
  }
}

object SwapperApp extends App {
  val system = ActorSystem(&quot;SwapperSystem&quot;)
  val swap = system.actorOf(Props[Swapper](), name = &quot;swapper&quot;)
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L439-L479" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class Swapper extends AbstractLoggingActor {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            Swap,
            s -&gt; {
              log().info(&quot;Hi&quot;);
              getContext()
                  .become(
                      receiveBuilder()
                          .matchEquals(
                              Swap,
                              x -&gt; {
                                log().info(&quot;Ho&quot;);
                                getContext()
                                    .unbecome(); // resets the latest &#39;become&#39; (just for fun)
                              })
                          .build(),
                      false); // push on top instead of replace
            })
        .build();
  }
}

static class SwapperApp {
  public static void main(String[] args) {
    ActorSystem system = ActorSystem.create(&quot;SwapperSystem&quot;);
    ActorRef swapper = system.actorOf(Props.create(Swapper.class), &quot;swapper&quot;);
    swapper.tell(Swap, ActorRef.noSender()); // logs Hi
    swapper.tell(Swap, ActorRef.noSender()); // logs Ho
    swapper.tell(Swap, ActorRef.noSender()); // logs Hi
    swapper.tell(Swap, ActorRef.noSender()); // logs Ho
    swapper.tell(Swap, ActorRef.noSender()); // logs Hi
    swapper.tell(Swap, ActorRef.noSender()); // logs Ho
    system.terminate();
  }
}</code></pre></dd>
</dl>
<h3><a href="#encoding-scala-actors-nested-receives-without-accidentally-leaking-memory" name="encoding-scala-actors-nested-receives-without-accidentally-leaking-memory" class="anchor"><span class="anchor-link"></span></a>Encoding Scala Actors nested receives without accidentally leaking memory</h3>
<p>See this <a href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/UnnestedReceives.scala">Unnested receive example</a>.</p>
<h2><a href="#stash" name="stash" class="anchor"><span class="anchor-link"></span></a>Stash</h2>
<p>The <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Stash.html" title="pekko.actor.Stash"><code>Stash</code></a> trait</span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActorWithStash.html" title="pekko.actor.AbstractActorWithStash"><code>AbstractActorWithStash</code></a> class</span> enables an actor to temporarily stash away messages that can not or should not be handled using the actor&rsquo;s current behavior. Upon changing the actor&rsquo;s message handler, i.e., right before invoking <span class="group-scala"><code>context.become</code> or <code>context.unbecome</code></span> <span class="group-java"><code>getContext().become()</code> or <code>getContext().unbecome()</code></span>, all stashed messages can be &ldquo;unstashed&rdquo;, thereby prepending them to the actor&rsquo;s mailbox. This way, the stashed messages can be processed in the same order as they have been received originally. <span class="group-java">An actor that extends <code>AbstractActorWithStash</code> will automatically get a deque-based mailbox.</span></p><div class="callout note group-scala"><div class="callout-title">Note</div>
<p>The trait <code>Stash</code> extends the marker trait <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/dispatch/RequiresMessageQueue.html" title="pekko.dispatch.RequiresMessageQueue"><code>RequiresMessageQueue</code></a>[<a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/dispatch/DequeBasedMessageQueueSemantics.html" title="org.apache.pekko.dispatch.DequeBasedMessageQueueSemantics"><code>DequeBasedMessageQueueSemantics</code></a>] which requests the system to automatically choose a deque based mailbox implementation for the actor. If you want more control over the mailbox, see the documentation on mailboxes: <a href="mailboxes.html">Mailboxes</a>.</p></div><div class="callout note group-java"><div class="callout-title">Note</div>
<p>The abstract class <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActorWithStash.html" title="pekko.actor.AbstractActorWithStash"><code>AbstractActorWithStash</code></a> implements the marker interface <a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/dispatch/RequiresMessageQueue.html" title="pekko.dispatch.RequiresMessageQueue"><code>RequiresMessageQueue</code></a>&lt;<a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/dispatch/DequeBasedMessageQueueSemantics.html" title="pekko.dispatch.DequeBasedMessageQueueSemantics"><code>DequeBasedMessageQueueSemantics</code></a>&gt; which requests the system to automatically choose a deque based mailbox implementation for the actor. If you want more control over the mailbox, see the documentation on mailboxes: <a href="mailboxes.html">Mailboxes</a>.</p></div>
<p>Here is an example of the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Stash.html" title="pekko.actor.Stash"><code>Stash</code></a> trait</span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActorWithStash.html" title="pekko.actor.AbstractActorWithStash"><code>AbstractActorWithStash</code></a> class</span> in action:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L562-L576" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import org.apache.pekko.actor.Stash
class ActorWithProtocol extends Actor with Stash {
  def receive = {
    case &quot;open&quot; =&gt;
      unstashAll()
      context.become({
          case &quot;write&quot; =&gt; // do writing...
          case &quot;close&quot; =&gt;
            unstashAll()
            context.unbecome()
          case msg =&gt; stash()
        }, discardOld = false) // stack on top instead of replacing
    case msg =&gt; stash()
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/ActorDocTest.java#L704-L732" target="_blank" title="Go to snippet source">source</a><code class="language-java">static class ActorWithProtocol extends AbstractActorWithStash {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            &quot;open&quot;,
            s -&gt; {
              getContext()
                  .become(
                      receiveBuilder()
                          .matchEquals(
                              &quot;write&quot;,
                              ws -&gt; {
                                /* do writing */
                              })
                          .matchEquals(
                              &quot;close&quot;,
                              cs -&gt; {
                                unstashAll();
                                getContext().unbecome();
                              })
                          .matchAny(msg -&gt; stash())
                          .build(),
                      false);
            })
        .matchAny(msg -&gt; stash())
        .build();
  }
}</code></pre></dd>
</dl>
<p>Invoking <code>stash()</code> adds the current message (the message that the actor received last) to the actor&rsquo;s stash. It is typically invoked when handling the default case in the actor&rsquo;s message handler to stash messages that aren&rsquo;t handled by the other cases. It is illegal to stash the same message twice; to do so results in an <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalStateException.html" title="java.lang.IllegalStateException"><code>IllegalStateException</code></a> being thrown. The stash may also be bounded in which case invoking <code>stash()</code> may lead to a capacity violation, which results in a <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/StashOverflowException.html" title="org.apache.pekko.actor.StashOverflowException"><code>StashOverflowException</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/StashOverflowException.html" title="org.apache.pekko.actor.StashOverflowException"><code>StashOverflowException</code></a></span>. The capacity of the stash can be configured using the <code>stash-capacity</code> setting (an <code>Int</code>) of the mailbox&rsquo;s configuration.</p>
<p>Invoking <code>unstashAll()</code> enqueues messages from the stash to the actor&rsquo;s mailbox until the capacity of the mailbox (if any) has been reached (note that messages from the stash are prepended to the mailbox). In case a bounded mailbox overflows, a <code>MessageQueueAppendFailedException</code> is thrown. The stash is guaranteed to be empty after calling <code>unstashAll()</code>.</p>
<p>The stash is backed by a <a href="http://www.scala-lang.org/api/2.13.8/scala/collection/immutable/Vector.html" title="scala.collection.immutable.Vector"><code>scala.collection.immutable.Vector</code></a>. As a result, even a very large number of messages may be stashed without a major impact on performance.</p><div class="callout warning group-scala"><div class="callout-title">Warning</div>
<p>Note that the <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Stash.html" title="pekko.actor.Stash"><code>Stash</code></a> trait must be mixed into (a subclass of) the <a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html" title="pekko.actor.Actor"><code>Actor</code></a> trait before any trait/class that overrides the <a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/Actor.html#preRestart(reason:Throwable,message:Option[Any]):Unit" title="org.apache.pekko.actor.Actor"><code>preRestart</code></a>] callback. This means it&rsquo;s not possible to write <code>Actor with MyActor with Stash</code> if <code>MyActor</code> overrides <code>preRestart</code>.</p></div>
<p>Note that the stash is part of the ephemeral actor state, unlike the mailbox. Therefore, it should be managed like other parts of the actor&rsquo;s state which have the same property.</p>
<p>However, the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Stash.html" title="pekko.actor.Stash"><code>Stash</code></a> trait</span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActorWithStash.html" title="pekko.actor.AbstractActorWithStash"><code>AbstractActorWithStash</code></a> class</span> implementation of <code>preRestart</code> will call <code>unstashAll()</code>. This means that before the actor restarts, it will transfer all stashed messages back to the actor&rsquo;s mailbox.</p>
<p>The result of this is that when an actor is restarted, any stashed messages will be delivered to the new incarnation of the actor. This is usually the desired behavior.</p><div class="callout note "><div class="callout-title">Note</div>
<p>If you want to enforce that your actor can only work with an unbounded stash, then you should use the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/UnboundedStash.html" title="pekko.actor.UnboundedStash"><code>UnboundedStash</code></a> trait</span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActorWithUnboundedStash.html" title="pekko.actor.AbstractActorWithUnboundedStash"><code>AbstractActorWithUnboundedStash</code></a> class</span> instead.</p></div><div class="group-scala">
<h2><a href="#extending-actors-using-partialfunction-chaining" name="extending-actors-using-partialfunction-chaining" class="anchor"><span class="anchor-link"></span></a>Extending Actors using PartialFunction chaining</h2>
<p>Sometimes it can be useful to share common behavior among a few actors, or compose one actor&rsquo;s behavior from multiple smaller functions. This is possible because an actor&rsquo;s <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#receive:org.apache.pekko.actor.Actor.Receive" title="pekko.actor.Actor"><code>receive</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#createReceive()" title="pekko.actor.AbstractActor"><code>createReceive</code></a></span> method returns an <code>Actor.Receive</code>, which is a type alias for <code>PartialFunction[Any,Unit]</code>, and partial functions can be chained together using the <code>PartialFunction#orElse</code> method. You can chain as many functions as you need, however you should keep in mind that &ldquo;first match&rdquo; wins - which may be important when combining functions that both can handle the same type of message.</p>
<p>For example, imagine you have a set of actors which are either <code>Producers</code> or <code>Consumers</code>, yet sometimes it makes sense to have an actor share both behaviors. This can be achieved without having to duplicate code by extracting the behaviors to traits and implementing the actor&rsquo;s <code>receive</code> as a combination of these partial functions.</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/ActorDocSpec.scala#L248-L286" target="_blank" title="Go to snippet source">source</a><code class="language-scala"><br/>trait ProducerBehavior {
  this: Actor =&gt;

  val producerBehavior: Receive = {
    case GiveMeThings =&gt;
      sender() ! Give(&quot;thing&quot;)
  }
}

trait ConsumerBehavior {
  this: Actor with ActorLogging =&gt;

  val consumerBehavior: Receive = {
    case ref: ActorRef =&gt;
      ref ! GiveMeThings

    case Give(thing) =&gt;
      log.info(&quot;Got a thing! It&#39;s {}&quot;, thing)
  }
}

class Producer extends Actor with ProducerBehavior {
  def receive = producerBehavior
}

class Consumer extends Actor with ActorLogging with ConsumerBehavior {
  def receive = consumerBehavior
}

class ProducerConsumer extends Actor with ActorLogging with ProducerBehavior with ConsumerBehavior {

  def receive = producerBehavior.orElse[Any, Unit](consumerBehavior)
}

// protocol
case object GiveMeThings
final case class Give(thing: Any)
</code></pre>
<p>Instead of inheritance the same pattern can be applied via composition - compose the receive method using partial functions from delegates.</p></div>
<h2><a href="#initialization-patterns" name="initialization-patterns" class="anchor"><span class="anchor-link"></span></a>Initialization patterns</h2>
<p>The rich lifecycle hooks of Actors provide a useful toolkit to implement various initialization patterns. During the lifetime of an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span>, an actor can potentially go through several restarts, where the old instance is replaced by a fresh one, invisibly to the outside observer who only sees the <code>ActorRef</code>.</p>
<p>Initialization might be necessary every time an actor is instantiated, but sometimes one needs initialization to happen only at the birth of the first instance when the <code>ActorRef</code> is created. The following sections provide patterns for different initialization needs.</p>
<h3><a href="#initialization-via-constructor" name="initialization-via-constructor" class="anchor"><span class="anchor-link"></span></a>Initialization via constructor</h3>
<p>Using the constructor for initialization has various benefits. First of all, it makes it possible to use <code>val</code> fields to store any state that does not change during the life of the actor instance, making the implementation of the actor more robust. The constructor is invoked when an actor instance is created calling <code>actorOf</code> and also on restart, therefore the internals of the actor can always assume that proper initialization happened. This is also the drawback of this approach, as there are cases when one would like to avoid reinitializing internals on restart. For example, it is often useful to preserve child actors across restarts. The following section provides a pattern for this case.</p>
<h3><a href="#initialization-via-prestart" name="initialization-via-prestart" class="anchor"><span class="anchor-link"></span></a>Initialization via preStart</h3>
<p>The method <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#preStart():Unit" title="pekko.actor.Actor"><code>preStart</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#preStart()" title="pekko.actor.AbstractActor"><code>preStart</code></a></span> of an actor is only called once directly during the initialization of the first instance, that is, at the creation of its <code>ActorRef</code>. In the case of restarts, <code>preStart()</code> is called from <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#postRestart(reason:Throwable):Unit" title="pekko.actor.Actor"><code>postRestart</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#postRestart(java.lang.Throwable)" title="pekko.actor.AbstractActor"><code>postRestart</code></a></span>, therefore if not overridden, <code>preStart()</code> is called on every restart. However, by overriding <code>postRestart()</code> one can disable this behavior, and ensure that there is only one call to <code>preStart()</code>.</p>
<p>One useful usage of this pattern is to disable creation of new <code>ActorRefs</code> for children during restarts. This can be achieved by overriding <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.6/org/apache/pekko/actor/Actor.html#preRestart(reason:Throwable,message:Option[Any]):Unit" title="pekko.actor.Actor"><code>preRestart</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.6/org/apache/pekko/actor/AbstractActor.html#preRestart(java.lang.Throwable,java.util.Optional)" title="pekko.actor.AbstractActor"><code>preRestart</code></a></span>. Below is the default implementation of these lifecycle hooks:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/InitializationDocSpec.scala#L27-L41" target="_blank" title="Go to snippet source">source</a><code class="language-scala">override def preStart(): Unit = {
  // Initialize children here
}

// Overriding postRestart to disable the call to preStart()
// after restarts
override def postRestart(reason: Throwable): Unit = ()

// The default implementation of preRestart() stops all the children
// of the actor. To opt-out from stopping the children, we
// have to override preRestart()
override def preRestart(reason: Throwable, message: Option[Any]): Unit = {
  // Keep the call to postStop(), but no stopping of children
  postStop()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/InitializationDocTest.java#L52-L69" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public void preStart() {
  // Initialize children here
}

// Overriding postRestart to disable the call to preStart()
// after restarts
@Override
public void postRestart(Throwable reason) {}

// The default implementation of preRestart() stops all the children
// of the actor. To opt-out from stopping the children, we
// have to override preRestart()
@Override
public void preRestart(Throwable reason, Optional&lt;Object&gt; message) throws Exception {
  // Keep the call to postStop(), but no stopping of children
  postStop();
}</code></pre></dd>
</dl>
<p>Please note, that the child actors are <em>still restarted</em>, but no new <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span> is created. One can recursively apply the same principles for the children, ensuring that their <code>preStart()</code> method is called only at the creation of their refs.</p>
<p>For more information see <a href="general/supervision.html#supervision-restart">What Restarting Means</a>.</p>
<h3><a href="#initialization-via-message-passing" name="initialization-via-message-passing" class="anchor"><span class="anchor-link"></span></a>Initialization via message passing</h3>
<p>There are cases when it is impossible to pass all the information needed for actor initialization in the constructor, for example in the presence of circular dependencies. In this case, the actor should listen for an initialization message, and use <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#become(behavior:org.apache.pekko.actor.Actor.Receive,discardOld:Boolean):Unit" title="org.apache.pekko.actor.ActorContext"><code>become()</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorContext.html#become(scala.PartialFunction,boolean)" title="org.apache.pekko.actor.ActorContext"><code>become()</code></a></span> or a finite state-machine state transition to encode the initialized and uninitialized states of the actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/scala/docs/actor/InitializationDocSpec.scala#L47-L58" target="_blank" title="Go to snippet source">source</a><code class="language-scala">var initializeMe: Option[String] = None

override def receive = {
  case &quot;init&quot; =&gt;
    initializeMe = Some(&quot;Up and running&quot;)
    context.become(initialized, discardOld = true)

}

def initialized: Receive = {
  case &quot;U OK?&quot; =&gt; initializeMe.foreach { sender() ! _ }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/test/java/jdocs/actor/InitializationDocTest.java#L78-L96" target="_blank" title="Go to snippet source">source</a><code class="language-java">@Override
public Receive createReceive() {
  return receiveBuilder()
      .matchEquals(
          &quot;init&quot;,
          m1 -&gt; {
            initializeMe = &quot;Up and running&quot;;
            getContext()
                .become(
                    receiveBuilder()
                        .matchEquals(
                            &quot;U OK?&quot;,
                            m2 -&gt; {
                              getSender().tell(initializeMe, getSelf());
                            })
                        .build());
          })
      .build();
}</code></pre></dd>
</dl>
<p>If the actor may receive messages before it has been initialized, a useful tool can be the <code>Stash</code> to save messages until the initialization finishes, and replaying them after the actor became initialized.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>This pattern should be used with care, and applied only when none of the patterns above are applicable. One of the potential issues is that messages might be lost when sent to remote actors. Also, publishing an <span class="group-scala"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span><span class="group-java"><a href="https://doc.akka.io/api/akka/HEAD+20230118-1331/org/apache/pekko/actor/ActorRef.html" title="org.apache.pekko.actor.ActorRef"><code>ActorRef</code></a></span> in an uninitialized state might lead to the condition that it receives a user message before the initialization has been done.</p></div>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/akka/akka/tree/vHEAD+20230118-1331/docs/src/main/paradox/actors.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="supervision-classic.html">Classic Supervision</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="actors.html#classic-actors" class="header">Classic Actors</a>
  <ul>
    <li><a href="actors.html#module-info" class="header">Module info</a></li>
    <li><a href="actors.html#introduction" class="header">Introduction</a></li>
    <li><a href="actors.html#creating-actors" class="header">Creating Actors</a></li>
    <li><a href="actors.html#actor-api" class="header">Actor API</a></li>
    <li><a href="actors.html#identifying-actors-via-actor-selection" class="header">Identifying Actors via Actor Selection</a></li>
    <li><a href="actors.html#messages-and-immutability" class="header">Messages and immutability</a></li>
    <li><a href="actors.html#send-messages" class="header">Send messages</a></li>
    <li><a href="actors.html#receive-messages" class="header">Receive messages</a></li>
    <li><a href="actors.html#reply-to-messages" class="header">Reply to messages</a></li>
    <li><a href="actors.html#receive-timeout" class="header">Receive timeout</a></li>
    <li><a href="actors.html#timers-scheduled-messages" class="header">Timers, scheduled messages</a></li>
    <li><a href="actors.html#stopping-actors" class="header">Stopping actors</a></li>
    <li><a href="actors.html#become-unbecome" class="header">Become/Unbecome</a></li>
    <li><a href="actors.html#stash" class="header">Stash</a></li>
    <li><a href="actors.html#extending-actors-using-partialfunction-chaining" class="header group-scala">Extending Actors using PartialFunction chaining</a></li>
    <li><a href="actors.html#initialization-patterns" class="header">Initialization patterns</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2023</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, 'HEAD+20230118-1331', 'https://akka.io/')});</script>


</html>
